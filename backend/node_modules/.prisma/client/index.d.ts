
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model app_usuario
 * 
 */
export type app_usuario = $Result.DefaultSelection<Prisma.$app_usuarioPayload>
/**
 * Model app_clinica
 * 
 */
export type app_clinica = $Result.DefaultSelection<Prisma.$app_clinicaPayload>
/**
 * Model app_log_acao
 * 
 */
export type app_log_acao = $Result.DefaultSelection<Prisma.$app_log_acaoPayload>
/**
 * Model app_conversa
 * 
 */
export type app_conversa = $Result.DefaultSelection<Prisma.$app_conversaPayload>
/**
 * Model app_mensagem
 * 
 */
export type app_mensagem = $Result.DefaultSelection<Prisma.$app_mensagemPayload>
/**
 * Model app_mensagem_sugestao
 * 
 */
export type app_mensagem_sugestao = $Result.DefaultSelection<Prisma.$app_mensagem_sugestaoPayload>
/**
 * Model app_midia
 * 
 */
export type app_midia = $Result.DefaultSelection<Prisma.$app_midiaPayload>
/**
 * Model app_paciente
 * 
 */
export type app_paciente = $Result.DefaultSelection<Prisma.$app_pacientePayload>
/**
 * Model app_paciente_clinica
 * 
 */
export type app_paciente_clinica = $Result.DefaultSelection<Prisma.$app_paciente_clinicaPayload>
/**
 * Model app_resposta_pronta
 * 
 */
export type app_resposta_pronta = $Result.DefaultSelection<Prisma.$app_resposta_prontaPayload>
/**
 * Model app_tag
 * 
 */
export type app_tag = $Result.DefaultSelection<Prisma.$app_tagPayload>
/**
 * Model consultas
 * 
 */
export type consultas = $Result.DefaultSelection<Prisma.$consultasPayload>
/**
 * Model conversations
 * 
 */
export type conversations = $Result.DefaultSelection<Prisma.$conversationsPayload>
/**
 * Model documents
 * 
 */
export type documents = $Result.DefaultSelection<Prisma.$documentsPayload>
/**
 * Model especialidades
 * 
 */
export type especialidades = $Result.DefaultSelection<Prisma.$especialidadesPayload>
/**
 * Model medico_procedimentos
 * 
 */
export type medico_procedimentos = $Result.DefaultSelection<Prisma.$medico_procedimentosPayload>
/**
 * Model medico_sintomas
 * 
 */
export type medico_sintomas = $Result.DefaultSelection<Prisma.$medico_sintomasPayload>
/**
 * Model medicos
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type medicos = $Result.DefaultSelection<Prisma.$medicosPayload>
/**
 * Model n8n_chat_histories
 * 
 */
export type n8n_chat_histories = $Result.DefaultSelection<Prisma.$n8n_chat_historiesPayload>
/**
 * Model pacientes
 * 
 */
export type pacientes = $Result.DefaultSelection<Prisma.$pacientesPayload>
/**
 * Model procedimentos
 * 
 */
export type procedimentos = $Result.DefaultSelection<Prisma.$procedimentosPayload>
/**
 * Model schema_migrations
 * 
 */
export type schema_migrations = $Result.DefaultSelection<Prisma.$schema_migrationsPayload>
/**
 * Model sintomas
 * 
 */
export type sintomas = $Result.DefaultSelection<Prisma.$sintomasPayload>
/**
 * Model agent_control
 * 
 */
export type agent_control = $Result.DefaultSelection<Prisma.$agent_controlPayload>
/**
 * Model app_grupo
 * 
 */
export type app_grupo = $Result.DefaultSelection<Prisma.$app_grupoPayload>
/**
 * Model app_receipt
 * 
 */
export type app_receipt = $Result.DefaultSelection<Prisma.$app_receiptPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more App_usuarios
 * const app_usuarios = await prisma.app_usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more App_usuarios
   * const app_usuarios = await prisma.app_usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.app_usuario`: Exposes CRUD operations for the **app_usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_usuarios
    * const app_usuarios = await prisma.app_usuario.findMany()
    * ```
    */
  get app_usuario(): Prisma.app_usuarioDelegate<ExtArgs>;

  /**
   * `prisma.app_clinica`: Exposes CRUD operations for the **app_clinica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_clinicas
    * const app_clinicas = await prisma.app_clinica.findMany()
    * ```
    */
  get app_clinica(): Prisma.app_clinicaDelegate<ExtArgs>;

  /**
   * `prisma.app_log_acao`: Exposes CRUD operations for the **app_log_acao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_log_acaos
    * const app_log_acaos = await prisma.app_log_acao.findMany()
    * ```
    */
  get app_log_acao(): Prisma.app_log_acaoDelegate<ExtArgs>;

  /**
   * `prisma.app_conversa`: Exposes CRUD operations for the **app_conversa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_conversas
    * const app_conversas = await prisma.app_conversa.findMany()
    * ```
    */
  get app_conversa(): Prisma.app_conversaDelegate<ExtArgs>;

  /**
   * `prisma.app_mensagem`: Exposes CRUD operations for the **app_mensagem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_mensagems
    * const app_mensagems = await prisma.app_mensagem.findMany()
    * ```
    */
  get app_mensagem(): Prisma.app_mensagemDelegate<ExtArgs>;

  /**
   * `prisma.app_mensagem_sugestao`: Exposes CRUD operations for the **app_mensagem_sugestao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_mensagem_sugestaos
    * const app_mensagem_sugestaos = await prisma.app_mensagem_sugestao.findMany()
    * ```
    */
  get app_mensagem_sugestao(): Prisma.app_mensagem_sugestaoDelegate<ExtArgs>;

  /**
   * `prisma.app_midia`: Exposes CRUD operations for the **app_midia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_midias
    * const app_midias = await prisma.app_midia.findMany()
    * ```
    */
  get app_midia(): Prisma.app_midiaDelegate<ExtArgs>;

  /**
   * `prisma.app_paciente`: Exposes CRUD operations for the **app_paciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_pacientes
    * const app_pacientes = await prisma.app_paciente.findMany()
    * ```
    */
  get app_paciente(): Prisma.app_pacienteDelegate<ExtArgs>;

  /**
   * `prisma.app_paciente_clinica`: Exposes CRUD operations for the **app_paciente_clinica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_paciente_clinicas
    * const app_paciente_clinicas = await prisma.app_paciente_clinica.findMany()
    * ```
    */
  get app_paciente_clinica(): Prisma.app_paciente_clinicaDelegate<ExtArgs>;

  /**
   * `prisma.app_resposta_pronta`: Exposes CRUD operations for the **app_resposta_pronta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_resposta_prontas
    * const app_resposta_prontas = await prisma.app_resposta_pronta.findMany()
    * ```
    */
  get app_resposta_pronta(): Prisma.app_resposta_prontaDelegate<ExtArgs>;

  /**
   * `prisma.app_tag`: Exposes CRUD operations for the **app_tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_tags
    * const app_tags = await prisma.app_tag.findMany()
    * ```
    */
  get app_tag(): Prisma.app_tagDelegate<ExtArgs>;

  /**
   * `prisma.consultas`: Exposes CRUD operations for the **consultas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultas
    * const consultas = await prisma.consultas.findMany()
    * ```
    */
  get consultas(): Prisma.consultasDelegate<ExtArgs>;

  /**
   * `prisma.conversations`: Exposes CRUD operations for the **conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversations.findMany()
    * ```
    */
  get conversations(): Prisma.conversationsDelegate<ExtArgs>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.documentsDelegate<ExtArgs>;

  /**
   * `prisma.especialidades`: Exposes CRUD operations for the **especialidades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especialidades
    * const especialidades = await prisma.especialidades.findMany()
    * ```
    */
  get especialidades(): Prisma.especialidadesDelegate<ExtArgs>;

  /**
   * `prisma.medico_procedimentos`: Exposes CRUD operations for the **medico_procedimentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medico_procedimentos
    * const medico_procedimentos = await prisma.medico_procedimentos.findMany()
    * ```
    */
  get medico_procedimentos(): Prisma.medico_procedimentosDelegate<ExtArgs>;

  /**
   * `prisma.medico_sintomas`: Exposes CRUD operations for the **medico_sintomas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medico_sintomas
    * const medico_sintomas = await prisma.medico_sintomas.findMany()
    * ```
    */
  get medico_sintomas(): Prisma.medico_sintomasDelegate<ExtArgs>;

  /**
   * `prisma.medicos`: Exposes CRUD operations for the **medicos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicos
    * const medicos = await prisma.medicos.findMany()
    * ```
    */
  get medicos(): Prisma.medicosDelegate<ExtArgs>;

  /**
   * `prisma.n8n_chat_histories`: Exposes CRUD operations for the **n8n_chat_histories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more N8n_chat_histories
    * const n8n_chat_histories = await prisma.n8n_chat_histories.findMany()
    * ```
    */
  get n8n_chat_histories(): Prisma.n8n_chat_historiesDelegate<ExtArgs>;

  /**
   * `prisma.pacientes`: Exposes CRUD operations for the **pacientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pacientes
    * const pacientes = await prisma.pacientes.findMany()
    * ```
    */
  get pacientes(): Prisma.pacientesDelegate<ExtArgs>;

  /**
   * `prisma.procedimentos`: Exposes CRUD operations for the **procedimentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedimentos
    * const procedimentos = await prisma.procedimentos.findMany()
    * ```
    */
  get procedimentos(): Prisma.procedimentosDelegate<ExtArgs>;

  /**
   * `prisma.schema_migrations`: Exposes CRUD operations for the **schema_migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schema_migrations
    * const schema_migrations = await prisma.schema_migrations.findMany()
    * ```
    */
  get schema_migrations(): Prisma.schema_migrationsDelegate<ExtArgs>;

  /**
   * `prisma.sintomas`: Exposes CRUD operations for the **sintomas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sintomas
    * const sintomas = await prisma.sintomas.findMany()
    * ```
    */
  get sintomas(): Prisma.sintomasDelegate<ExtArgs>;

  /**
   * `prisma.agent_control`: Exposes CRUD operations for the **agent_control** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agent_controls
    * const agent_controls = await prisma.agent_control.findMany()
    * ```
    */
  get agent_control(): Prisma.agent_controlDelegate<ExtArgs>;

  /**
   * `prisma.app_grupo`: Exposes CRUD operations for the **app_grupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_grupos
    * const app_grupos = await prisma.app_grupo.findMany()
    * ```
    */
  get app_grupo(): Prisma.app_grupoDelegate<ExtArgs>;

  /**
   * `prisma.app_receipt`: Exposes CRUD operations for the **app_receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_receipts
    * const app_receipts = await prisma.app_receipt.findMany()
    * ```
    */
  get app_receipt(): Prisma.app_receiptDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    app_usuario: 'app_usuario',
    app_clinica: 'app_clinica',
    app_log_acao: 'app_log_acao',
    app_conversa: 'app_conversa',
    app_mensagem: 'app_mensagem',
    app_mensagem_sugestao: 'app_mensagem_sugestao',
    app_midia: 'app_midia',
    app_paciente: 'app_paciente',
    app_paciente_clinica: 'app_paciente_clinica',
    app_resposta_pronta: 'app_resposta_pronta',
    app_tag: 'app_tag',
    consultas: 'consultas',
    conversations: 'conversations',
    documents: 'documents',
    especialidades: 'especialidades',
    medico_procedimentos: 'medico_procedimentos',
    medico_sintomas: 'medico_sintomas',
    medicos: 'medicos',
    n8n_chat_histories: 'n8n_chat_histories',
    pacientes: 'pacientes',
    procedimentos: 'procedimentos',
    schema_migrations: 'schema_migrations',
    sintomas: 'sintomas',
    agent_control: 'agent_control',
    app_grupo: 'app_grupo',
    app_receipt: 'app_receipt'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "app_usuario" | "app_clinica" | "app_log_acao" | "app_conversa" | "app_mensagem" | "app_mensagem_sugestao" | "app_midia" | "app_paciente" | "app_paciente_clinica" | "app_resposta_pronta" | "app_tag" | "consultas" | "conversations" | "documents" | "especialidades" | "medico_procedimentos" | "medico_sintomas" | "medicos" | "n8n_chat_histories" | "pacientes" | "procedimentos" | "schema_migrations" | "sintomas" | "agent_control" | "app_grupo" | "app_receipt"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      app_usuario: {
        payload: Prisma.$app_usuarioPayload<ExtArgs>
        fields: Prisma.app_usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>
          }
          findFirst: {
            args: Prisma.app_usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>
          }
          findMany: {
            args: Prisma.app_usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>[]
          }
          create: {
            args: Prisma.app_usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>
          }
          createMany: {
            args: Prisma.app_usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_usuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>[]
          }
          delete: {
            args: Prisma.app_usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>
          }
          update: {
            args: Prisma.app_usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>
          }
          deleteMany: {
            args: Prisma.app_usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usuarioPayload>
          }
          aggregate: {
            args: Prisma.App_usuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_usuario>
          }
          groupBy: {
            args: Prisma.app_usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_usuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<App_usuarioCountAggregateOutputType> | number
          }
        }
      }
      app_clinica: {
        payload: Prisma.$app_clinicaPayload<ExtArgs>
        fields: Prisma.app_clinicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_clinicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_clinicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>
          }
          findFirst: {
            args: Prisma.app_clinicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_clinicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>
          }
          findMany: {
            args: Prisma.app_clinicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>[]
          }
          create: {
            args: Prisma.app_clinicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>
          }
          createMany: {
            args: Prisma.app_clinicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_clinicaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>[]
          }
          delete: {
            args: Prisma.app_clinicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>
          }
          update: {
            args: Prisma.app_clinicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>
          }
          deleteMany: {
            args: Prisma.app_clinicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_clinicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_clinicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_clinicaPayload>
          }
          aggregate: {
            args: Prisma.App_clinicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_clinica>
          }
          groupBy: {
            args: Prisma.app_clinicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_clinicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_clinicaCountArgs<ExtArgs>
            result: $Utils.Optional<App_clinicaCountAggregateOutputType> | number
          }
        }
      }
      app_log_acao: {
        payload: Prisma.$app_log_acaoPayload<ExtArgs>
        fields: Prisma.app_log_acaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_log_acaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_log_acaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>
          }
          findFirst: {
            args: Prisma.app_log_acaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_log_acaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>
          }
          findMany: {
            args: Prisma.app_log_acaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>[]
          }
          create: {
            args: Prisma.app_log_acaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>
          }
          createMany: {
            args: Prisma.app_log_acaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_log_acaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>[]
          }
          delete: {
            args: Prisma.app_log_acaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>
          }
          update: {
            args: Prisma.app_log_acaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>
          }
          deleteMany: {
            args: Prisma.app_log_acaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_log_acaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_log_acaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_log_acaoPayload>
          }
          aggregate: {
            args: Prisma.App_log_acaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_log_acao>
          }
          groupBy: {
            args: Prisma.app_log_acaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_log_acaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_log_acaoCountArgs<ExtArgs>
            result: $Utils.Optional<App_log_acaoCountAggregateOutputType> | number
          }
        }
      }
      app_conversa: {
        payload: Prisma.$app_conversaPayload<ExtArgs>
        fields: Prisma.app_conversaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_conversaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_conversaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>
          }
          findFirst: {
            args: Prisma.app_conversaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_conversaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>
          }
          findMany: {
            args: Prisma.app_conversaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>[]
          }
          create: {
            args: Prisma.app_conversaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>
          }
          createMany: {
            args: Prisma.app_conversaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_conversaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>[]
          }
          delete: {
            args: Prisma.app_conversaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>
          }
          update: {
            args: Prisma.app_conversaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>
          }
          deleteMany: {
            args: Prisma.app_conversaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_conversaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_conversaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_conversaPayload>
          }
          aggregate: {
            args: Prisma.App_conversaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_conversa>
          }
          groupBy: {
            args: Prisma.app_conversaGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_conversaGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_conversaCountArgs<ExtArgs>
            result: $Utils.Optional<App_conversaCountAggregateOutputType> | number
          }
        }
      }
      app_mensagem: {
        payload: Prisma.$app_mensagemPayload<ExtArgs>
        fields: Prisma.app_mensagemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_mensagemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_mensagemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>
          }
          findFirst: {
            args: Prisma.app_mensagemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_mensagemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>
          }
          findMany: {
            args: Prisma.app_mensagemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>[]
          }
          create: {
            args: Prisma.app_mensagemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>
          }
          createMany: {
            args: Prisma.app_mensagemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_mensagemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>[]
          }
          delete: {
            args: Prisma.app_mensagemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>
          }
          update: {
            args: Prisma.app_mensagemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>
          }
          deleteMany: {
            args: Prisma.app_mensagemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_mensagemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_mensagemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagemPayload>
          }
          aggregate: {
            args: Prisma.App_mensagemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_mensagem>
          }
          groupBy: {
            args: Prisma.app_mensagemGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_mensagemGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_mensagemCountArgs<ExtArgs>
            result: $Utils.Optional<App_mensagemCountAggregateOutputType> | number
          }
        }
      }
      app_mensagem_sugestao: {
        payload: Prisma.$app_mensagem_sugestaoPayload<ExtArgs>
        fields: Prisma.app_mensagem_sugestaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_mensagem_sugestaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_mensagem_sugestaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>
          }
          findFirst: {
            args: Prisma.app_mensagem_sugestaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_mensagem_sugestaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>
          }
          findMany: {
            args: Prisma.app_mensagem_sugestaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>[]
          }
          create: {
            args: Prisma.app_mensagem_sugestaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>
          }
          createMany: {
            args: Prisma.app_mensagem_sugestaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_mensagem_sugestaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>[]
          }
          delete: {
            args: Prisma.app_mensagem_sugestaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>
          }
          update: {
            args: Prisma.app_mensagem_sugestaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>
          }
          deleteMany: {
            args: Prisma.app_mensagem_sugestaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_mensagem_sugestaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_mensagem_sugestaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_mensagem_sugestaoPayload>
          }
          aggregate: {
            args: Prisma.App_mensagem_sugestaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_mensagem_sugestao>
          }
          groupBy: {
            args: Prisma.app_mensagem_sugestaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_mensagem_sugestaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_mensagem_sugestaoCountArgs<ExtArgs>
            result: $Utils.Optional<App_mensagem_sugestaoCountAggregateOutputType> | number
          }
        }
      }
      app_midia: {
        payload: Prisma.$app_midiaPayload<ExtArgs>
        fields: Prisma.app_midiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_midiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_midiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>
          }
          findFirst: {
            args: Prisma.app_midiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_midiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>
          }
          findMany: {
            args: Prisma.app_midiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>[]
          }
          create: {
            args: Prisma.app_midiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>
          }
          createMany: {
            args: Prisma.app_midiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_midiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>[]
          }
          delete: {
            args: Prisma.app_midiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>
          }
          update: {
            args: Prisma.app_midiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>
          }
          deleteMany: {
            args: Prisma.app_midiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_midiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_midiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_midiaPayload>
          }
          aggregate: {
            args: Prisma.App_midiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_midia>
          }
          groupBy: {
            args: Prisma.app_midiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_midiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_midiaCountArgs<ExtArgs>
            result: $Utils.Optional<App_midiaCountAggregateOutputType> | number
          }
        }
      }
      app_paciente: {
        payload: Prisma.$app_pacientePayload<ExtArgs>
        fields: Prisma.app_pacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_pacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_pacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>
          }
          findFirst: {
            args: Prisma.app_pacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_pacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>
          }
          findMany: {
            args: Prisma.app_pacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>[]
          }
          create: {
            args: Prisma.app_pacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>
          }
          createMany: {
            args: Prisma.app_pacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_pacienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>[]
          }
          delete: {
            args: Prisma.app_pacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>
          }
          update: {
            args: Prisma.app_pacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>
          }
          deleteMany: {
            args: Prisma.app_pacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_pacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_pacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_pacientePayload>
          }
          aggregate: {
            args: Prisma.App_pacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_paciente>
          }
          groupBy: {
            args: Prisma.app_pacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_pacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_pacienteCountArgs<ExtArgs>
            result: $Utils.Optional<App_pacienteCountAggregateOutputType> | number
          }
        }
      }
      app_paciente_clinica: {
        payload: Prisma.$app_paciente_clinicaPayload<ExtArgs>
        fields: Prisma.app_paciente_clinicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_paciente_clinicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_paciente_clinicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>
          }
          findFirst: {
            args: Prisma.app_paciente_clinicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_paciente_clinicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>
          }
          findMany: {
            args: Prisma.app_paciente_clinicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>[]
          }
          create: {
            args: Prisma.app_paciente_clinicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>
          }
          createMany: {
            args: Prisma.app_paciente_clinicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_paciente_clinicaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>[]
          }
          delete: {
            args: Prisma.app_paciente_clinicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>
          }
          update: {
            args: Prisma.app_paciente_clinicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>
          }
          deleteMany: {
            args: Prisma.app_paciente_clinicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_paciente_clinicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_paciente_clinicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_paciente_clinicaPayload>
          }
          aggregate: {
            args: Prisma.App_paciente_clinicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_paciente_clinica>
          }
          groupBy: {
            args: Prisma.app_paciente_clinicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_paciente_clinicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_paciente_clinicaCountArgs<ExtArgs>
            result: $Utils.Optional<App_paciente_clinicaCountAggregateOutputType> | number
          }
        }
      }
      app_resposta_pronta: {
        payload: Prisma.$app_resposta_prontaPayload<ExtArgs>
        fields: Prisma.app_resposta_prontaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_resposta_prontaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_resposta_prontaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>
          }
          findFirst: {
            args: Prisma.app_resposta_prontaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_resposta_prontaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>
          }
          findMany: {
            args: Prisma.app_resposta_prontaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>[]
          }
          create: {
            args: Prisma.app_resposta_prontaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>
          }
          createMany: {
            args: Prisma.app_resposta_prontaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_resposta_prontaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>[]
          }
          delete: {
            args: Prisma.app_resposta_prontaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>
          }
          update: {
            args: Prisma.app_resposta_prontaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>
          }
          deleteMany: {
            args: Prisma.app_resposta_prontaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_resposta_prontaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_resposta_prontaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_resposta_prontaPayload>
          }
          aggregate: {
            args: Prisma.App_resposta_prontaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_resposta_pronta>
          }
          groupBy: {
            args: Prisma.app_resposta_prontaGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_resposta_prontaGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_resposta_prontaCountArgs<ExtArgs>
            result: $Utils.Optional<App_resposta_prontaCountAggregateOutputType> | number
          }
        }
      }
      app_tag: {
        payload: Prisma.$app_tagPayload<ExtArgs>
        fields: Prisma.app_tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_tagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_tagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>
          }
          findFirst: {
            args: Prisma.app_tagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_tagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>
          }
          findMany: {
            args: Prisma.app_tagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>[]
          }
          create: {
            args: Prisma.app_tagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>
          }
          createMany: {
            args: Prisma.app_tagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_tagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>[]
          }
          delete: {
            args: Prisma.app_tagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>
          }
          update: {
            args: Prisma.app_tagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>
          }
          deleteMany: {
            args: Prisma.app_tagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_tagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_tagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_tagPayload>
          }
          aggregate: {
            args: Prisma.App_tagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_tag>
          }
          groupBy: {
            args: Prisma.app_tagGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_tagGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_tagCountArgs<ExtArgs>
            result: $Utils.Optional<App_tagCountAggregateOutputType> | number
          }
        }
      }
      consultas: {
        payload: Prisma.$consultasPayload<ExtArgs>
        fields: Prisma.consultasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consultasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consultasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          findFirst: {
            args: Prisma.consultasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consultasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          findMany: {
            args: Prisma.consultasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>[]
          }
          create: {
            args: Prisma.consultasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          createMany: {
            args: Prisma.consultasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consultasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>[]
          }
          delete: {
            args: Prisma.consultasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          update: {
            args: Prisma.consultasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          deleteMany: {
            args: Prisma.consultasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consultasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consultasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          aggregate: {
            args: Prisma.ConsultasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultas>
          }
          groupBy: {
            args: Prisma.consultasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultasGroupByOutputType>[]
          }
          count: {
            args: Prisma.consultasCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultasCountAggregateOutputType> | number
          }
        }
      }
      conversations: {
        payload: Prisma.$conversationsPayload<ExtArgs>
        fields: Prisma.conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findFirst: {
            args: Prisma.conversationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findMany: {
            args: Prisma.conversationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          create: {
            args: Prisma.conversationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          createMany: {
            args: Prisma.conversationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          delete: {
            args: Prisma.conversationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          update: {
            args: Prisma.conversationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          deleteMany: {
            args: Prisma.conversationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.conversationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          aggregate: {
            args: Prisma.ConversationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversations>
          }
          groupBy: {
            args: Prisma.conversationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationsCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationsCountAggregateOutputType> | number
          }
        }
      }
      documents: {
        payload: Prisma.$documentsPayload<ExtArgs>
        fields: Prisma.documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findFirst: {
            args: Prisma.documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findMany: {
            args: Prisma.documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          create: {
            args: Prisma.documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          createMany: {
            args: Prisma.documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.documentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          delete: {
            args: Prisma.documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          update: {
            args: Prisma.documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          deleteMany: {
            args: Prisma.documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      especialidades: {
        payload: Prisma.$especialidadesPayload<ExtArgs>
        fields: Prisma.especialidadesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.especialidadesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.especialidadesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          findFirst: {
            args: Prisma.especialidadesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.especialidadesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          findMany: {
            args: Prisma.especialidadesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>[]
          }
          create: {
            args: Prisma.especialidadesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          createMany: {
            args: Prisma.especialidadesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.especialidadesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>[]
          }
          delete: {
            args: Prisma.especialidadesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          update: {
            args: Prisma.especialidadesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          deleteMany: {
            args: Prisma.especialidadesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.especialidadesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.especialidadesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especialidadesPayload>
          }
          aggregate: {
            args: Prisma.EspecialidadesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecialidades>
          }
          groupBy: {
            args: Prisma.especialidadesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecialidadesGroupByOutputType>[]
          }
          count: {
            args: Prisma.especialidadesCountArgs<ExtArgs>
            result: $Utils.Optional<EspecialidadesCountAggregateOutputType> | number
          }
        }
      }
      medico_procedimentos: {
        payload: Prisma.$medico_procedimentosPayload<ExtArgs>
        fields: Prisma.medico_procedimentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medico_procedimentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medico_procedimentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>
          }
          findFirst: {
            args: Prisma.medico_procedimentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medico_procedimentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>
          }
          findMany: {
            args: Prisma.medico_procedimentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>[]
          }
          create: {
            args: Prisma.medico_procedimentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>
          }
          createMany: {
            args: Prisma.medico_procedimentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medico_procedimentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>[]
          }
          delete: {
            args: Prisma.medico_procedimentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>
          }
          update: {
            args: Prisma.medico_procedimentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>
          }
          deleteMany: {
            args: Prisma.medico_procedimentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medico_procedimentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medico_procedimentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_procedimentosPayload>
          }
          aggregate: {
            args: Prisma.Medico_procedimentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedico_procedimentos>
          }
          groupBy: {
            args: Prisma.medico_procedimentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Medico_procedimentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.medico_procedimentosCountArgs<ExtArgs>
            result: $Utils.Optional<Medico_procedimentosCountAggregateOutputType> | number
          }
        }
      }
      medico_sintomas: {
        payload: Prisma.$medico_sintomasPayload<ExtArgs>
        fields: Prisma.medico_sintomasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medico_sintomasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medico_sintomasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>
          }
          findFirst: {
            args: Prisma.medico_sintomasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medico_sintomasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>
          }
          findMany: {
            args: Prisma.medico_sintomasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>[]
          }
          create: {
            args: Prisma.medico_sintomasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>
          }
          createMany: {
            args: Prisma.medico_sintomasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medico_sintomasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>[]
          }
          delete: {
            args: Prisma.medico_sintomasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>
          }
          update: {
            args: Prisma.medico_sintomasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>
          }
          deleteMany: {
            args: Prisma.medico_sintomasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medico_sintomasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medico_sintomasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medico_sintomasPayload>
          }
          aggregate: {
            args: Prisma.Medico_sintomasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedico_sintomas>
          }
          groupBy: {
            args: Prisma.medico_sintomasGroupByArgs<ExtArgs>
            result: $Utils.Optional<Medico_sintomasGroupByOutputType>[]
          }
          count: {
            args: Prisma.medico_sintomasCountArgs<ExtArgs>
            result: $Utils.Optional<Medico_sintomasCountAggregateOutputType> | number
          }
        }
      }
      medicos: {
        payload: Prisma.$medicosPayload<ExtArgs>
        fields: Prisma.medicosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          findFirst: {
            args: Prisma.medicosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          findMany: {
            args: Prisma.medicosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>[]
          }
          create: {
            args: Prisma.medicosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          createMany: {
            args: Prisma.medicosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medicosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>[]
          }
          delete: {
            args: Prisma.medicosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          update: {
            args: Prisma.medicosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          deleteMany: {
            args: Prisma.medicosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medicosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicosPayload>
          }
          aggregate: {
            args: Prisma.MedicosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicos>
          }
          groupBy: {
            args: Prisma.medicosGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicosGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicosCountArgs<ExtArgs>
            result: $Utils.Optional<MedicosCountAggregateOutputType> | number
          }
        }
      }
      n8n_chat_histories: {
        payload: Prisma.$n8n_chat_historiesPayload<ExtArgs>
        fields: Prisma.n8n_chat_historiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.n8n_chat_historiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.n8n_chat_historiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>
          }
          findFirst: {
            args: Prisma.n8n_chat_historiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.n8n_chat_historiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>
          }
          findMany: {
            args: Prisma.n8n_chat_historiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>[]
          }
          create: {
            args: Prisma.n8n_chat_historiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>
          }
          createMany: {
            args: Prisma.n8n_chat_historiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.n8n_chat_historiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>[]
          }
          delete: {
            args: Prisma.n8n_chat_historiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>
          }
          update: {
            args: Prisma.n8n_chat_historiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>
          }
          deleteMany: {
            args: Prisma.n8n_chat_historiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.n8n_chat_historiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.n8n_chat_historiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$n8n_chat_historiesPayload>
          }
          aggregate: {
            args: Prisma.N8n_chat_historiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateN8n_chat_histories>
          }
          groupBy: {
            args: Prisma.n8n_chat_historiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<N8n_chat_historiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.n8n_chat_historiesCountArgs<ExtArgs>
            result: $Utils.Optional<N8n_chat_historiesCountAggregateOutputType> | number
          }
        }
      }
      pacientes: {
        payload: Prisma.$pacientesPayload<ExtArgs>
        fields: Prisma.pacientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pacientesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pacientesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          findFirst: {
            args: Prisma.pacientesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pacientesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          findMany: {
            args: Prisma.pacientesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>[]
          }
          create: {
            args: Prisma.pacientesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          createMany: {
            args: Prisma.pacientesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pacientesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>[]
          }
          delete: {
            args: Prisma.pacientesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          update: {
            args: Prisma.pacientesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          deleteMany: {
            args: Prisma.pacientesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pacientesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pacientesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pacientesPayload>
          }
          aggregate: {
            args: Prisma.PacientesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePacientes>
          }
          groupBy: {
            args: Prisma.pacientesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.pacientesCountArgs<ExtArgs>
            result: $Utils.Optional<PacientesCountAggregateOutputType> | number
          }
        }
      }
      procedimentos: {
        payload: Prisma.$procedimentosPayload<ExtArgs>
        fields: Prisma.procedimentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.procedimentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.procedimentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>
          }
          findFirst: {
            args: Prisma.procedimentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.procedimentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>
          }
          findMany: {
            args: Prisma.procedimentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>[]
          }
          create: {
            args: Prisma.procedimentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>
          }
          createMany: {
            args: Prisma.procedimentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.procedimentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>[]
          }
          delete: {
            args: Prisma.procedimentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>
          }
          update: {
            args: Prisma.procedimentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>
          }
          deleteMany: {
            args: Prisma.procedimentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.procedimentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.procedimentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$procedimentosPayload>
          }
          aggregate: {
            args: Prisma.ProcedimentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedimentos>
          }
          groupBy: {
            args: Prisma.procedimentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedimentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.procedimentosCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedimentosCountAggregateOutputType> | number
          }
        }
      }
      schema_migrations: {
        payload: Prisma.$schema_migrationsPayload<ExtArgs>
        fields: Prisma.schema_migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schema_migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schema_migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          findFirst: {
            args: Prisma.schema_migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schema_migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          findMany: {
            args: Prisma.schema_migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          create: {
            args: Prisma.schema_migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          createMany: {
            args: Prisma.schema_migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.schema_migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          delete: {
            args: Prisma.schema_migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          update: {
            args: Prisma.schema_migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          deleteMany: {
            args: Prisma.schema_migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.schema_migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.schema_migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          aggregate: {
            args: Prisma.Schema_migrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchema_migrations>
          }
          groupBy: {
            args: Prisma.schema_migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Schema_migrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.schema_migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<Schema_migrationsCountAggregateOutputType> | number
          }
        }
      }
      sintomas: {
        payload: Prisma.$sintomasPayload<ExtArgs>
        fields: Prisma.sintomasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sintomasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sintomasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>
          }
          findFirst: {
            args: Prisma.sintomasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sintomasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>
          }
          findMany: {
            args: Prisma.sintomasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>[]
          }
          create: {
            args: Prisma.sintomasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>
          }
          createMany: {
            args: Prisma.sintomasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sintomasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>[]
          }
          delete: {
            args: Prisma.sintomasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>
          }
          update: {
            args: Prisma.sintomasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>
          }
          deleteMany: {
            args: Prisma.sintomasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sintomasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sintomasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sintomasPayload>
          }
          aggregate: {
            args: Prisma.SintomasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSintomas>
          }
          groupBy: {
            args: Prisma.sintomasGroupByArgs<ExtArgs>
            result: $Utils.Optional<SintomasGroupByOutputType>[]
          }
          count: {
            args: Prisma.sintomasCountArgs<ExtArgs>
            result: $Utils.Optional<SintomasCountAggregateOutputType> | number
          }
        }
      }
      agent_control: {
        payload: Prisma.$agent_controlPayload<ExtArgs>
        fields: Prisma.agent_controlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agent_controlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agent_controlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>
          }
          findFirst: {
            args: Prisma.agent_controlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agent_controlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>
          }
          findMany: {
            args: Prisma.agent_controlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>[]
          }
          create: {
            args: Prisma.agent_controlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>
          }
          createMany: {
            args: Prisma.agent_controlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.agent_controlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>[]
          }
          delete: {
            args: Prisma.agent_controlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>
          }
          update: {
            args: Prisma.agent_controlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>
          }
          deleteMany: {
            args: Prisma.agent_controlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agent_controlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agent_controlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agent_controlPayload>
          }
          aggregate: {
            args: Prisma.Agent_controlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent_control>
          }
          groupBy: {
            args: Prisma.agent_controlGroupByArgs<ExtArgs>
            result: $Utils.Optional<Agent_controlGroupByOutputType>[]
          }
          count: {
            args: Prisma.agent_controlCountArgs<ExtArgs>
            result: $Utils.Optional<Agent_controlCountAggregateOutputType> | number
          }
        }
      }
      app_grupo: {
        payload: Prisma.$app_grupoPayload<ExtArgs>
        fields: Prisma.app_grupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_grupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_grupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>
          }
          findFirst: {
            args: Prisma.app_grupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_grupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>
          }
          findMany: {
            args: Prisma.app_grupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>[]
          }
          create: {
            args: Prisma.app_grupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>
          }
          createMany: {
            args: Prisma.app_grupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_grupoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>[]
          }
          delete: {
            args: Prisma.app_grupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>
          }
          update: {
            args: Prisma.app_grupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>
          }
          deleteMany: {
            args: Prisma.app_grupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_grupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_grupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_grupoPayload>
          }
          aggregate: {
            args: Prisma.App_grupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_grupo>
          }
          groupBy: {
            args: Prisma.app_grupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_grupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_grupoCountArgs<ExtArgs>
            result: $Utils.Optional<App_grupoCountAggregateOutputType> | number
          }
        }
      }
      app_receipt: {
        payload: Prisma.$app_receiptPayload<ExtArgs>
        fields: Prisma.app_receiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_receiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_receiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>
          }
          findFirst: {
            args: Prisma.app_receiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_receiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>
          }
          findMany: {
            args: Prisma.app_receiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>[]
          }
          create: {
            args: Prisma.app_receiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>
          }
          createMany: {
            args: Prisma.app_receiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_receiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>[]
          }
          delete: {
            args: Prisma.app_receiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>
          }
          update: {
            args: Prisma.app_receiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>
          }
          deleteMany: {
            args: Prisma.app_receiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_receiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_receiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_receiptPayload>
          }
          aggregate: {
            args: Prisma.App_receiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_receipt>
          }
          groupBy: {
            args: Prisma.app_receiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_receiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_receiptCountArgs<ExtArgs>
            result: $Utils.Optional<App_receiptCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type App_usuarioCountOutputType
   */

  export type App_usuarioCountOutputType = {
    app_log_acao: number
  }

  export type App_usuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_log_acao?: boolean | App_usuarioCountOutputTypeCountApp_log_acaoArgs
  }

  // Custom InputTypes
  /**
   * App_usuarioCountOutputType without action
   */
  export type App_usuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_usuarioCountOutputType
     */
    select?: App_usuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_usuarioCountOutputType without action
   */
  export type App_usuarioCountOutputTypeCountApp_log_acaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_log_acaoWhereInput
  }


  /**
   * Count Type App_clinicaCountOutputType
   */

  export type App_clinicaCountOutputType = {
    app_conversa: number
    app_grupo: number
    app_mensagem_sugestao: number
    app_paciente: number
    app_paciente_clinica: number
    app_resposta_pronta: number
    app_tag: number
    app_usuario_app_usuario_clinicaIdToapp_clinica: number
    app_usuario: number
  }

  export type App_clinicaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | App_clinicaCountOutputTypeCountApp_conversaArgs
    app_grupo?: boolean | App_clinicaCountOutputTypeCountApp_grupoArgs
    app_mensagem_sugestao?: boolean | App_clinicaCountOutputTypeCountApp_mensagem_sugestaoArgs
    app_paciente?: boolean | App_clinicaCountOutputTypeCountApp_pacienteArgs
    app_paciente_clinica?: boolean | App_clinicaCountOutputTypeCountApp_paciente_clinicaArgs
    app_resposta_pronta?: boolean | App_clinicaCountOutputTypeCountApp_resposta_prontaArgs
    app_tag?: boolean | App_clinicaCountOutputTypeCountApp_tagArgs
    app_usuario_app_usuario_clinicaIdToapp_clinica?: boolean | App_clinicaCountOutputTypeCountApp_usuario_app_usuario_clinicaIdToapp_clinicaArgs
    app_usuario?: boolean | App_clinicaCountOutputTypeCountApp_usuarioArgs
  }

  // Custom InputTypes
  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_clinicaCountOutputType
     */
    select?: App_clinicaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_conversaWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_grupoWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_mensagem_sugestaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_mensagem_sugestaoWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_pacienteWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_paciente_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_paciente_clinicaWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_resposta_prontaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_resposta_prontaWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_tagWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_usuario_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_usuarioWhereInput
  }

  /**
   * App_clinicaCountOutputType without action
   */
  export type App_clinicaCountOutputTypeCountApp_usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_usuarioWhereInput
  }


  /**
   * Count Type App_conversaCountOutputType
   */

  export type App_conversaCountOutputType = {
    app_mensagem: number
  }

  export type App_conversaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_mensagem?: boolean | App_conversaCountOutputTypeCountApp_mensagemArgs
  }

  // Custom InputTypes
  /**
   * App_conversaCountOutputType without action
   */
  export type App_conversaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_conversaCountOutputType
     */
    select?: App_conversaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_conversaCountOutputType without action
   */
  export type App_conversaCountOutputTypeCountApp_mensagemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_mensagemWhereInput
  }


  /**
   * Count Type App_mensagemCountOutputType
   */

  export type App_mensagemCountOutputType = {
    app_midia: number
    app_receipt: number
  }

  export type App_mensagemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_midia?: boolean | App_mensagemCountOutputTypeCountApp_midiaArgs
    app_receipt?: boolean | App_mensagemCountOutputTypeCountApp_receiptArgs
  }

  // Custom InputTypes
  /**
   * App_mensagemCountOutputType without action
   */
  export type App_mensagemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_mensagemCountOutputType
     */
    select?: App_mensagemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_mensagemCountOutputType without action
   */
  export type App_mensagemCountOutputTypeCountApp_midiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_midiaWhereInput
  }

  /**
   * App_mensagemCountOutputType without action
   */
  export type App_mensagemCountOutputTypeCountApp_receiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_receiptWhereInput
  }


  /**
   * Count Type App_pacienteCountOutputType
   */

  export type App_pacienteCountOutputType = {
    app_conversa: number
    app_paciente_clinica: number
  }

  export type App_pacienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | App_pacienteCountOutputTypeCountApp_conversaArgs
    app_paciente_clinica?: boolean | App_pacienteCountOutputTypeCountApp_paciente_clinicaArgs
  }

  // Custom InputTypes
  /**
   * App_pacienteCountOutputType without action
   */
  export type App_pacienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_pacienteCountOutputType
     */
    select?: App_pacienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_pacienteCountOutputType without action
   */
  export type App_pacienteCountOutputTypeCountApp_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_conversaWhereInput
  }

  /**
   * App_pacienteCountOutputType without action
   */
  export type App_pacienteCountOutputTypeCountApp_paciente_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_paciente_clinicaWhereInput
  }


  /**
   * Count Type EspecialidadesCountOutputType
   */

  export type EspecialidadesCountOutputType = {
    medicos: number
  }

  export type EspecialidadesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | EspecialidadesCountOutputTypeCountMedicosArgs
  }

  // Custom InputTypes
  /**
   * EspecialidadesCountOutputType without action
   */
  export type EspecialidadesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecialidadesCountOutputType
     */
    select?: EspecialidadesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EspecialidadesCountOutputType without action
   */
  export type EspecialidadesCountOutputTypeCountMedicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicosWhereInput
  }


  /**
   * Count Type MedicosCountOutputType
   */

  export type MedicosCountOutputType = {
    consultas: number
    medico_procedimentos: number
    medico_sintomas: number
  }

  export type MedicosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultas?: boolean | MedicosCountOutputTypeCountConsultasArgs
    medico_procedimentos?: boolean | MedicosCountOutputTypeCountMedico_procedimentosArgs
    medico_sintomas?: boolean | MedicosCountOutputTypeCountMedico_sintomasArgs
  }

  // Custom InputTypes
  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicosCountOutputType
     */
    select?: MedicosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeCountConsultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultasWhereInput
  }

  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeCountMedico_procedimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medico_procedimentosWhereInput
  }

  /**
   * MedicosCountOutputType without action
   */
  export type MedicosCountOutputTypeCountMedico_sintomasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medico_sintomasWhereInput
  }


  /**
   * Count Type PacientesCountOutputType
   */

  export type PacientesCountOutputType = {
    consultas: number
  }

  export type PacientesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultas?: boolean | PacientesCountOutputTypeCountConsultasArgs
  }

  // Custom InputTypes
  /**
   * PacientesCountOutputType without action
   */
  export type PacientesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PacientesCountOutputType
     */
    select?: PacientesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PacientesCountOutputType without action
   */
  export type PacientesCountOutputTypeCountConsultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultasWhereInput
  }


  /**
   * Count Type ProcedimentosCountOutputType
   */

  export type ProcedimentosCountOutputType = {
    medico_procedimentos: number
  }

  export type ProcedimentosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medico_procedimentos?: boolean | ProcedimentosCountOutputTypeCountMedico_procedimentosArgs
  }

  // Custom InputTypes
  /**
   * ProcedimentosCountOutputType without action
   */
  export type ProcedimentosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedimentosCountOutputType
     */
    select?: ProcedimentosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedimentosCountOutputType without action
   */
  export type ProcedimentosCountOutputTypeCountMedico_procedimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medico_procedimentosWhereInput
  }


  /**
   * Count Type SintomasCountOutputType
   */

  export type SintomasCountOutputType = {
    medico_sintomas: number
  }

  export type SintomasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medico_sintomas?: boolean | SintomasCountOutputTypeCountMedico_sintomasArgs
  }

  // Custom InputTypes
  /**
   * SintomasCountOutputType without action
   */
  export type SintomasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SintomasCountOutputType
     */
    select?: SintomasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SintomasCountOutputType without action
   */
  export type SintomasCountOutputTypeCountMedico_sintomasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medico_sintomasWhereInput
  }


  /**
   * Count Type App_grupoCountOutputType
   */

  export type App_grupoCountOutputType = {
    app_conversa: number
  }

  export type App_grupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | App_grupoCountOutputTypeCountApp_conversaArgs
  }

  // Custom InputTypes
  /**
   * App_grupoCountOutputType without action
   */
  export type App_grupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_grupoCountOutputType
     */
    select?: App_grupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * App_grupoCountOutputType without action
   */
  export type App_grupoCountOutputTypeCountApp_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_conversaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model app_usuario
   */

  export type AggregateApp_usuario = {
    _count: App_usuarioCountAggregateOutputType | null
    _avg: App_usuarioAvgAggregateOutputType | null
    _sum: App_usuarioSumAggregateOutputType | null
    _min: App_usuarioMinAggregateOutputType | null
    _max: App_usuarioMaxAggregateOutputType | null
  }

  export type App_usuarioAvgAggregateOutputType = {
    id: number | null
    clinica_id: number | null
    clinicaId: number | null
  }

  export type App_usuarioSumAggregateOutputType = {
    id: number | null
    clinica_id: number | null
    clinicaId: number | null
  }

  export type App_usuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    clinica_id: number | null
    criado_em: Date | null
    atualizado_em: Date | null
    clinicaId: number | null
  }

  export type App_usuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    clinica_id: number | null
    criado_em: Date | null
    atualizado_em: Date | null
    clinicaId: number | null
  }

  export type App_usuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    clinica_id: number
    criado_em: number
    atualizado_em: number
    clinicaId: number
    _all: number
  }


  export type App_usuarioAvgAggregateInputType = {
    id?: true
    clinica_id?: true
    clinicaId?: true
  }

  export type App_usuarioSumAggregateInputType = {
    id?: true
    clinica_id?: true
    clinicaId?: true
  }

  export type App_usuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    clinica_id?: true
    criado_em?: true
    atualizado_em?: true
    clinicaId?: true
  }

  export type App_usuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    clinica_id?: true
    criado_em?: true
    atualizado_em?: true
    clinicaId?: true
  }

  export type App_usuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    clinica_id?: true
    criado_em?: true
    atualizado_em?: true
    clinicaId?: true
    _all?: true
  }

  export type App_usuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_usuario to aggregate.
     */
    where?: app_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_usuarios to fetch.
     */
    orderBy?: app_usuarioOrderByWithRelationInput | app_usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_usuarios
    **/
    _count?: true | App_usuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_usuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_usuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_usuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_usuarioMaxAggregateInputType
  }

  export type GetApp_usuarioAggregateType<T extends App_usuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_usuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_usuario[P]>
      : GetScalarType<T[P], AggregateApp_usuario[P]>
  }




  export type app_usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_usuarioWhereInput
    orderBy?: app_usuarioOrderByWithAggregationInput | app_usuarioOrderByWithAggregationInput[]
    by: App_usuarioScalarFieldEnum[] | App_usuarioScalarFieldEnum
    having?: app_usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_usuarioCountAggregateInputType | true
    _avg?: App_usuarioAvgAggregateInputType
    _sum?: App_usuarioSumAggregateInputType
    _min?: App_usuarioMinAggregateInputType
    _max?: App_usuarioMaxAggregateInputType
  }

  export type App_usuarioGroupByOutputType = {
    id: number
    nome: string
    email: string
    senha: string
    clinica_id: number | null
    criado_em: Date | null
    atualizado_em: Date | null
    clinicaId: number | null
    _count: App_usuarioCountAggregateOutputType | null
    _avg: App_usuarioAvgAggregateOutputType | null
    _sum: App_usuarioSumAggregateOutputType | null
    _min: App_usuarioMinAggregateOutputType | null
    _max: App_usuarioMaxAggregateOutputType | null
  }

  type GetApp_usuarioGroupByPayload<T extends app_usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_usuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_usuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_usuarioGroupByOutputType[P]>
            : GetScalarType<T[P], App_usuarioGroupByOutputType[P]>
        }
      >
    >


  export type app_usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    clinica_id?: boolean
    criado_em?: boolean
    atualizado_em?: boolean
    clinicaId?: boolean
    app_log_acao?: boolean | app_usuario$app_log_acaoArgs<ExtArgs>
    app_clinica_app_usuario_clinicaIdToapp_clinica?: boolean | app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>
    app_clinica?: boolean | app_usuario$app_clinicaArgs<ExtArgs>
    _count?: boolean | App_usuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_usuario"]>

  export type app_usuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    clinica_id?: boolean
    criado_em?: boolean
    atualizado_em?: boolean
    clinicaId?: boolean
    app_clinica_app_usuario_clinicaIdToapp_clinica?: boolean | app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>
    app_clinica?: boolean | app_usuario$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_usuario"]>

  export type app_usuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    clinica_id?: boolean
    criado_em?: boolean
    atualizado_em?: boolean
    clinicaId?: boolean
  }

  export type app_usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_log_acao?: boolean | app_usuario$app_log_acaoArgs<ExtArgs>
    app_clinica_app_usuario_clinicaIdToapp_clinica?: boolean | app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>
    app_clinica?: boolean | app_usuario$app_clinicaArgs<ExtArgs>
    _count?: boolean | App_usuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type app_usuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica_app_usuario_clinicaIdToapp_clinica?: boolean | app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>
    app_clinica?: boolean | app_usuario$app_clinicaArgs<ExtArgs>
  }

  export type $app_usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_usuario"
    objects: {
      app_log_acao: Prisma.$app_log_acaoPayload<ExtArgs>[]
      app_clinica_app_usuario_clinicaIdToapp_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string
      senha: string
      clinica_id: number | null
      criado_em: Date | null
      atualizado_em: Date | null
      clinicaId: number | null
    }, ExtArgs["result"]["app_usuario"]>
    composites: {}
  }

  type app_usuarioGetPayload<S extends boolean | null | undefined | app_usuarioDefaultArgs> = $Result.GetResult<Prisma.$app_usuarioPayload, S>

  type app_usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_usuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_usuarioCountAggregateInputType | true
    }

  export interface app_usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_usuario'], meta: { name: 'app_usuario' } }
    /**
     * Find zero or one App_usuario that matches the filter.
     * @param {app_usuarioFindUniqueArgs} args - Arguments to find a App_usuario
     * @example
     * // Get one App_usuario
     * const app_usuario = await prisma.app_usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_usuarioFindUniqueArgs>(args: SelectSubset<T, app_usuarioFindUniqueArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_usuarioFindUniqueOrThrowArgs} args - Arguments to find a App_usuario
     * @example
     * // Get one App_usuario
     * const app_usuario = await prisma.app_usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, app_usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usuarioFindFirstArgs} args - Arguments to find a App_usuario
     * @example
     * // Get one App_usuario
     * const app_usuario = await prisma.app_usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_usuarioFindFirstArgs>(args?: SelectSubset<T, app_usuarioFindFirstArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usuarioFindFirstOrThrowArgs} args - Arguments to find a App_usuario
     * @example
     * // Get one App_usuario
     * const app_usuario = await prisma.app_usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, app_usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_usuarios
     * const app_usuarios = await prisma.app_usuario.findMany()
     * 
     * // Get first 10 App_usuarios
     * const app_usuarios = await prisma.app_usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_usuarioWithIdOnly = await prisma.app_usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_usuarioFindManyArgs>(args?: SelectSubset<T, app_usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_usuario.
     * @param {app_usuarioCreateArgs} args - Arguments to create a App_usuario.
     * @example
     * // Create one App_usuario
     * const App_usuario = await prisma.app_usuario.create({
     *   data: {
     *     // ... data to create a App_usuario
     *   }
     * })
     * 
     */
    create<T extends app_usuarioCreateArgs>(args: SelectSubset<T, app_usuarioCreateArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_usuarios.
     * @param {app_usuarioCreateManyArgs} args - Arguments to create many App_usuarios.
     * @example
     * // Create many App_usuarios
     * const app_usuario = await prisma.app_usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_usuarioCreateManyArgs>(args?: SelectSubset<T, app_usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_usuarios and returns the data saved in the database.
     * @param {app_usuarioCreateManyAndReturnArgs} args - Arguments to create many App_usuarios.
     * @example
     * // Create many App_usuarios
     * const app_usuario = await prisma.app_usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_usuarios and only return the `id`
     * const app_usuarioWithIdOnly = await prisma.app_usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_usuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, app_usuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_usuario.
     * @param {app_usuarioDeleteArgs} args - Arguments to delete one App_usuario.
     * @example
     * // Delete one App_usuario
     * const App_usuario = await prisma.app_usuario.delete({
     *   where: {
     *     // ... filter to delete one App_usuario
     *   }
     * })
     * 
     */
    delete<T extends app_usuarioDeleteArgs>(args: SelectSubset<T, app_usuarioDeleteArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_usuario.
     * @param {app_usuarioUpdateArgs} args - Arguments to update one App_usuario.
     * @example
     * // Update one App_usuario
     * const app_usuario = await prisma.app_usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_usuarioUpdateArgs>(args: SelectSubset<T, app_usuarioUpdateArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_usuarios.
     * @param {app_usuarioDeleteManyArgs} args - Arguments to filter App_usuarios to delete.
     * @example
     * // Delete a few App_usuarios
     * const { count } = await prisma.app_usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_usuarioDeleteManyArgs>(args?: SelectSubset<T, app_usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_usuarios
     * const app_usuario = await prisma.app_usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_usuarioUpdateManyArgs>(args: SelectSubset<T, app_usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_usuario.
     * @param {app_usuarioUpsertArgs} args - Arguments to update or create a App_usuario.
     * @example
     * // Update or create a App_usuario
     * const app_usuario = await prisma.app_usuario.upsert({
     *   create: {
     *     // ... data to create a App_usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_usuario we want to update
     *   }
     * })
     */
    upsert<T extends app_usuarioUpsertArgs>(args: SelectSubset<T, app_usuarioUpsertArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usuarioCountArgs} args - Arguments to filter App_usuarios to count.
     * @example
     * // Count the number of App_usuarios
     * const count = await prisma.app_usuario.count({
     *   where: {
     *     // ... the filter for the App_usuarios we want to count
     *   }
     * })
    **/
    count<T extends app_usuarioCountArgs>(
      args?: Subset<T, app_usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_usuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_usuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_usuarioAggregateArgs>(args: Subset<T, App_usuarioAggregateArgs>): Prisma.PrismaPromise<GetApp_usuarioAggregateType<T>>

    /**
     * Group by App_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_usuarioGroupByArgs['orderBy'] }
        : { orderBy?: app_usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_usuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_usuario model
   */
  readonly fields: app_usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_log_acao<T extends app_usuario$app_log_acaoArgs<ExtArgs> = {}>(args?: Subset<T, app_usuario$app_log_acaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "findMany"> | Null>
    app_clinica_app_usuario_clinicaIdToapp_clinica<T extends app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    app_clinica<T extends app_usuario$app_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_usuario$app_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_usuario model
   */ 
  interface app_usuarioFieldRefs {
    readonly id: FieldRef<"app_usuario", 'Int'>
    readonly nome: FieldRef<"app_usuario", 'String'>
    readonly email: FieldRef<"app_usuario", 'String'>
    readonly senha: FieldRef<"app_usuario", 'String'>
    readonly clinica_id: FieldRef<"app_usuario", 'Int'>
    readonly criado_em: FieldRef<"app_usuario", 'DateTime'>
    readonly atualizado_em: FieldRef<"app_usuario", 'DateTime'>
    readonly clinicaId: FieldRef<"app_usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * app_usuario findUnique
   */
  export type app_usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * Filter, which app_usuario to fetch.
     */
    where: app_usuarioWhereUniqueInput
  }

  /**
   * app_usuario findUniqueOrThrow
   */
  export type app_usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * Filter, which app_usuario to fetch.
     */
    where: app_usuarioWhereUniqueInput
  }

  /**
   * app_usuario findFirst
   */
  export type app_usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * Filter, which app_usuario to fetch.
     */
    where?: app_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_usuarios to fetch.
     */
    orderBy?: app_usuarioOrderByWithRelationInput | app_usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_usuarios.
     */
    cursor?: app_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_usuarios.
     */
    distinct?: App_usuarioScalarFieldEnum | App_usuarioScalarFieldEnum[]
  }

  /**
   * app_usuario findFirstOrThrow
   */
  export type app_usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * Filter, which app_usuario to fetch.
     */
    where?: app_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_usuarios to fetch.
     */
    orderBy?: app_usuarioOrderByWithRelationInput | app_usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_usuarios.
     */
    cursor?: app_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_usuarios.
     */
    distinct?: App_usuarioScalarFieldEnum | App_usuarioScalarFieldEnum[]
  }

  /**
   * app_usuario findMany
   */
  export type app_usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * Filter, which app_usuarios to fetch.
     */
    where?: app_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_usuarios to fetch.
     */
    orderBy?: app_usuarioOrderByWithRelationInput | app_usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_usuarios.
     */
    cursor?: app_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_usuarios.
     */
    skip?: number
    distinct?: App_usuarioScalarFieldEnum | App_usuarioScalarFieldEnum[]
  }

  /**
   * app_usuario create
   */
  export type app_usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a app_usuario.
     */
    data: XOR<app_usuarioCreateInput, app_usuarioUncheckedCreateInput>
  }

  /**
   * app_usuario createMany
   */
  export type app_usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_usuarios.
     */
    data: app_usuarioCreateManyInput | app_usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_usuario createManyAndReturn
   */
  export type app_usuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_usuarios.
     */
    data: app_usuarioCreateManyInput | app_usuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_usuario update
   */
  export type app_usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a app_usuario.
     */
    data: XOR<app_usuarioUpdateInput, app_usuarioUncheckedUpdateInput>
    /**
     * Choose, which app_usuario to update.
     */
    where: app_usuarioWhereUniqueInput
  }

  /**
   * app_usuario updateMany
   */
  export type app_usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_usuarios.
     */
    data: XOR<app_usuarioUpdateManyMutationInput, app_usuarioUncheckedUpdateManyInput>
    /**
     * Filter which app_usuarios to update
     */
    where?: app_usuarioWhereInput
  }

  /**
   * app_usuario upsert
   */
  export type app_usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the app_usuario to update in case it exists.
     */
    where: app_usuarioWhereUniqueInput
    /**
     * In case the app_usuario found by the `where` argument doesn't exist, create a new app_usuario with this data.
     */
    create: XOR<app_usuarioCreateInput, app_usuarioUncheckedCreateInput>
    /**
     * In case the app_usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_usuarioUpdateInput, app_usuarioUncheckedUpdateInput>
  }

  /**
   * app_usuario delete
   */
  export type app_usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    /**
     * Filter which app_usuario to delete.
     */
    where: app_usuarioWhereUniqueInput
  }

  /**
   * app_usuario deleteMany
   */
  export type app_usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_usuarios to delete
     */
    where?: app_usuarioWhereInput
  }

  /**
   * app_usuario.app_log_acao
   */
  export type app_usuario$app_log_acaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    where?: app_log_acaoWhereInput
    orderBy?: app_log_acaoOrderByWithRelationInput | app_log_acaoOrderByWithRelationInput[]
    cursor?: app_log_acaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_log_acaoScalarFieldEnum | App_log_acaoScalarFieldEnum[]
  }

  /**
   * app_usuario.app_clinica_app_usuario_clinicaIdToapp_clinica
   */
  export type app_usuario$app_clinica_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_usuario.app_clinica
   */
  export type app_usuario$app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_usuario without action
   */
  export type app_usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
  }


  /**
   * Model app_clinica
   */

  export type AggregateApp_clinica = {
    _count: App_clinicaCountAggregateOutputType | null
    _avg: App_clinicaAvgAggregateOutputType | null
    _sum: App_clinicaSumAggregateOutputType | null
    _min: App_clinicaMinAggregateOutputType | null
    _max: App_clinicaMaxAggregateOutputType | null
  }

  export type App_clinicaAvgAggregateOutputType = {
    id: number | null
  }

  export type App_clinicaSumAggregateOutputType = {
    id: number | null
  }

  export type App_clinicaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    instancia: string | null
    base_url: string | null
    criada_em: Date | null
    atualizada_em: Date | null
    tokenEvolution: string | null
  }

  export type App_clinicaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    endereco: string | null
    telefone: string | null
    email: string | null
    instancia: string | null
    base_url: string | null
    criada_em: Date | null
    atualizada_em: Date | null
    tokenEvolution: string | null
  }

  export type App_clinicaCountAggregateOutputType = {
    id: number
    nome: number
    endereco: number
    telefone: number
    email: number
    instancia: number
    base_url: number
    criada_em: number
    atualizada_em: number
    tokenEvolution: number
    _all: number
  }


  export type App_clinicaAvgAggregateInputType = {
    id?: true
  }

  export type App_clinicaSumAggregateInputType = {
    id?: true
  }

  export type App_clinicaMinAggregateInputType = {
    id?: true
    nome?: true
    endereco?: true
    telefone?: true
    email?: true
    instancia?: true
    base_url?: true
    criada_em?: true
    atualizada_em?: true
    tokenEvolution?: true
  }

  export type App_clinicaMaxAggregateInputType = {
    id?: true
    nome?: true
    endereco?: true
    telefone?: true
    email?: true
    instancia?: true
    base_url?: true
    criada_em?: true
    atualizada_em?: true
    tokenEvolution?: true
  }

  export type App_clinicaCountAggregateInputType = {
    id?: true
    nome?: true
    endereco?: true
    telefone?: true
    email?: true
    instancia?: true
    base_url?: true
    criada_em?: true
    atualizada_em?: true
    tokenEvolution?: true
    _all?: true
  }

  export type App_clinicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_clinica to aggregate.
     */
    where?: app_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_clinicas to fetch.
     */
    orderBy?: app_clinicaOrderByWithRelationInput | app_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_clinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_clinicas
    **/
    _count?: true | App_clinicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_clinicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_clinicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_clinicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_clinicaMaxAggregateInputType
  }

  export type GetApp_clinicaAggregateType<T extends App_clinicaAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_clinica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_clinica[P]>
      : GetScalarType<T[P], AggregateApp_clinica[P]>
  }




  export type app_clinicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_clinicaWhereInput
    orderBy?: app_clinicaOrderByWithAggregationInput | app_clinicaOrderByWithAggregationInput[]
    by: App_clinicaScalarFieldEnum[] | App_clinicaScalarFieldEnum
    having?: app_clinicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_clinicaCountAggregateInputType | true
    _avg?: App_clinicaAvgAggregateInputType
    _sum?: App_clinicaSumAggregateInputType
    _min?: App_clinicaMinAggregateInputType
    _max?: App_clinicaMaxAggregateInputType
  }

  export type App_clinicaGroupByOutputType = {
    id: number
    nome: string
    endereco: string | null
    telefone: string | null
    email: string | null
    instancia: string | null
    base_url: string | null
    criada_em: Date | null
    atualizada_em: Date | null
    tokenEvolution: string | null
    _count: App_clinicaCountAggregateOutputType | null
    _avg: App_clinicaAvgAggregateOutputType | null
    _sum: App_clinicaSumAggregateOutputType | null
    _min: App_clinicaMinAggregateOutputType | null
    _max: App_clinicaMaxAggregateOutputType | null
  }

  type GetApp_clinicaGroupByPayload<T extends app_clinicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_clinicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_clinicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_clinicaGroupByOutputType[P]>
            : GetScalarType<T[P], App_clinicaGroupByOutputType[P]>
        }
      >
    >


  export type app_clinicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    instancia?: boolean
    base_url?: boolean
    criada_em?: boolean
    atualizada_em?: boolean
    tokenEvolution?: boolean
    app_conversa?: boolean | app_clinica$app_conversaArgs<ExtArgs>
    app_grupo?: boolean | app_clinica$app_grupoArgs<ExtArgs>
    app_mensagem_sugestao?: boolean | app_clinica$app_mensagem_sugestaoArgs<ExtArgs>
    app_paciente?: boolean | app_clinica$app_pacienteArgs<ExtArgs>
    app_paciente_clinica?: boolean | app_clinica$app_paciente_clinicaArgs<ExtArgs>
    app_resposta_pronta?: boolean | app_clinica$app_resposta_prontaArgs<ExtArgs>
    app_tag?: boolean | app_clinica$app_tagArgs<ExtArgs>
    app_usuario_app_usuario_clinicaIdToapp_clinica?: boolean | app_clinica$app_usuario_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>
    app_usuario?: boolean | app_clinica$app_usuarioArgs<ExtArgs>
    _count?: boolean | App_clinicaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_clinica"]>

  export type app_clinicaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    instancia?: boolean
    base_url?: boolean
    criada_em?: boolean
    atualizada_em?: boolean
    tokenEvolution?: boolean
  }, ExtArgs["result"]["app_clinica"]>

  export type app_clinicaSelectScalar = {
    id?: boolean
    nome?: boolean
    endereco?: boolean
    telefone?: boolean
    email?: boolean
    instancia?: boolean
    base_url?: boolean
    criada_em?: boolean
    atualizada_em?: boolean
    tokenEvolution?: boolean
  }

  export type app_clinicaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | app_clinica$app_conversaArgs<ExtArgs>
    app_grupo?: boolean | app_clinica$app_grupoArgs<ExtArgs>
    app_mensagem_sugestao?: boolean | app_clinica$app_mensagem_sugestaoArgs<ExtArgs>
    app_paciente?: boolean | app_clinica$app_pacienteArgs<ExtArgs>
    app_paciente_clinica?: boolean | app_clinica$app_paciente_clinicaArgs<ExtArgs>
    app_resposta_pronta?: boolean | app_clinica$app_resposta_prontaArgs<ExtArgs>
    app_tag?: boolean | app_clinica$app_tagArgs<ExtArgs>
    app_usuario_app_usuario_clinicaIdToapp_clinica?: boolean | app_clinica$app_usuario_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>
    app_usuario?: boolean | app_clinica$app_usuarioArgs<ExtArgs>
    _count?: boolean | App_clinicaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type app_clinicaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $app_clinicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_clinica"
    objects: {
      app_conversa: Prisma.$app_conversaPayload<ExtArgs>[]
      app_grupo: Prisma.$app_grupoPayload<ExtArgs>[]
      app_mensagem_sugestao: Prisma.$app_mensagem_sugestaoPayload<ExtArgs>[]
      app_paciente: Prisma.$app_pacientePayload<ExtArgs>[]
      app_paciente_clinica: Prisma.$app_paciente_clinicaPayload<ExtArgs>[]
      app_resposta_pronta: Prisma.$app_resposta_prontaPayload<ExtArgs>[]
      app_tag: Prisma.$app_tagPayload<ExtArgs>[]
      app_usuario_app_usuario_clinicaIdToapp_clinica: Prisma.$app_usuarioPayload<ExtArgs>[]
      app_usuario: Prisma.$app_usuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      endereco: string | null
      telefone: string | null
      email: string | null
      instancia: string | null
      base_url: string | null
      criada_em: Date | null
      atualizada_em: Date | null
      tokenEvolution: string | null
    }, ExtArgs["result"]["app_clinica"]>
    composites: {}
  }

  type app_clinicaGetPayload<S extends boolean | null | undefined | app_clinicaDefaultArgs> = $Result.GetResult<Prisma.$app_clinicaPayload, S>

  type app_clinicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_clinicaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_clinicaCountAggregateInputType | true
    }

  export interface app_clinicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_clinica'], meta: { name: 'app_clinica' } }
    /**
     * Find zero or one App_clinica that matches the filter.
     * @param {app_clinicaFindUniqueArgs} args - Arguments to find a App_clinica
     * @example
     * // Get one App_clinica
     * const app_clinica = await prisma.app_clinica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_clinicaFindUniqueArgs>(args: SelectSubset<T, app_clinicaFindUniqueArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_clinica that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_clinicaFindUniqueOrThrowArgs} args - Arguments to find a App_clinica
     * @example
     * // Get one App_clinica
     * const app_clinica = await prisma.app_clinica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_clinicaFindUniqueOrThrowArgs>(args: SelectSubset<T, app_clinicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_clinica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_clinicaFindFirstArgs} args - Arguments to find a App_clinica
     * @example
     * // Get one App_clinica
     * const app_clinica = await prisma.app_clinica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_clinicaFindFirstArgs>(args?: SelectSubset<T, app_clinicaFindFirstArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_clinica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_clinicaFindFirstOrThrowArgs} args - Arguments to find a App_clinica
     * @example
     * // Get one App_clinica
     * const app_clinica = await prisma.app_clinica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_clinicaFindFirstOrThrowArgs>(args?: SelectSubset<T, app_clinicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_clinicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_clinicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_clinicas
     * const app_clinicas = await prisma.app_clinica.findMany()
     * 
     * // Get first 10 App_clinicas
     * const app_clinicas = await prisma.app_clinica.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_clinicaWithIdOnly = await prisma.app_clinica.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_clinicaFindManyArgs>(args?: SelectSubset<T, app_clinicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_clinica.
     * @param {app_clinicaCreateArgs} args - Arguments to create a App_clinica.
     * @example
     * // Create one App_clinica
     * const App_clinica = await prisma.app_clinica.create({
     *   data: {
     *     // ... data to create a App_clinica
     *   }
     * })
     * 
     */
    create<T extends app_clinicaCreateArgs>(args: SelectSubset<T, app_clinicaCreateArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_clinicas.
     * @param {app_clinicaCreateManyArgs} args - Arguments to create many App_clinicas.
     * @example
     * // Create many App_clinicas
     * const app_clinica = await prisma.app_clinica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_clinicaCreateManyArgs>(args?: SelectSubset<T, app_clinicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_clinicas and returns the data saved in the database.
     * @param {app_clinicaCreateManyAndReturnArgs} args - Arguments to create many App_clinicas.
     * @example
     * // Create many App_clinicas
     * const app_clinica = await prisma.app_clinica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_clinicas and only return the `id`
     * const app_clinicaWithIdOnly = await prisma.app_clinica.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_clinicaCreateManyAndReturnArgs>(args?: SelectSubset<T, app_clinicaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_clinica.
     * @param {app_clinicaDeleteArgs} args - Arguments to delete one App_clinica.
     * @example
     * // Delete one App_clinica
     * const App_clinica = await prisma.app_clinica.delete({
     *   where: {
     *     // ... filter to delete one App_clinica
     *   }
     * })
     * 
     */
    delete<T extends app_clinicaDeleteArgs>(args: SelectSubset<T, app_clinicaDeleteArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_clinica.
     * @param {app_clinicaUpdateArgs} args - Arguments to update one App_clinica.
     * @example
     * // Update one App_clinica
     * const app_clinica = await prisma.app_clinica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_clinicaUpdateArgs>(args: SelectSubset<T, app_clinicaUpdateArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_clinicas.
     * @param {app_clinicaDeleteManyArgs} args - Arguments to filter App_clinicas to delete.
     * @example
     * // Delete a few App_clinicas
     * const { count } = await prisma.app_clinica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_clinicaDeleteManyArgs>(args?: SelectSubset<T, app_clinicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_clinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_clinicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_clinicas
     * const app_clinica = await prisma.app_clinica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_clinicaUpdateManyArgs>(args: SelectSubset<T, app_clinicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_clinica.
     * @param {app_clinicaUpsertArgs} args - Arguments to update or create a App_clinica.
     * @example
     * // Update or create a App_clinica
     * const app_clinica = await prisma.app_clinica.upsert({
     *   create: {
     *     // ... data to create a App_clinica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_clinica we want to update
     *   }
     * })
     */
    upsert<T extends app_clinicaUpsertArgs>(args: SelectSubset<T, app_clinicaUpsertArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_clinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_clinicaCountArgs} args - Arguments to filter App_clinicas to count.
     * @example
     * // Count the number of App_clinicas
     * const count = await prisma.app_clinica.count({
     *   where: {
     *     // ... the filter for the App_clinicas we want to count
     *   }
     * })
    **/
    count<T extends app_clinicaCountArgs>(
      args?: Subset<T, app_clinicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_clinicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_clinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_clinicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_clinicaAggregateArgs>(args: Subset<T, App_clinicaAggregateArgs>): Prisma.PrismaPromise<GetApp_clinicaAggregateType<T>>

    /**
     * Group by App_clinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_clinicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_clinicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_clinicaGroupByArgs['orderBy'] }
        : { orderBy?: app_clinicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_clinicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_clinicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_clinica model
   */
  readonly fields: app_clinicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_clinica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_clinicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_conversa<T extends app_clinica$app_conversaArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_conversaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findMany"> | Null>
    app_grupo<T extends app_clinica$app_grupoArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_grupoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findMany"> | Null>
    app_mensagem_sugestao<T extends app_clinica$app_mensagem_sugestaoArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_mensagem_sugestaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "findMany"> | Null>
    app_paciente<T extends app_clinica$app_pacienteArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_pacienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findMany"> | Null>
    app_paciente_clinica<T extends app_clinica$app_paciente_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_paciente_clinicaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findMany"> | Null>
    app_resposta_pronta<T extends app_clinica$app_resposta_prontaArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_resposta_prontaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "findMany"> | Null>
    app_tag<T extends app_clinica$app_tagArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_tagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "findMany"> | Null>
    app_usuario_app_usuario_clinicaIdToapp_clinica<T extends app_clinica$app_usuario_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_usuario_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findMany"> | Null>
    app_usuario<T extends app_clinica$app_usuarioArgs<ExtArgs> = {}>(args?: Subset<T, app_clinica$app_usuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_clinica model
   */ 
  interface app_clinicaFieldRefs {
    readonly id: FieldRef<"app_clinica", 'Int'>
    readonly nome: FieldRef<"app_clinica", 'String'>
    readonly endereco: FieldRef<"app_clinica", 'String'>
    readonly telefone: FieldRef<"app_clinica", 'String'>
    readonly email: FieldRef<"app_clinica", 'String'>
    readonly instancia: FieldRef<"app_clinica", 'String'>
    readonly base_url: FieldRef<"app_clinica", 'String'>
    readonly criada_em: FieldRef<"app_clinica", 'DateTime'>
    readonly atualizada_em: FieldRef<"app_clinica", 'DateTime'>
    readonly tokenEvolution: FieldRef<"app_clinica", 'String'>
  }
    

  // Custom InputTypes
  /**
   * app_clinica findUnique
   */
  export type app_clinicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_clinica to fetch.
     */
    where: app_clinicaWhereUniqueInput
  }

  /**
   * app_clinica findUniqueOrThrow
   */
  export type app_clinicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_clinica to fetch.
     */
    where: app_clinicaWhereUniqueInput
  }

  /**
   * app_clinica findFirst
   */
  export type app_clinicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_clinica to fetch.
     */
    where?: app_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_clinicas to fetch.
     */
    orderBy?: app_clinicaOrderByWithRelationInput | app_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_clinicas.
     */
    cursor?: app_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_clinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_clinicas.
     */
    distinct?: App_clinicaScalarFieldEnum | App_clinicaScalarFieldEnum[]
  }

  /**
   * app_clinica findFirstOrThrow
   */
  export type app_clinicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_clinica to fetch.
     */
    where?: app_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_clinicas to fetch.
     */
    orderBy?: app_clinicaOrderByWithRelationInput | app_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_clinicas.
     */
    cursor?: app_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_clinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_clinicas.
     */
    distinct?: App_clinicaScalarFieldEnum | App_clinicaScalarFieldEnum[]
  }

  /**
   * app_clinica findMany
   */
  export type app_clinicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_clinicas to fetch.
     */
    where?: app_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_clinicas to fetch.
     */
    orderBy?: app_clinicaOrderByWithRelationInput | app_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_clinicas.
     */
    cursor?: app_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_clinicas.
     */
    skip?: number
    distinct?: App_clinicaScalarFieldEnum | App_clinicaScalarFieldEnum[]
  }

  /**
   * app_clinica create
   */
  export type app_clinicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * The data needed to create a app_clinica.
     */
    data: XOR<app_clinicaCreateInput, app_clinicaUncheckedCreateInput>
  }

  /**
   * app_clinica createMany
   */
  export type app_clinicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_clinicas.
     */
    data: app_clinicaCreateManyInput | app_clinicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_clinica createManyAndReturn
   */
  export type app_clinicaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_clinicas.
     */
    data: app_clinicaCreateManyInput | app_clinicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_clinica update
   */
  export type app_clinicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * The data needed to update a app_clinica.
     */
    data: XOR<app_clinicaUpdateInput, app_clinicaUncheckedUpdateInput>
    /**
     * Choose, which app_clinica to update.
     */
    where: app_clinicaWhereUniqueInput
  }

  /**
   * app_clinica updateMany
   */
  export type app_clinicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_clinicas.
     */
    data: XOR<app_clinicaUpdateManyMutationInput, app_clinicaUncheckedUpdateManyInput>
    /**
     * Filter which app_clinicas to update
     */
    where?: app_clinicaWhereInput
  }

  /**
   * app_clinica upsert
   */
  export type app_clinicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * The filter to search for the app_clinica to update in case it exists.
     */
    where: app_clinicaWhereUniqueInput
    /**
     * In case the app_clinica found by the `where` argument doesn't exist, create a new app_clinica with this data.
     */
    create: XOR<app_clinicaCreateInput, app_clinicaUncheckedCreateInput>
    /**
     * In case the app_clinica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_clinicaUpdateInput, app_clinicaUncheckedUpdateInput>
  }

  /**
   * app_clinica delete
   */
  export type app_clinicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    /**
     * Filter which app_clinica to delete.
     */
    where: app_clinicaWhereUniqueInput
  }

  /**
   * app_clinica deleteMany
   */
  export type app_clinicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_clinicas to delete
     */
    where?: app_clinicaWhereInput
  }

  /**
   * app_clinica.app_conversa
   */
  export type app_clinica$app_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    where?: app_conversaWhereInput
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    cursor?: app_conversaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_conversaScalarFieldEnum | App_conversaScalarFieldEnum[]
  }

  /**
   * app_clinica.app_grupo
   */
  export type app_clinica$app_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    where?: app_grupoWhereInput
    orderBy?: app_grupoOrderByWithRelationInput | app_grupoOrderByWithRelationInput[]
    cursor?: app_grupoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_grupoScalarFieldEnum | App_grupoScalarFieldEnum[]
  }

  /**
   * app_clinica.app_mensagem_sugestao
   */
  export type app_clinica$app_mensagem_sugestaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    where?: app_mensagem_sugestaoWhereInput
    orderBy?: app_mensagem_sugestaoOrderByWithRelationInput | app_mensagem_sugestaoOrderByWithRelationInput[]
    cursor?: app_mensagem_sugestaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_mensagem_sugestaoScalarFieldEnum | App_mensagem_sugestaoScalarFieldEnum[]
  }

  /**
   * app_clinica.app_paciente
   */
  export type app_clinica$app_pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    where?: app_pacienteWhereInput
    orderBy?: app_pacienteOrderByWithRelationInput | app_pacienteOrderByWithRelationInput[]
    cursor?: app_pacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_pacienteScalarFieldEnum | App_pacienteScalarFieldEnum[]
  }

  /**
   * app_clinica.app_paciente_clinica
   */
  export type app_clinica$app_paciente_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    where?: app_paciente_clinicaWhereInput
    orderBy?: app_paciente_clinicaOrderByWithRelationInput | app_paciente_clinicaOrderByWithRelationInput[]
    cursor?: app_paciente_clinicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_paciente_clinicaScalarFieldEnum | App_paciente_clinicaScalarFieldEnum[]
  }

  /**
   * app_clinica.app_resposta_pronta
   */
  export type app_clinica$app_resposta_prontaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    where?: app_resposta_prontaWhereInput
    orderBy?: app_resposta_prontaOrderByWithRelationInput | app_resposta_prontaOrderByWithRelationInput[]
    cursor?: app_resposta_prontaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_resposta_prontaScalarFieldEnum | App_resposta_prontaScalarFieldEnum[]
  }

  /**
   * app_clinica.app_tag
   */
  export type app_clinica$app_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    where?: app_tagWhereInput
    orderBy?: app_tagOrderByWithRelationInput | app_tagOrderByWithRelationInput[]
    cursor?: app_tagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_tagScalarFieldEnum | App_tagScalarFieldEnum[]
  }

  /**
   * app_clinica.app_usuario_app_usuario_clinicaIdToapp_clinica
   */
  export type app_clinica$app_usuario_app_usuario_clinicaIdToapp_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    where?: app_usuarioWhereInput
    orderBy?: app_usuarioOrderByWithRelationInput | app_usuarioOrderByWithRelationInput[]
    cursor?: app_usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_usuarioScalarFieldEnum | App_usuarioScalarFieldEnum[]
  }

  /**
   * app_clinica.app_usuario
   */
  export type app_clinica$app_usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    where?: app_usuarioWhereInput
    orderBy?: app_usuarioOrderByWithRelationInput | app_usuarioOrderByWithRelationInput[]
    cursor?: app_usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_usuarioScalarFieldEnum | App_usuarioScalarFieldEnum[]
  }

  /**
   * app_clinica without action
   */
  export type app_clinicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
  }


  /**
   * Model app_log_acao
   */

  export type AggregateApp_log_acao = {
    _count: App_log_acaoCountAggregateOutputType | null
    _avg: App_log_acaoAvgAggregateOutputType | null
    _sum: App_log_acaoSumAggregateOutputType | null
    _min: App_log_acaoMinAggregateOutputType | null
    _max: App_log_acaoMaxAggregateOutputType | null
  }

  export type App_log_acaoAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type App_log_acaoSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type App_log_acaoMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    acao: string | null
    criado_em: Date | null
  }

  export type App_log_acaoMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    acao: string | null
    criado_em: Date | null
  }

  export type App_log_acaoCountAggregateOutputType = {
    id: number
    usuario_id: number
    acao: number
    criado_em: number
    _all: number
  }


  export type App_log_acaoAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type App_log_acaoSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type App_log_acaoMinAggregateInputType = {
    id?: true
    usuario_id?: true
    acao?: true
    criado_em?: true
  }

  export type App_log_acaoMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    acao?: true
    criado_em?: true
  }

  export type App_log_acaoCountAggregateInputType = {
    id?: true
    usuario_id?: true
    acao?: true
    criado_em?: true
    _all?: true
  }

  export type App_log_acaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_log_acao to aggregate.
     */
    where?: app_log_acaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_log_acaos to fetch.
     */
    orderBy?: app_log_acaoOrderByWithRelationInput | app_log_acaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_log_acaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_log_acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_log_acaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_log_acaos
    **/
    _count?: true | App_log_acaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_log_acaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_log_acaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_log_acaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_log_acaoMaxAggregateInputType
  }

  export type GetApp_log_acaoAggregateType<T extends App_log_acaoAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_log_acao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_log_acao[P]>
      : GetScalarType<T[P], AggregateApp_log_acao[P]>
  }




  export type app_log_acaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_log_acaoWhereInput
    orderBy?: app_log_acaoOrderByWithAggregationInput | app_log_acaoOrderByWithAggregationInput[]
    by: App_log_acaoScalarFieldEnum[] | App_log_acaoScalarFieldEnum
    having?: app_log_acaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_log_acaoCountAggregateInputType | true
    _avg?: App_log_acaoAvgAggregateInputType
    _sum?: App_log_acaoSumAggregateInputType
    _min?: App_log_acaoMinAggregateInputType
    _max?: App_log_acaoMaxAggregateInputType
  }

  export type App_log_acaoGroupByOutputType = {
    id: number
    usuario_id: number | null
    acao: string | null
    criado_em: Date | null
    _count: App_log_acaoCountAggregateOutputType | null
    _avg: App_log_acaoAvgAggregateOutputType | null
    _sum: App_log_acaoSumAggregateOutputType | null
    _min: App_log_acaoMinAggregateOutputType | null
    _max: App_log_acaoMaxAggregateOutputType | null
  }

  type GetApp_log_acaoGroupByPayload<T extends app_log_acaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_log_acaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_log_acaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_log_acaoGroupByOutputType[P]>
            : GetScalarType<T[P], App_log_acaoGroupByOutputType[P]>
        }
      >
    >


  export type app_log_acaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    acao?: boolean
    criado_em?: boolean
    app_usuario?: boolean | app_log_acao$app_usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["app_log_acao"]>

  export type app_log_acaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    acao?: boolean
    criado_em?: boolean
    app_usuario?: boolean | app_log_acao$app_usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["app_log_acao"]>

  export type app_log_acaoSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    acao?: boolean
    criado_em?: boolean
  }

  export type app_log_acaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_usuario?: boolean | app_log_acao$app_usuarioArgs<ExtArgs>
  }
  export type app_log_acaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_usuario?: boolean | app_log_acao$app_usuarioArgs<ExtArgs>
  }

  export type $app_log_acaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_log_acao"
    objects: {
      app_usuario: Prisma.$app_usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number | null
      acao: string | null
      criado_em: Date | null
    }, ExtArgs["result"]["app_log_acao"]>
    composites: {}
  }

  type app_log_acaoGetPayload<S extends boolean | null | undefined | app_log_acaoDefaultArgs> = $Result.GetResult<Prisma.$app_log_acaoPayload, S>

  type app_log_acaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_log_acaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_log_acaoCountAggregateInputType | true
    }

  export interface app_log_acaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_log_acao'], meta: { name: 'app_log_acao' } }
    /**
     * Find zero or one App_log_acao that matches the filter.
     * @param {app_log_acaoFindUniqueArgs} args - Arguments to find a App_log_acao
     * @example
     * // Get one App_log_acao
     * const app_log_acao = await prisma.app_log_acao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_log_acaoFindUniqueArgs>(args: SelectSubset<T, app_log_acaoFindUniqueArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_log_acao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_log_acaoFindUniqueOrThrowArgs} args - Arguments to find a App_log_acao
     * @example
     * // Get one App_log_acao
     * const app_log_acao = await prisma.app_log_acao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_log_acaoFindUniqueOrThrowArgs>(args: SelectSubset<T, app_log_acaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_log_acao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_log_acaoFindFirstArgs} args - Arguments to find a App_log_acao
     * @example
     * // Get one App_log_acao
     * const app_log_acao = await prisma.app_log_acao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_log_acaoFindFirstArgs>(args?: SelectSubset<T, app_log_acaoFindFirstArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_log_acao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_log_acaoFindFirstOrThrowArgs} args - Arguments to find a App_log_acao
     * @example
     * // Get one App_log_acao
     * const app_log_acao = await prisma.app_log_acao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_log_acaoFindFirstOrThrowArgs>(args?: SelectSubset<T, app_log_acaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_log_acaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_log_acaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_log_acaos
     * const app_log_acaos = await prisma.app_log_acao.findMany()
     * 
     * // Get first 10 App_log_acaos
     * const app_log_acaos = await prisma.app_log_acao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_log_acaoWithIdOnly = await prisma.app_log_acao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_log_acaoFindManyArgs>(args?: SelectSubset<T, app_log_acaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_log_acao.
     * @param {app_log_acaoCreateArgs} args - Arguments to create a App_log_acao.
     * @example
     * // Create one App_log_acao
     * const App_log_acao = await prisma.app_log_acao.create({
     *   data: {
     *     // ... data to create a App_log_acao
     *   }
     * })
     * 
     */
    create<T extends app_log_acaoCreateArgs>(args: SelectSubset<T, app_log_acaoCreateArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_log_acaos.
     * @param {app_log_acaoCreateManyArgs} args - Arguments to create many App_log_acaos.
     * @example
     * // Create many App_log_acaos
     * const app_log_acao = await prisma.app_log_acao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_log_acaoCreateManyArgs>(args?: SelectSubset<T, app_log_acaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_log_acaos and returns the data saved in the database.
     * @param {app_log_acaoCreateManyAndReturnArgs} args - Arguments to create many App_log_acaos.
     * @example
     * // Create many App_log_acaos
     * const app_log_acao = await prisma.app_log_acao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_log_acaos and only return the `id`
     * const app_log_acaoWithIdOnly = await prisma.app_log_acao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_log_acaoCreateManyAndReturnArgs>(args?: SelectSubset<T, app_log_acaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_log_acao.
     * @param {app_log_acaoDeleteArgs} args - Arguments to delete one App_log_acao.
     * @example
     * // Delete one App_log_acao
     * const App_log_acao = await prisma.app_log_acao.delete({
     *   where: {
     *     // ... filter to delete one App_log_acao
     *   }
     * })
     * 
     */
    delete<T extends app_log_acaoDeleteArgs>(args: SelectSubset<T, app_log_acaoDeleteArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_log_acao.
     * @param {app_log_acaoUpdateArgs} args - Arguments to update one App_log_acao.
     * @example
     * // Update one App_log_acao
     * const app_log_acao = await prisma.app_log_acao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_log_acaoUpdateArgs>(args: SelectSubset<T, app_log_acaoUpdateArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_log_acaos.
     * @param {app_log_acaoDeleteManyArgs} args - Arguments to filter App_log_acaos to delete.
     * @example
     * // Delete a few App_log_acaos
     * const { count } = await prisma.app_log_acao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_log_acaoDeleteManyArgs>(args?: SelectSubset<T, app_log_acaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_log_acaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_log_acaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_log_acaos
     * const app_log_acao = await prisma.app_log_acao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_log_acaoUpdateManyArgs>(args: SelectSubset<T, app_log_acaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_log_acao.
     * @param {app_log_acaoUpsertArgs} args - Arguments to update or create a App_log_acao.
     * @example
     * // Update or create a App_log_acao
     * const app_log_acao = await prisma.app_log_acao.upsert({
     *   create: {
     *     // ... data to create a App_log_acao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_log_acao we want to update
     *   }
     * })
     */
    upsert<T extends app_log_acaoUpsertArgs>(args: SelectSubset<T, app_log_acaoUpsertArgs<ExtArgs>>): Prisma__app_log_acaoClient<$Result.GetResult<Prisma.$app_log_acaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_log_acaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_log_acaoCountArgs} args - Arguments to filter App_log_acaos to count.
     * @example
     * // Count the number of App_log_acaos
     * const count = await prisma.app_log_acao.count({
     *   where: {
     *     // ... the filter for the App_log_acaos we want to count
     *   }
     * })
    **/
    count<T extends app_log_acaoCountArgs>(
      args?: Subset<T, app_log_acaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_log_acaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_log_acao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_log_acaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_log_acaoAggregateArgs>(args: Subset<T, App_log_acaoAggregateArgs>): Prisma.PrismaPromise<GetApp_log_acaoAggregateType<T>>

    /**
     * Group by App_log_acao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_log_acaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_log_acaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_log_acaoGroupByArgs['orderBy'] }
        : { orderBy?: app_log_acaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_log_acaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_log_acaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_log_acao model
   */
  readonly fields: app_log_acaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_log_acao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_log_acaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_usuario<T extends app_log_acao$app_usuarioArgs<ExtArgs> = {}>(args?: Subset<T, app_log_acao$app_usuarioArgs<ExtArgs>>): Prisma__app_usuarioClient<$Result.GetResult<Prisma.$app_usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_log_acao model
   */ 
  interface app_log_acaoFieldRefs {
    readonly id: FieldRef<"app_log_acao", 'Int'>
    readonly usuario_id: FieldRef<"app_log_acao", 'Int'>
    readonly acao: FieldRef<"app_log_acao", 'String'>
    readonly criado_em: FieldRef<"app_log_acao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_log_acao findUnique
   */
  export type app_log_acaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * Filter, which app_log_acao to fetch.
     */
    where: app_log_acaoWhereUniqueInput
  }

  /**
   * app_log_acao findUniqueOrThrow
   */
  export type app_log_acaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * Filter, which app_log_acao to fetch.
     */
    where: app_log_acaoWhereUniqueInput
  }

  /**
   * app_log_acao findFirst
   */
  export type app_log_acaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * Filter, which app_log_acao to fetch.
     */
    where?: app_log_acaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_log_acaos to fetch.
     */
    orderBy?: app_log_acaoOrderByWithRelationInput | app_log_acaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_log_acaos.
     */
    cursor?: app_log_acaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_log_acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_log_acaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_log_acaos.
     */
    distinct?: App_log_acaoScalarFieldEnum | App_log_acaoScalarFieldEnum[]
  }

  /**
   * app_log_acao findFirstOrThrow
   */
  export type app_log_acaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * Filter, which app_log_acao to fetch.
     */
    where?: app_log_acaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_log_acaos to fetch.
     */
    orderBy?: app_log_acaoOrderByWithRelationInput | app_log_acaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_log_acaos.
     */
    cursor?: app_log_acaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_log_acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_log_acaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_log_acaos.
     */
    distinct?: App_log_acaoScalarFieldEnum | App_log_acaoScalarFieldEnum[]
  }

  /**
   * app_log_acao findMany
   */
  export type app_log_acaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * Filter, which app_log_acaos to fetch.
     */
    where?: app_log_acaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_log_acaos to fetch.
     */
    orderBy?: app_log_acaoOrderByWithRelationInput | app_log_acaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_log_acaos.
     */
    cursor?: app_log_acaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_log_acaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_log_acaos.
     */
    skip?: number
    distinct?: App_log_acaoScalarFieldEnum | App_log_acaoScalarFieldEnum[]
  }

  /**
   * app_log_acao create
   */
  export type app_log_acaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * The data needed to create a app_log_acao.
     */
    data?: XOR<app_log_acaoCreateInput, app_log_acaoUncheckedCreateInput>
  }

  /**
   * app_log_acao createMany
   */
  export type app_log_acaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_log_acaos.
     */
    data: app_log_acaoCreateManyInput | app_log_acaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_log_acao createManyAndReturn
   */
  export type app_log_acaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_log_acaos.
     */
    data: app_log_acaoCreateManyInput | app_log_acaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_log_acao update
   */
  export type app_log_acaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * The data needed to update a app_log_acao.
     */
    data: XOR<app_log_acaoUpdateInput, app_log_acaoUncheckedUpdateInput>
    /**
     * Choose, which app_log_acao to update.
     */
    where: app_log_acaoWhereUniqueInput
  }

  /**
   * app_log_acao updateMany
   */
  export type app_log_acaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_log_acaos.
     */
    data: XOR<app_log_acaoUpdateManyMutationInput, app_log_acaoUncheckedUpdateManyInput>
    /**
     * Filter which app_log_acaos to update
     */
    where?: app_log_acaoWhereInput
  }

  /**
   * app_log_acao upsert
   */
  export type app_log_acaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * The filter to search for the app_log_acao to update in case it exists.
     */
    where: app_log_acaoWhereUniqueInput
    /**
     * In case the app_log_acao found by the `where` argument doesn't exist, create a new app_log_acao with this data.
     */
    create: XOR<app_log_acaoCreateInput, app_log_acaoUncheckedCreateInput>
    /**
     * In case the app_log_acao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_log_acaoUpdateInput, app_log_acaoUncheckedUpdateInput>
  }

  /**
   * app_log_acao delete
   */
  export type app_log_acaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
    /**
     * Filter which app_log_acao to delete.
     */
    where: app_log_acaoWhereUniqueInput
  }

  /**
   * app_log_acao deleteMany
   */
  export type app_log_acaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_log_acaos to delete
     */
    where?: app_log_acaoWhereInput
  }

  /**
   * app_log_acao.app_usuario
   */
  export type app_log_acao$app_usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_usuario
     */
    select?: app_usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_usuarioInclude<ExtArgs> | null
    where?: app_usuarioWhereInput
  }

  /**
   * app_log_acao without action
   */
  export type app_log_acaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_log_acao
     */
    select?: app_log_acaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_log_acaoInclude<ExtArgs> | null
  }


  /**
   * Model app_conversa
   */

  export type AggregateApp_conversa = {
    _count: App_conversaCountAggregateOutputType | null
    _avg: App_conversaAvgAggregateOutputType | null
    _sum: App_conversaSumAggregateOutputType | null
    _min: App_conversaMinAggregateOutputType | null
    _max: App_conversaMaxAggregateOutputType | null
  }

  export type App_conversaAvgAggregateOutputType = {
    id: number | null
    paciente_id: number | null
    clinica_id: number | null
    grupo_id: number | null
  }

  export type App_conversaSumAggregateOutputType = {
    id: number | null
    paciente_id: number | null
    clinica_id: number | null
    grupo_id: number | null
  }

  export type App_conversaMinAggregateOutputType = {
    id: number | null
    paciente_id: number | null
    clinica_id: number | null
    iniciada_em: Date | null
    atualizada_em: Date | null
    grupo_id: number | null
  }

  export type App_conversaMaxAggregateOutputType = {
    id: number | null
    paciente_id: number | null
    clinica_id: number | null
    iniciada_em: Date | null
    atualizada_em: Date | null
    grupo_id: number | null
  }

  export type App_conversaCountAggregateOutputType = {
    id: number
    paciente_id: number
    clinica_id: number
    iniciada_em: number
    atualizada_em: number
    grupo_id: number
    _all: number
  }


  export type App_conversaAvgAggregateInputType = {
    id?: true
    paciente_id?: true
    clinica_id?: true
    grupo_id?: true
  }

  export type App_conversaSumAggregateInputType = {
    id?: true
    paciente_id?: true
    clinica_id?: true
    grupo_id?: true
  }

  export type App_conversaMinAggregateInputType = {
    id?: true
    paciente_id?: true
    clinica_id?: true
    iniciada_em?: true
    atualizada_em?: true
    grupo_id?: true
  }

  export type App_conversaMaxAggregateInputType = {
    id?: true
    paciente_id?: true
    clinica_id?: true
    iniciada_em?: true
    atualizada_em?: true
    grupo_id?: true
  }

  export type App_conversaCountAggregateInputType = {
    id?: true
    paciente_id?: true
    clinica_id?: true
    iniciada_em?: true
    atualizada_em?: true
    grupo_id?: true
    _all?: true
  }

  export type App_conversaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_conversa to aggregate.
     */
    where?: app_conversaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_conversas to fetch.
     */
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_conversaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_conversas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_conversas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_conversas
    **/
    _count?: true | App_conversaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_conversaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_conversaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_conversaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_conversaMaxAggregateInputType
  }

  export type GetApp_conversaAggregateType<T extends App_conversaAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_conversa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_conversa[P]>
      : GetScalarType<T[P], AggregateApp_conversa[P]>
  }




  export type app_conversaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_conversaWhereInput
    orderBy?: app_conversaOrderByWithAggregationInput | app_conversaOrderByWithAggregationInput[]
    by: App_conversaScalarFieldEnum[] | App_conversaScalarFieldEnum
    having?: app_conversaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_conversaCountAggregateInputType | true
    _avg?: App_conversaAvgAggregateInputType
    _sum?: App_conversaSumAggregateInputType
    _min?: App_conversaMinAggregateInputType
    _max?: App_conversaMaxAggregateInputType
  }

  export type App_conversaGroupByOutputType = {
    id: number
    paciente_id: number | null
    clinica_id: number | null
    iniciada_em: Date | null
    atualizada_em: Date | null
    grupo_id: number | null
    _count: App_conversaCountAggregateOutputType | null
    _avg: App_conversaAvgAggregateOutputType | null
    _sum: App_conversaSumAggregateOutputType | null
    _min: App_conversaMinAggregateOutputType | null
    _max: App_conversaMaxAggregateOutputType | null
  }

  type GetApp_conversaGroupByPayload<T extends app_conversaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_conversaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_conversaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_conversaGroupByOutputType[P]>
            : GetScalarType<T[P], App_conversaGroupByOutputType[P]>
        }
      >
    >


  export type app_conversaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paciente_id?: boolean
    clinica_id?: boolean
    iniciada_em?: boolean
    atualizada_em?: boolean
    grupo_id?: boolean
    app_clinica?: boolean | app_conversa$app_clinicaArgs<ExtArgs>
    app_paciente?: boolean | app_conversa$app_pacienteArgs<ExtArgs>
    app_grupo?: boolean | app_conversa$app_grupoArgs<ExtArgs>
    app_mensagem?: boolean | app_conversa$app_mensagemArgs<ExtArgs>
    _count?: boolean | App_conversaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_conversa"]>

  export type app_conversaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paciente_id?: boolean
    clinica_id?: boolean
    iniciada_em?: boolean
    atualizada_em?: boolean
    grupo_id?: boolean
    app_clinica?: boolean | app_conversa$app_clinicaArgs<ExtArgs>
    app_paciente?: boolean | app_conversa$app_pacienteArgs<ExtArgs>
    app_grupo?: boolean | app_conversa$app_grupoArgs<ExtArgs>
  }, ExtArgs["result"]["app_conversa"]>

  export type app_conversaSelectScalar = {
    id?: boolean
    paciente_id?: boolean
    clinica_id?: boolean
    iniciada_em?: boolean
    atualizada_em?: boolean
    grupo_id?: boolean
  }

  export type app_conversaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_conversa$app_clinicaArgs<ExtArgs>
    app_paciente?: boolean | app_conversa$app_pacienteArgs<ExtArgs>
    app_grupo?: boolean | app_conversa$app_grupoArgs<ExtArgs>
    app_mensagem?: boolean | app_conversa$app_mensagemArgs<ExtArgs>
    _count?: boolean | App_conversaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type app_conversaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_conversa$app_clinicaArgs<ExtArgs>
    app_paciente?: boolean | app_conversa$app_pacienteArgs<ExtArgs>
    app_grupo?: boolean | app_conversa$app_grupoArgs<ExtArgs>
  }

  export type $app_conversaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_conversa"
    objects: {
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
      app_paciente: Prisma.$app_pacientePayload<ExtArgs> | null
      app_grupo: Prisma.$app_grupoPayload<ExtArgs> | null
      app_mensagem: Prisma.$app_mensagemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paciente_id: number | null
      clinica_id: number | null
      iniciada_em: Date | null
      atualizada_em: Date | null
      grupo_id: number | null
    }, ExtArgs["result"]["app_conversa"]>
    composites: {}
  }

  type app_conversaGetPayload<S extends boolean | null | undefined | app_conversaDefaultArgs> = $Result.GetResult<Prisma.$app_conversaPayload, S>

  type app_conversaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_conversaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_conversaCountAggregateInputType | true
    }

  export interface app_conversaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_conversa'], meta: { name: 'app_conversa' } }
    /**
     * Find zero or one App_conversa that matches the filter.
     * @param {app_conversaFindUniqueArgs} args - Arguments to find a App_conversa
     * @example
     * // Get one App_conversa
     * const app_conversa = await prisma.app_conversa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_conversaFindUniqueArgs>(args: SelectSubset<T, app_conversaFindUniqueArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_conversa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_conversaFindUniqueOrThrowArgs} args - Arguments to find a App_conversa
     * @example
     * // Get one App_conversa
     * const app_conversa = await prisma.app_conversa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_conversaFindUniqueOrThrowArgs>(args: SelectSubset<T, app_conversaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_conversa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_conversaFindFirstArgs} args - Arguments to find a App_conversa
     * @example
     * // Get one App_conversa
     * const app_conversa = await prisma.app_conversa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_conversaFindFirstArgs>(args?: SelectSubset<T, app_conversaFindFirstArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_conversa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_conversaFindFirstOrThrowArgs} args - Arguments to find a App_conversa
     * @example
     * // Get one App_conversa
     * const app_conversa = await prisma.app_conversa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_conversaFindFirstOrThrowArgs>(args?: SelectSubset<T, app_conversaFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_conversas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_conversaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_conversas
     * const app_conversas = await prisma.app_conversa.findMany()
     * 
     * // Get first 10 App_conversas
     * const app_conversas = await prisma.app_conversa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_conversaWithIdOnly = await prisma.app_conversa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_conversaFindManyArgs>(args?: SelectSubset<T, app_conversaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_conversa.
     * @param {app_conversaCreateArgs} args - Arguments to create a App_conversa.
     * @example
     * // Create one App_conversa
     * const App_conversa = await prisma.app_conversa.create({
     *   data: {
     *     // ... data to create a App_conversa
     *   }
     * })
     * 
     */
    create<T extends app_conversaCreateArgs>(args: SelectSubset<T, app_conversaCreateArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_conversas.
     * @param {app_conversaCreateManyArgs} args - Arguments to create many App_conversas.
     * @example
     * // Create many App_conversas
     * const app_conversa = await prisma.app_conversa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_conversaCreateManyArgs>(args?: SelectSubset<T, app_conversaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_conversas and returns the data saved in the database.
     * @param {app_conversaCreateManyAndReturnArgs} args - Arguments to create many App_conversas.
     * @example
     * // Create many App_conversas
     * const app_conversa = await prisma.app_conversa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_conversas and only return the `id`
     * const app_conversaWithIdOnly = await prisma.app_conversa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_conversaCreateManyAndReturnArgs>(args?: SelectSubset<T, app_conversaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_conversa.
     * @param {app_conversaDeleteArgs} args - Arguments to delete one App_conversa.
     * @example
     * // Delete one App_conversa
     * const App_conversa = await prisma.app_conversa.delete({
     *   where: {
     *     // ... filter to delete one App_conversa
     *   }
     * })
     * 
     */
    delete<T extends app_conversaDeleteArgs>(args: SelectSubset<T, app_conversaDeleteArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_conversa.
     * @param {app_conversaUpdateArgs} args - Arguments to update one App_conversa.
     * @example
     * // Update one App_conversa
     * const app_conversa = await prisma.app_conversa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_conversaUpdateArgs>(args: SelectSubset<T, app_conversaUpdateArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_conversas.
     * @param {app_conversaDeleteManyArgs} args - Arguments to filter App_conversas to delete.
     * @example
     * // Delete a few App_conversas
     * const { count } = await prisma.app_conversa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_conversaDeleteManyArgs>(args?: SelectSubset<T, app_conversaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_conversas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_conversaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_conversas
     * const app_conversa = await prisma.app_conversa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_conversaUpdateManyArgs>(args: SelectSubset<T, app_conversaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_conversa.
     * @param {app_conversaUpsertArgs} args - Arguments to update or create a App_conversa.
     * @example
     * // Update or create a App_conversa
     * const app_conversa = await prisma.app_conversa.upsert({
     *   create: {
     *     // ... data to create a App_conversa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_conversa we want to update
     *   }
     * })
     */
    upsert<T extends app_conversaUpsertArgs>(args: SelectSubset<T, app_conversaUpsertArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_conversas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_conversaCountArgs} args - Arguments to filter App_conversas to count.
     * @example
     * // Count the number of App_conversas
     * const count = await prisma.app_conversa.count({
     *   where: {
     *     // ... the filter for the App_conversas we want to count
     *   }
     * })
    **/
    count<T extends app_conversaCountArgs>(
      args?: Subset<T, app_conversaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_conversaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_conversa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_conversaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_conversaAggregateArgs>(args: Subset<T, App_conversaAggregateArgs>): Prisma.PrismaPromise<GetApp_conversaAggregateType<T>>

    /**
     * Group by App_conversa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_conversaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_conversaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_conversaGroupByArgs['orderBy'] }
        : { orderBy?: app_conversaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_conversaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_conversaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_conversa model
   */
  readonly fields: app_conversaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_conversa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_conversaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_clinica<T extends app_conversa$app_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_conversa$app_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    app_paciente<T extends app_conversa$app_pacienteArgs<ExtArgs> = {}>(args?: Subset<T, app_conversa$app_pacienteArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    app_grupo<T extends app_conversa$app_grupoArgs<ExtArgs> = {}>(args?: Subset<T, app_conversa$app_grupoArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    app_mensagem<T extends app_conversa$app_mensagemArgs<ExtArgs> = {}>(args?: Subset<T, app_conversa$app_mensagemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_conversa model
   */ 
  interface app_conversaFieldRefs {
    readonly id: FieldRef<"app_conversa", 'Int'>
    readonly paciente_id: FieldRef<"app_conversa", 'Int'>
    readonly clinica_id: FieldRef<"app_conversa", 'Int'>
    readonly iniciada_em: FieldRef<"app_conversa", 'DateTime'>
    readonly atualizada_em: FieldRef<"app_conversa", 'DateTime'>
    readonly grupo_id: FieldRef<"app_conversa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * app_conversa findUnique
   */
  export type app_conversaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * Filter, which app_conversa to fetch.
     */
    where: app_conversaWhereUniqueInput
  }

  /**
   * app_conversa findUniqueOrThrow
   */
  export type app_conversaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * Filter, which app_conversa to fetch.
     */
    where: app_conversaWhereUniqueInput
  }

  /**
   * app_conversa findFirst
   */
  export type app_conversaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * Filter, which app_conversa to fetch.
     */
    where?: app_conversaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_conversas to fetch.
     */
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_conversas.
     */
    cursor?: app_conversaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_conversas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_conversas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_conversas.
     */
    distinct?: App_conversaScalarFieldEnum | App_conversaScalarFieldEnum[]
  }

  /**
   * app_conversa findFirstOrThrow
   */
  export type app_conversaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * Filter, which app_conversa to fetch.
     */
    where?: app_conversaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_conversas to fetch.
     */
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_conversas.
     */
    cursor?: app_conversaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_conversas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_conversas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_conversas.
     */
    distinct?: App_conversaScalarFieldEnum | App_conversaScalarFieldEnum[]
  }

  /**
   * app_conversa findMany
   */
  export type app_conversaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * Filter, which app_conversas to fetch.
     */
    where?: app_conversaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_conversas to fetch.
     */
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_conversas.
     */
    cursor?: app_conversaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_conversas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_conversas.
     */
    skip?: number
    distinct?: App_conversaScalarFieldEnum | App_conversaScalarFieldEnum[]
  }

  /**
   * app_conversa create
   */
  export type app_conversaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * The data needed to create a app_conversa.
     */
    data?: XOR<app_conversaCreateInput, app_conversaUncheckedCreateInput>
  }

  /**
   * app_conversa createMany
   */
  export type app_conversaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_conversas.
     */
    data: app_conversaCreateManyInput | app_conversaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_conversa createManyAndReturn
   */
  export type app_conversaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_conversas.
     */
    data: app_conversaCreateManyInput | app_conversaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_conversa update
   */
  export type app_conversaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * The data needed to update a app_conversa.
     */
    data: XOR<app_conversaUpdateInput, app_conversaUncheckedUpdateInput>
    /**
     * Choose, which app_conversa to update.
     */
    where: app_conversaWhereUniqueInput
  }

  /**
   * app_conversa updateMany
   */
  export type app_conversaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_conversas.
     */
    data: XOR<app_conversaUpdateManyMutationInput, app_conversaUncheckedUpdateManyInput>
    /**
     * Filter which app_conversas to update
     */
    where?: app_conversaWhereInput
  }

  /**
   * app_conversa upsert
   */
  export type app_conversaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * The filter to search for the app_conversa to update in case it exists.
     */
    where: app_conversaWhereUniqueInput
    /**
     * In case the app_conversa found by the `where` argument doesn't exist, create a new app_conversa with this data.
     */
    create: XOR<app_conversaCreateInput, app_conversaUncheckedCreateInput>
    /**
     * In case the app_conversa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_conversaUpdateInput, app_conversaUncheckedUpdateInput>
  }

  /**
   * app_conversa delete
   */
  export type app_conversaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    /**
     * Filter which app_conversa to delete.
     */
    where: app_conversaWhereUniqueInput
  }

  /**
   * app_conversa deleteMany
   */
  export type app_conversaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_conversas to delete
     */
    where?: app_conversaWhereInput
  }

  /**
   * app_conversa.app_clinica
   */
  export type app_conversa$app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_conversa.app_paciente
   */
  export type app_conversa$app_pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    where?: app_pacienteWhereInput
  }

  /**
   * app_conversa.app_grupo
   */
  export type app_conversa$app_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    where?: app_grupoWhereInput
  }

  /**
   * app_conversa.app_mensagem
   */
  export type app_conversa$app_mensagemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    where?: app_mensagemWhereInput
    orderBy?: app_mensagemOrderByWithRelationInput | app_mensagemOrderByWithRelationInput[]
    cursor?: app_mensagemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_mensagemScalarFieldEnum | App_mensagemScalarFieldEnum[]
  }

  /**
   * app_conversa without action
   */
  export type app_conversaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
  }


  /**
   * Model app_mensagem
   */

  export type AggregateApp_mensagem = {
    _count: App_mensagemCountAggregateOutputType | null
    _avg: App_mensagemAvgAggregateOutputType | null
    _sum: App_mensagemSumAggregateOutputType | null
    _min: App_mensagemMinAggregateOutputType | null
    _max: App_mensagemMaxAggregateOutputType | null
  }

  export type App_mensagemAvgAggregateOutputType = {
    id: number | null
    conversa_id: number | null
  }

  export type App_mensagemSumAggregateOutputType = {
    id: number | null
    conversa_id: number | null
  }

  export type App_mensagemMinAggregateOutputType = {
    id: number | null
    conversa_id: number | null
    remetente: string | null
    conteudo: string | null
    tipo_mensagem: string | null
    evolution_id: string | null
    status: string | null
    criadaEm: Date | null
  }

  export type App_mensagemMaxAggregateOutputType = {
    id: number | null
    conversa_id: number | null
    remetente: string | null
    conteudo: string | null
    tipo_mensagem: string | null
    evolution_id: string | null
    status: string | null
    criadaEm: Date | null
  }

  export type App_mensagemCountAggregateOutputType = {
    id: number
    conversa_id: number
    remetente: number
    conteudo: number
    tipo_mensagem: number
    evolution_id: number
    status: number
    criadaEm: number
    _all: number
  }


  export type App_mensagemAvgAggregateInputType = {
    id?: true
    conversa_id?: true
  }

  export type App_mensagemSumAggregateInputType = {
    id?: true
    conversa_id?: true
  }

  export type App_mensagemMinAggregateInputType = {
    id?: true
    conversa_id?: true
    remetente?: true
    conteudo?: true
    tipo_mensagem?: true
    evolution_id?: true
    status?: true
    criadaEm?: true
  }

  export type App_mensagemMaxAggregateInputType = {
    id?: true
    conversa_id?: true
    remetente?: true
    conteudo?: true
    tipo_mensagem?: true
    evolution_id?: true
    status?: true
    criadaEm?: true
  }

  export type App_mensagemCountAggregateInputType = {
    id?: true
    conversa_id?: true
    remetente?: true
    conteudo?: true
    tipo_mensagem?: true
    evolution_id?: true
    status?: true
    criadaEm?: true
    _all?: true
  }

  export type App_mensagemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_mensagem to aggregate.
     */
    where?: app_mensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagems to fetch.
     */
    orderBy?: app_mensagemOrderByWithRelationInput | app_mensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_mensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_mensagems
    **/
    _count?: true | App_mensagemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_mensagemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_mensagemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_mensagemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_mensagemMaxAggregateInputType
  }

  export type GetApp_mensagemAggregateType<T extends App_mensagemAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_mensagem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_mensagem[P]>
      : GetScalarType<T[P], AggregateApp_mensagem[P]>
  }




  export type app_mensagemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_mensagemWhereInput
    orderBy?: app_mensagemOrderByWithAggregationInput | app_mensagemOrderByWithAggregationInput[]
    by: App_mensagemScalarFieldEnum[] | App_mensagemScalarFieldEnum
    having?: app_mensagemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_mensagemCountAggregateInputType | true
    _avg?: App_mensagemAvgAggregateInputType
    _sum?: App_mensagemSumAggregateInputType
    _min?: App_mensagemMinAggregateInputType
    _max?: App_mensagemMaxAggregateInputType
  }

  export type App_mensagemGroupByOutputType = {
    id: number
    conversa_id: number | null
    remetente: string | null
    conteudo: string | null
    tipo_mensagem: string | null
    evolution_id: string | null
    status: string | null
    criadaEm: Date | null
    _count: App_mensagemCountAggregateOutputType | null
    _avg: App_mensagemAvgAggregateOutputType | null
    _sum: App_mensagemSumAggregateOutputType | null
    _min: App_mensagemMinAggregateOutputType | null
    _max: App_mensagemMaxAggregateOutputType | null
  }

  type GetApp_mensagemGroupByPayload<T extends app_mensagemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_mensagemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_mensagemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_mensagemGroupByOutputType[P]>
            : GetScalarType<T[P], App_mensagemGroupByOutputType[P]>
        }
      >
    >


  export type app_mensagemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversa_id?: boolean
    remetente?: boolean
    conteudo?: boolean
    tipo_mensagem?: boolean
    evolution_id?: boolean
    status?: boolean
    criadaEm?: boolean
    app_conversa?: boolean | app_mensagem$app_conversaArgs<ExtArgs>
    app_midia?: boolean | app_mensagem$app_midiaArgs<ExtArgs>
    app_receipt?: boolean | app_mensagem$app_receiptArgs<ExtArgs>
    _count?: boolean | App_mensagemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_mensagem"]>

  export type app_mensagemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversa_id?: boolean
    remetente?: boolean
    conteudo?: boolean
    tipo_mensagem?: boolean
    evolution_id?: boolean
    status?: boolean
    criadaEm?: boolean
    app_conversa?: boolean | app_mensagem$app_conversaArgs<ExtArgs>
  }, ExtArgs["result"]["app_mensagem"]>

  export type app_mensagemSelectScalar = {
    id?: boolean
    conversa_id?: boolean
    remetente?: boolean
    conteudo?: boolean
    tipo_mensagem?: boolean
    evolution_id?: boolean
    status?: boolean
    criadaEm?: boolean
  }

  export type app_mensagemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | app_mensagem$app_conversaArgs<ExtArgs>
    app_midia?: boolean | app_mensagem$app_midiaArgs<ExtArgs>
    app_receipt?: boolean | app_mensagem$app_receiptArgs<ExtArgs>
    _count?: boolean | App_mensagemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type app_mensagemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | app_mensagem$app_conversaArgs<ExtArgs>
  }

  export type $app_mensagemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_mensagem"
    objects: {
      app_conversa: Prisma.$app_conversaPayload<ExtArgs> | null
      app_midia: Prisma.$app_midiaPayload<ExtArgs>[]
      app_receipt: Prisma.$app_receiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversa_id: number | null
      remetente: string | null
      conteudo: string | null
      tipo_mensagem: string | null
      evolution_id: string | null
      status: string | null
      criadaEm: Date | null
    }, ExtArgs["result"]["app_mensagem"]>
    composites: {}
  }

  type app_mensagemGetPayload<S extends boolean | null | undefined | app_mensagemDefaultArgs> = $Result.GetResult<Prisma.$app_mensagemPayload, S>

  type app_mensagemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_mensagemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_mensagemCountAggregateInputType | true
    }

  export interface app_mensagemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_mensagem'], meta: { name: 'app_mensagem' } }
    /**
     * Find zero or one App_mensagem that matches the filter.
     * @param {app_mensagemFindUniqueArgs} args - Arguments to find a App_mensagem
     * @example
     * // Get one App_mensagem
     * const app_mensagem = await prisma.app_mensagem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_mensagemFindUniqueArgs>(args: SelectSubset<T, app_mensagemFindUniqueArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_mensagem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_mensagemFindUniqueOrThrowArgs} args - Arguments to find a App_mensagem
     * @example
     * // Get one App_mensagem
     * const app_mensagem = await prisma.app_mensagem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_mensagemFindUniqueOrThrowArgs>(args: SelectSubset<T, app_mensagemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_mensagem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagemFindFirstArgs} args - Arguments to find a App_mensagem
     * @example
     * // Get one App_mensagem
     * const app_mensagem = await prisma.app_mensagem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_mensagemFindFirstArgs>(args?: SelectSubset<T, app_mensagemFindFirstArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_mensagem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagemFindFirstOrThrowArgs} args - Arguments to find a App_mensagem
     * @example
     * // Get one App_mensagem
     * const app_mensagem = await prisma.app_mensagem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_mensagemFindFirstOrThrowArgs>(args?: SelectSubset<T, app_mensagemFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_mensagems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_mensagems
     * const app_mensagems = await prisma.app_mensagem.findMany()
     * 
     * // Get first 10 App_mensagems
     * const app_mensagems = await prisma.app_mensagem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_mensagemWithIdOnly = await prisma.app_mensagem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_mensagemFindManyArgs>(args?: SelectSubset<T, app_mensagemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_mensagem.
     * @param {app_mensagemCreateArgs} args - Arguments to create a App_mensagem.
     * @example
     * // Create one App_mensagem
     * const App_mensagem = await prisma.app_mensagem.create({
     *   data: {
     *     // ... data to create a App_mensagem
     *   }
     * })
     * 
     */
    create<T extends app_mensagemCreateArgs>(args: SelectSubset<T, app_mensagemCreateArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_mensagems.
     * @param {app_mensagemCreateManyArgs} args - Arguments to create many App_mensagems.
     * @example
     * // Create many App_mensagems
     * const app_mensagem = await prisma.app_mensagem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_mensagemCreateManyArgs>(args?: SelectSubset<T, app_mensagemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_mensagems and returns the data saved in the database.
     * @param {app_mensagemCreateManyAndReturnArgs} args - Arguments to create many App_mensagems.
     * @example
     * // Create many App_mensagems
     * const app_mensagem = await prisma.app_mensagem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_mensagems and only return the `id`
     * const app_mensagemWithIdOnly = await prisma.app_mensagem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_mensagemCreateManyAndReturnArgs>(args?: SelectSubset<T, app_mensagemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_mensagem.
     * @param {app_mensagemDeleteArgs} args - Arguments to delete one App_mensagem.
     * @example
     * // Delete one App_mensagem
     * const App_mensagem = await prisma.app_mensagem.delete({
     *   where: {
     *     // ... filter to delete one App_mensagem
     *   }
     * })
     * 
     */
    delete<T extends app_mensagemDeleteArgs>(args: SelectSubset<T, app_mensagemDeleteArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_mensagem.
     * @param {app_mensagemUpdateArgs} args - Arguments to update one App_mensagem.
     * @example
     * // Update one App_mensagem
     * const app_mensagem = await prisma.app_mensagem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_mensagemUpdateArgs>(args: SelectSubset<T, app_mensagemUpdateArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_mensagems.
     * @param {app_mensagemDeleteManyArgs} args - Arguments to filter App_mensagems to delete.
     * @example
     * // Delete a few App_mensagems
     * const { count } = await prisma.app_mensagem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_mensagemDeleteManyArgs>(args?: SelectSubset<T, app_mensagemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_mensagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_mensagems
     * const app_mensagem = await prisma.app_mensagem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_mensagemUpdateManyArgs>(args: SelectSubset<T, app_mensagemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_mensagem.
     * @param {app_mensagemUpsertArgs} args - Arguments to update or create a App_mensagem.
     * @example
     * // Update or create a App_mensagem
     * const app_mensagem = await prisma.app_mensagem.upsert({
     *   create: {
     *     // ... data to create a App_mensagem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_mensagem we want to update
     *   }
     * })
     */
    upsert<T extends app_mensagemUpsertArgs>(args: SelectSubset<T, app_mensagemUpsertArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_mensagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagemCountArgs} args - Arguments to filter App_mensagems to count.
     * @example
     * // Count the number of App_mensagems
     * const count = await prisma.app_mensagem.count({
     *   where: {
     *     // ... the filter for the App_mensagems we want to count
     *   }
     * })
    **/
    count<T extends app_mensagemCountArgs>(
      args?: Subset<T, app_mensagemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_mensagemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_mensagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_mensagemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_mensagemAggregateArgs>(args: Subset<T, App_mensagemAggregateArgs>): Prisma.PrismaPromise<GetApp_mensagemAggregateType<T>>

    /**
     * Group by App_mensagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_mensagemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_mensagemGroupByArgs['orderBy'] }
        : { orderBy?: app_mensagemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_mensagemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_mensagemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_mensagem model
   */
  readonly fields: app_mensagemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_mensagem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_mensagemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_conversa<T extends app_mensagem$app_conversaArgs<ExtArgs> = {}>(args?: Subset<T, app_mensagem$app_conversaArgs<ExtArgs>>): Prisma__app_conversaClient<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    app_midia<T extends app_mensagem$app_midiaArgs<ExtArgs> = {}>(args?: Subset<T, app_mensagem$app_midiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "findMany"> | Null>
    app_receipt<T extends app_mensagem$app_receiptArgs<ExtArgs> = {}>(args?: Subset<T, app_mensagem$app_receiptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_mensagem model
   */ 
  interface app_mensagemFieldRefs {
    readonly id: FieldRef<"app_mensagem", 'Int'>
    readonly conversa_id: FieldRef<"app_mensagem", 'Int'>
    readonly remetente: FieldRef<"app_mensagem", 'String'>
    readonly conteudo: FieldRef<"app_mensagem", 'String'>
    readonly tipo_mensagem: FieldRef<"app_mensagem", 'String'>
    readonly evolution_id: FieldRef<"app_mensagem", 'String'>
    readonly status: FieldRef<"app_mensagem", 'String'>
    readonly criadaEm: FieldRef<"app_mensagem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_mensagem findUnique
   */
  export type app_mensagemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem to fetch.
     */
    where: app_mensagemWhereUniqueInput
  }

  /**
   * app_mensagem findUniqueOrThrow
   */
  export type app_mensagemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem to fetch.
     */
    where: app_mensagemWhereUniqueInput
  }

  /**
   * app_mensagem findFirst
   */
  export type app_mensagemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem to fetch.
     */
    where?: app_mensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagems to fetch.
     */
    orderBy?: app_mensagemOrderByWithRelationInput | app_mensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_mensagems.
     */
    cursor?: app_mensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_mensagems.
     */
    distinct?: App_mensagemScalarFieldEnum | App_mensagemScalarFieldEnum[]
  }

  /**
   * app_mensagem findFirstOrThrow
   */
  export type app_mensagemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem to fetch.
     */
    where?: app_mensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagems to fetch.
     */
    orderBy?: app_mensagemOrderByWithRelationInput | app_mensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_mensagems.
     */
    cursor?: app_mensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_mensagems.
     */
    distinct?: App_mensagemScalarFieldEnum | App_mensagemScalarFieldEnum[]
  }

  /**
   * app_mensagem findMany
   */
  export type app_mensagemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagems to fetch.
     */
    where?: app_mensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagems to fetch.
     */
    orderBy?: app_mensagemOrderByWithRelationInput | app_mensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_mensagems.
     */
    cursor?: app_mensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagems.
     */
    skip?: number
    distinct?: App_mensagemScalarFieldEnum | App_mensagemScalarFieldEnum[]
  }

  /**
   * app_mensagem create
   */
  export type app_mensagemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * The data needed to create a app_mensagem.
     */
    data?: XOR<app_mensagemCreateInput, app_mensagemUncheckedCreateInput>
  }

  /**
   * app_mensagem createMany
   */
  export type app_mensagemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_mensagems.
     */
    data: app_mensagemCreateManyInput | app_mensagemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_mensagem createManyAndReturn
   */
  export type app_mensagemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_mensagems.
     */
    data: app_mensagemCreateManyInput | app_mensagemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_mensagem update
   */
  export type app_mensagemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * The data needed to update a app_mensagem.
     */
    data: XOR<app_mensagemUpdateInput, app_mensagemUncheckedUpdateInput>
    /**
     * Choose, which app_mensagem to update.
     */
    where: app_mensagemWhereUniqueInput
  }

  /**
   * app_mensagem updateMany
   */
  export type app_mensagemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_mensagems.
     */
    data: XOR<app_mensagemUpdateManyMutationInput, app_mensagemUncheckedUpdateManyInput>
    /**
     * Filter which app_mensagems to update
     */
    where?: app_mensagemWhereInput
  }

  /**
   * app_mensagem upsert
   */
  export type app_mensagemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * The filter to search for the app_mensagem to update in case it exists.
     */
    where: app_mensagemWhereUniqueInput
    /**
     * In case the app_mensagem found by the `where` argument doesn't exist, create a new app_mensagem with this data.
     */
    create: XOR<app_mensagemCreateInput, app_mensagemUncheckedCreateInput>
    /**
     * In case the app_mensagem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_mensagemUpdateInput, app_mensagemUncheckedUpdateInput>
  }

  /**
   * app_mensagem delete
   */
  export type app_mensagemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
    /**
     * Filter which app_mensagem to delete.
     */
    where: app_mensagemWhereUniqueInput
  }

  /**
   * app_mensagem deleteMany
   */
  export type app_mensagemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_mensagems to delete
     */
    where?: app_mensagemWhereInput
  }

  /**
   * app_mensagem.app_conversa
   */
  export type app_mensagem$app_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    where?: app_conversaWhereInput
  }

  /**
   * app_mensagem.app_midia
   */
  export type app_mensagem$app_midiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    where?: app_midiaWhereInput
    orderBy?: app_midiaOrderByWithRelationInput | app_midiaOrderByWithRelationInput[]
    cursor?: app_midiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_midiaScalarFieldEnum | App_midiaScalarFieldEnum[]
  }

  /**
   * app_mensagem.app_receipt
   */
  export type app_mensagem$app_receiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    where?: app_receiptWhereInput
    orderBy?: app_receiptOrderByWithRelationInput | app_receiptOrderByWithRelationInput[]
    cursor?: app_receiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_receiptScalarFieldEnum | App_receiptScalarFieldEnum[]
  }

  /**
   * app_mensagem without action
   */
  export type app_mensagemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem
     */
    select?: app_mensagemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagemInclude<ExtArgs> | null
  }


  /**
   * Model app_mensagem_sugestao
   */

  export type AggregateApp_mensagem_sugestao = {
    _count: App_mensagem_sugestaoCountAggregateOutputType | null
    _avg: App_mensagem_sugestaoAvgAggregateOutputType | null
    _sum: App_mensagem_sugestaoSumAggregateOutputType | null
    _min: App_mensagem_sugestaoMinAggregateOutputType | null
    _max: App_mensagem_sugestaoMaxAggregateOutputType | null
  }

  export type App_mensagem_sugestaoAvgAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_mensagem_sugestaoSumAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_mensagem_sugestaoMinAggregateOutputType = {
    id: number | null
    clinica_id: number | null
    sugestao: string | null
    criado_em: Date | null
  }

  export type App_mensagem_sugestaoMaxAggregateOutputType = {
    id: number | null
    clinica_id: number | null
    sugestao: string | null
    criado_em: Date | null
  }

  export type App_mensagem_sugestaoCountAggregateOutputType = {
    id: number
    clinica_id: number
    sugestao: number
    criado_em: number
    _all: number
  }


  export type App_mensagem_sugestaoAvgAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_mensagem_sugestaoSumAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_mensagem_sugestaoMinAggregateInputType = {
    id?: true
    clinica_id?: true
    sugestao?: true
    criado_em?: true
  }

  export type App_mensagem_sugestaoMaxAggregateInputType = {
    id?: true
    clinica_id?: true
    sugestao?: true
    criado_em?: true
  }

  export type App_mensagem_sugestaoCountAggregateInputType = {
    id?: true
    clinica_id?: true
    sugestao?: true
    criado_em?: true
    _all?: true
  }

  export type App_mensagem_sugestaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_mensagem_sugestao to aggregate.
     */
    where?: app_mensagem_sugestaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagem_sugestaos to fetch.
     */
    orderBy?: app_mensagem_sugestaoOrderByWithRelationInput | app_mensagem_sugestaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_mensagem_sugestaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagem_sugestaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagem_sugestaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_mensagem_sugestaos
    **/
    _count?: true | App_mensagem_sugestaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_mensagem_sugestaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_mensagem_sugestaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_mensagem_sugestaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_mensagem_sugestaoMaxAggregateInputType
  }

  export type GetApp_mensagem_sugestaoAggregateType<T extends App_mensagem_sugestaoAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_mensagem_sugestao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_mensagem_sugestao[P]>
      : GetScalarType<T[P], AggregateApp_mensagem_sugestao[P]>
  }




  export type app_mensagem_sugestaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_mensagem_sugestaoWhereInput
    orderBy?: app_mensagem_sugestaoOrderByWithAggregationInput | app_mensagem_sugestaoOrderByWithAggregationInput[]
    by: App_mensagem_sugestaoScalarFieldEnum[] | App_mensagem_sugestaoScalarFieldEnum
    having?: app_mensagem_sugestaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_mensagem_sugestaoCountAggregateInputType | true
    _avg?: App_mensagem_sugestaoAvgAggregateInputType
    _sum?: App_mensagem_sugestaoSumAggregateInputType
    _min?: App_mensagem_sugestaoMinAggregateInputType
    _max?: App_mensagem_sugestaoMaxAggregateInputType
  }

  export type App_mensagem_sugestaoGroupByOutputType = {
    id: number
    clinica_id: number | null
    sugestao: string
    criado_em: Date | null
    _count: App_mensagem_sugestaoCountAggregateOutputType | null
    _avg: App_mensagem_sugestaoAvgAggregateOutputType | null
    _sum: App_mensagem_sugestaoSumAggregateOutputType | null
    _min: App_mensagem_sugestaoMinAggregateOutputType | null
    _max: App_mensagem_sugestaoMaxAggregateOutputType | null
  }

  type GetApp_mensagem_sugestaoGroupByPayload<T extends app_mensagem_sugestaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_mensagem_sugestaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_mensagem_sugestaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_mensagem_sugestaoGroupByOutputType[P]>
            : GetScalarType<T[P], App_mensagem_sugestaoGroupByOutputType[P]>
        }
      >
    >


  export type app_mensagem_sugestaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinica_id?: boolean
    sugestao?: boolean
    criado_em?: boolean
    app_clinica?: boolean | app_mensagem_sugestao$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_mensagem_sugestao"]>

  export type app_mensagem_sugestaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinica_id?: boolean
    sugestao?: boolean
    criado_em?: boolean
    app_clinica?: boolean | app_mensagem_sugestao$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_mensagem_sugestao"]>

  export type app_mensagem_sugestaoSelectScalar = {
    id?: boolean
    clinica_id?: boolean
    sugestao?: boolean
    criado_em?: boolean
  }

  export type app_mensagem_sugestaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_mensagem_sugestao$app_clinicaArgs<ExtArgs>
  }
  export type app_mensagem_sugestaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_mensagem_sugestao$app_clinicaArgs<ExtArgs>
  }

  export type $app_mensagem_sugestaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_mensagem_sugestao"
    objects: {
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinica_id: number | null
      sugestao: string
      criado_em: Date | null
    }, ExtArgs["result"]["app_mensagem_sugestao"]>
    composites: {}
  }

  type app_mensagem_sugestaoGetPayload<S extends boolean | null | undefined | app_mensagem_sugestaoDefaultArgs> = $Result.GetResult<Prisma.$app_mensagem_sugestaoPayload, S>

  type app_mensagem_sugestaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_mensagem_sugestaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_mensagem_sugestaoCountAggregateInputType | true
    }

  export interface app_mensagem_sugestaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_mensagem_sugestao'], meta: { name: 'app_mensagem_sugestao' } }
    /**
     * Find zero or one App_mensagem_sugestao that matches the filter.
     * @param {app_mensagem_sugestaoFindUniqueArgs} args - Arguments to find a App_mensagem_sugestao
     * @example
     * // Get one App_mensagem_sugestao
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_mensagem_sugestaoFindUniqueArgs>(args: SelectSubset<T, app_mensagem_sugestaoFindUniqueArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_mensagem_sugestao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_mensagem_sugestaoFindUniqueOrThrowArgs} args - Arguments to find a App_mensagem_sugestao
     * @example
     * // Get one App_mensagem_sugestao
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_mensagem_sugestaoFindUniqueOrThrowArgs>(args: SelectSubset<T, app_mensagem_sugestaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_mensagem_sugestao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagem_sugestaoFindFirstArgs} args - Arguments to find a App_mensagem_sugestao
     * @example
     * // Get one App_mensagem_sugestao
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_mensagem_sugestaoFindFirstArgs>(args?: SelectSubset<T, app_mensagem_sugestaoFindFirstArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_mensagem_sugestao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagem_sugestaoFindFirstOrThrowArgs} args - Arguments to find a App_mensagem_sugestao
     * @example
     * // Get one App_mensagem_sugestao
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_mensagem_sugestaoFindFirstOrThrowArgs>(args?: SelectSubset<T, app_mensagem_sugestaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_mensagem_sugestaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagem_sugestaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_mensagem_sugestaos
     * const app_mensagem_sugestaos = await prisma.app_mensagem_sugestao.findMany()
     * 
     * // Get first 10 App_mensagem_sugestaos
     * const app_mensagem_sugestaos = await prisma.app_mensagem_sugestao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_mensagem_sugestaoWithIdOnly = await prisma.app_mensagem_sugestao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_mensagem_sugestaoFindManyArgs>(args?: SelectSubset<T, app_mensagem_sugestaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_mensagem_sugestao.
     * @param {app_mensagem_sugestaoCreateArgs} args - Arguments to create a App_mensagem_sugestao.
     * @example
     * // Create one App_mensagem_sugestao
     * const App_mensagem_sugestao = await prisma.app_mensagem_sugestao.create({
     *   data: {
     *     // ... data to create a App_mensagem_sugestao
     *   }
     * })
     * 
     */
    create<T extends app_mensagem_sugestaoCreateArgs>(args: SelectSubset<T, app_mensagem_sugestaoCreateArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_mensagem_sugestaos.
     * @param {app_mensagem_sugestaoCreateManyArgs} args - Arguments to create many App_mensagem_sugestaos.
     * @example
     * // Create many App_mensagem_sugestaos
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_mensagem_sugestaoCreateManyArgs>(args?: SelectSubset<T, app_mensagem_sugestaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_mensagem_sugestaos and returns the data saved in the database.
     * @param {app_mensagem_sugestaoCreateManyAndReturnArgs} args - Arguments to create many App_mensagem_sugestaos.
     * @example
     * // Create many App_mensagem_sugestaos
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_mensagem_sugestaos and only return the `id`
     * const app_mensagem_sugestaoWithIdOnly = await prisma.app_mensagem_sugestao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_mensagem_sugestaoCreateManyAndReturnArgs>(args?: SelectSubset<T, app_mensagem_sugestaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_mensagem_sugestao.
     * @param {app_mensagem_sugestaoDeleteArgs} args - Arguments to delete one App_mensagem_sugestao.
     * @example
     * // Delete one App_mensagem_sugestao
     * const App_mensagem_sugestao = await prisma.app_mensagem_sugestao.delete({
     *   where: {
     *     // ... filter to delete one App_mensagem_sugestao
     *   }
     * })
     * 
     */
    delete<T extends app_mensagem_sugestaoDeleteArgs>(args: SelectSubset<T, app_mensagem_sugestaoDeleteArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_mensagem_sugestao.
     * @param {app_mensagem_sugestaoUpdateArgs} args - Arguments to update one App_mensagem_sugestao.
     * @example
     * // Update one App_mensagem_sugestao
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_mensagem_sugestaoUpdateArgs>(args: SelectSubset<T, app_mensagem_sugestaoUpdateArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_mensagem_sugestaos.
     * @param {app_mensagem_sugestaoDeleteManyArgs} args - Arguments to filter App_mensagem_sugestaos to delete.
     * @example
     * // Delete a few App_mensagem_sugestaos
     * const { count } = await prisma.app_mensagem_sugestao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_mensagem_sugestaoDeleteManyArgs>(args?: SelectSubset<T, app_mensagem_sugestaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_mensagem_sugestaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagem_sugestaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_mensagem_sugestaos
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_mensagem_sugestaoUpdateManyArgs>(args: SelectSubset<T, app_mensagem_sugestaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_mensagem_sugestao.
     * @param {app_mensagem_sugestaoUpsertArgs} args - Arguments to update or create a App_mensagem_sugestao.
     * @example
     * // Update or create a App_mensagem_sugestao
     * const app_mensagem_sugestao = await prisma.app_mensagem_sugestao.upsert({
     *   create: {
     *     // ... data to create a App_mensagem_sugestao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_mensagem_sugestao we want to update
     *   }
     * })
     */
    upsert<T extends app_mensagem_sugestaoUpsertArgs>(args: SelectSubset<T, app_mensagem_sugestaoUpsertArgs<ExtArgs>>): Prisma__app_mensagem_sugestaoClient<$Result.GetResult<Prisma.$app_mensagem_sugestaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_mensagem_sugestaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagem_sugestaoCountArgs} args - Arguments to filter App_mensagem_sugestaos to count.
     * @example
     * // Count the number of App_mensagem_sugestaos
     * const count = await prisma.app_mensagem_sugestao.count({
     *   where: {
     *     // ... the filter for the App_mensagem_sugestaos we want to count
     *   }
     * })
    **/
    count<T extends app_mensagem_sugestaoCountArgs>(
      args?: Subset<T, app_mensagem_sugestaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_mensagem_sugestaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_mensagem_sugestao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_mensagem_sugestaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_mensagem_sugestaoAggregateArgs>(args: Subset<T, App_mensagem_sugestaoAggregateArgs>): Prisma.PrismaPromise<GetApp_mensagem_sugestaoAggregateType<T>>

    /**
     * Group by App_mensagem_sugestao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_mensagem_sugestaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_mensagem_sugestaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_mensagem_sugestaoGroupByArgs['orderBy'] }
        : { orderBy?: app_mensagem_sugestaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_mensagem_sugestaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_mensagem_sugestaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_mensagem_sugestao model
   */
  readonly fields: app_mensagem_sugestaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_mensagem_sugestao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_mensagem_sugestaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_clinica<T extends app_mensagem_sugestao$app_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_mensagem_sugestao$app_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_mensagem_sugestao model
   */ 
  interface app_mensagem_sugestaoFieldRefs {
    readonly id: FieldRef<"app_mensagem_sugestao", 'Int'>
    readonly clinica_id: FieldRef<"app_mensagem_sugestao", 'Int'>
    readonly sugestao: FieldRef<"app_mensagem_sugestao", 'String'>
    readonly criado_em: FieldRef<"app_mensagem_sugestao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_mensagem_sugestao findUnique
   */
  export type app_mensagem_sugestaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem_sugestao to fetch.
     */
    where: app_mensagem_sugestaoWhereUniqueInput
  }

  /**
   * app_mensagem_sugestao findUniqueOrThrow
   */
  export type app_mensagem_sugestaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem_sugestao to fetch.
     */
    where: app_mensagem_sugestaoWhereUniqueInput
  }

  /**
   * app_mensagem_sugestao findFirst
   */
  export type app_mensagem_sugestaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem_sugestao to fetch.
     */
    where?: app_mensagem_sugestaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagem_sugestaos to fetch.
     */
    orderBy?: app_mensagem_sugestaoOrderByWithRelationInput | app_mensagem_sugestaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_mensagem_sugestaos.
     */
    cursor?: app_mensagem_sugestaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagem_sugestaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagem_sugestaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_mensagem_sugestaos.
     */
    distinct?: App_mensagem_sugestaoScalarFieldEnum | App_mensagem_sugestaoScalarFieldEnum[]
  }

  /**
   * app_mensagem_sugestao findFirstOrThrow
   */
  export type app_mensagem_sugestaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem_sugestao to fetch.
     */
    where?: app_mensagem_sugestaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagem_sugestaos to fetch.
     */
    orderBy?: app_mensagem_sugestaoOrderByWithRelationInput | app_mensagem_sugestaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_mensagem_sugestaos.
     */
    cursor?: app_mensagem_sugestaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagem_sugestaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagem_sugestaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_mensagem_sugestaos.
     */
    distinct?: App_mensagem_sugestaoScalarFieldEnum | App_mensagem_sugestaoScalarFieldEnum[]
  }

  /**
   * app_mensagem_sugestao findMany
   */
  export type app_mensagem_sugestaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * Filter, which app_mensagem_sugestaos to fetch.
     */
    where?: app_mensagem_sugestaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_mensagem_sugestaos to fetch.
     */
    orderBy?: app_mensagem_sugestaoOrderByWithRelationInput | app_mensagem_sugestaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_mensagem_sugestaos.
     */
    cursor?: app_mensagem_sugestaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_mensagem_sugestaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_mensagem_sugestaos.
     */
    skip?: number
    distinct?: App_mensagem_sugestaoScalarFieldEnum | App_mensagem_sugestaoScalarFieldEnum[]
  }

  /**
   * app_mensagem_sugestao create
   */
  export type app_mensagem_sugestaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * The data needed to create a app_mensagem_sugestao.
     */
    data: XOR<app_mensagem_sugestaoCreateInput, app_mensagem_sugestaoUncheckedCreateInput>
  }

  /**
   * app_mensagem_sugestao createMany
   */
  export type app_mensagem_sugestaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_mensagem_sugestaos.
     */
    data: app_mensagem_sugestaoCreateManyInput | app_mensagem_sugestaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_mensagem_sugestao createManyAndReturn
   */
  export type app_mensagem_sugestaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_mensagem_sugestaos.
     */
    data: app_mensagem_sugestaoCreateManyInput | app_mensagem_sugestaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_mensagem_sugestao update
   */
  export type app_mensagem_sugestaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * The data needed to update a app_mensagem_sugestao.
     */
    data: XOR<app_mensagem_sugestaoUpdateInput, app_mensagem_sugestaoUncheckedUpdateInput>
    /**
     * Choose, which app_mensagem_sugestao to update.
     */
    where: app_mensagem_sugestaoWhereUniqueInput
  }

  /**
   * app_mensagem_sugestao updateMany
   */
  export type app_mensagem_sugestaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_mensagem_sugestaos.
     */
    data: XOR<app_mensagem_sugestaoUpdateManyMutationInput, app_mensagem_sugestaoUncheckedUpdateManyInput>
    /**
     * Filter which app_mensagem_sugestaos to update
     */
    where?: app_mensagem_sugestaoWhereInput
  }

  /**
   * app_mensagem_sugestao upsert
   */
  export type app_mensagem_sugestaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * The filter to search for the app_mensagem_sugestao to update in case it exists.
     */
    where: app_mensagem_sugestaoWhereUniqueInput
    /**
     * In case the app_mensagem_sugestao found by the `where` argument doesn't exist, create a new app_mensagem_sugestao with this data.
     */
    create: XOR<app_mensagem_sugestaoCreateInput, app_mensagem_sugestaoUncheckedCreateInput>
    /**
     * In case the app_mensagem_sugestao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_mensagem_sugestaoUpdateInput, app_mensagem_sugestaoUncheckedUpdateInput>
  }

  /**
   * app_mensagem_sugestao delete
   */
  export type app_mensagem_sugestaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
    /**
     * Filter which app_mensagem_sugestao to delete.
     */
    where: app_mensagem_sugestaoWhereUniqueInput
  }

  /**
   * app_mensagem_sugestao deleteMany
   */
  export type app_mensagem_sugestaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_mensagem_sugestaos to delete
     */
    where?: app_mensagem_sugestaoWhereInput
  }

  /**
   * app_mensagem_sugestao.app_clinica
   */
  export type app_mensagem_sugestao$app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_mensagem_sugestao without action
   */
  export type app_mensagem_sugestaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_mensagem_sugestao
     */
    select?: app_mensagem_sugestaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_mensagem_sugestaoInclude<ExtArgs> | null
  }


  /**
   * Model app_midia
   */

  export type AggregateApp_midia = {
    _count: App_midiaCountAggregateOutputType | null
    _avg: App_midiaAvgAggregateOutputType | null
    _sum: App_midiaSumAggregateOutputType | null
    _min: App_midiaMinAggregateOutputType | null
    _max: App_midiaMaxAggregateOutputType | null
  }

  export type App_midiaAvgAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
    duration: number | null
    file_size: number | null
  }

  export type App_midiaSumAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
    duration: number | null
    file_size: bigint | null
  }

  export type App_midiaMinAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
    tipo: string | null
    file_url: string | null
    criado_em: Date | null
    mime_type: string | null
    caption: string | null
    duration: number | null
    file_size: bigint | null
  }

  export type App_midiaMaxAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
    tipo: string | null
    file_url: string | null
    criado_em: Date | null
    mime_type: string | null
    caption: string | null
    duration: number | null
    file_size: bigint | null
  }

  export type App_midiaCountAggregateOutputType = {
    id: number
    mensagem_id: number
    tipo: number
    file_url: number
    criado_em: number
    mime_type: number
    caption: number
    duration: number
    file_size: number
    _all: number
  }


  export type App_midiaAvgAggregateInputType = {
    id?: true
    mensagem_id?: true
    duration?: true
    file_size?: true
  }

  export type App_midiaSumAggregateInputType = {
    id?: true
    mensagem_id?: true
    duration?: true
    file_size?: true
  }

  export type App_midiaMinAggregateInputType = {
    id?: true
    mensagem_id?: true
    tipo?: true
    file_url?: true
    criado_em?: true
    mime_type?: true
    caption?: true
    duration?: true
    file_size?: true
  }

  export type App_midiaMaxAggregateInputType = {
    id?: true
    mensagem_id?: true
    tipo?: true
    file_url?: true
    criado_em?: true
    mime_type?: true
    caption?: true
    duration?: true
    file_size?: true
  }

  export type App_midiaCountAggregateInputType = {
    id?: true
    mensagem_id?: true
    tipo?: true
    file_url?: true
    criado_em?: true
    mime_type?: true
    caption?: true
    duration?: true
    file_size?: true
    _all?: true
  }

  export type App_midiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_midia to aggregate.
     */
    where?: app_midiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_midias to fetch.
     */
    orderBy?: app_midiaOrderByWithRelationInput | app_midiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_midiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_midias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_midias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_midias
    **/
    _count?: true | App_midiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_midiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_midiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_midiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_midiaMaxAggregateInputType
  }

  export type GetApp_midiaAggregateType<T extends App_midiaAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_midia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_midia[P]>
      : GetScalarType<T[P], AggregateApp_midia[P]>
  }




  export type app_midiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_midiaWhereInput
    orderBy?: app_midiaOrderByWithAggregationInput | app_midiaOrderByWithAggregationInput[]
    by: App_midiaScalarFieldEnum[] | App_midiaScalarFieldEnum
    having?: app_midiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_midiaCountAggregateInputType | true
    _avg?: App_midiaAvgAggregateInputType
    _sum?: App_midiaSumAggregateInputType
    _min?: App_midiaMinAggregateInputType
    _max?: App_midiaMaxAggregateInputType
  }

  export type App_midiaGroupByOutputType = {
    id: number
    mensagem_id: number
    tipo: string | null
    file_url: string | null
    criado_em: Date | null
    mime_type: string | null
    caption: string | null
    duration: number | null
    file_size: bigint | null
    _count: App_midiaCountAggregateOutputType | null
    _avg: App_midiaAvgAggregateOutputType | null
    _sum: App_midiaSumAggregateOutputType | null
    _min: App_midiaMinAggregateOutputType | null
    _max: App_midiaMaxAggregateOutputType | null
  }

  type GetApp_midiaGroupByPayload<T extends app_midiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_midiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_midiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_midiaGroupByOutputType[P]>
            : GetScalarType<T[P], App_midiaGroupByOutputType[P]>
        }
      >
    >


  export type app_midiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem_id?: boolean
    tipo?: boolean
    file_url?: boolean
    criado_em?: boolean
    mime_type?: boolean
    caption?: boolean
    duration?: boolean
    file_size?: boolean
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_midia"]>

  export type app_midiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem_id?: boolean
    tipo?: boolean
    file_url?: boolean
    criado_em?: boolean
    mime_type?: boolean
    caption?: boolean
    duration?: boolean
    file_size?: boolean
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_midia"]>

  export type app_midiaSelectScalar = {
    id?: boolean
    mensagem_id?: boolean
    tipo?: boolean
    file_url?: boolean
    criado_em?: boolean
    mime_type?: boolean
    caption?: boolean
    duration?: boolean
    file_size?: boolean
  }

  export type app_midiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }
  export type app_midiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }

  export type $app_midiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_midia"
    objects: {
      app_mensagem: Prisma.$app_mensagemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mensagem_id: number
      tipo: string | null
      file_url: string | null
      criado_em: Date | null
      mime_type: string | null
      caption: string | null
      duration: number | null
      file_size: bigint | null
    }, ExtArgs["result"]["app_midia"]>
    composites: {}
  }

  type app_midiaGetPayload<S extends boolean | null | undefined | app_midiaDefaultArgs> = $Result.GetResult<Prisma.$app_midiaPayload, S>

  type app_midiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_midiaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_midiaCountAggregateInputType | true
    }

  export interface app_midiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_midia'], meta: { name: 'app_midia' } }
    /**
     * Find zero or one App_midia that matches the filter.
     * @param {app_midiaFindUniqueArgs} args - Arguments to find a App_midia
     * @example
     * // Get one App_midia
     * const app_midia = await prisma.app_midia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_midiaFindUniqueArgs>(args: SelectSubset<T, app_midiaFindUniqueArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_midia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_midiaFindUniqueOrThrowArgs} args - Arguments to find a App_midia
     * @example
     * // Get one App_midia
     * const app_midia = await prisma.app_midia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_midiaFindUniqueOrThrowArgs>(args: SelectSubset<T, app_midiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_midia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_midiaFindFirstArgs} args - Arguments to find a App_midia
     * @example
     * // Get one App_midia
     * const app_midia = await prisma.app_midia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_midiaFindFirstArgs>(args?: SelectSubset<T, app_midiaFindFirstArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_midia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_midiaFindFirstOrThrowArgs} args - Arguments to find a App_midia
     * @example
     * // Get one App_midia
     * const app_midia = await prisma.app_midia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_midiaFindFirstOrThrowArgs>(args?: SelectSubset<T, app_midiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_midias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_midiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_midias
     * const app_midias = await prisma.app_midia.findMany()
     * 
     * // Get first 10 App_midias
     * const app_midias = await prisma.app_midia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_midiaWithIdOnly = await prisma.app_midia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_midiaFindManyArgs>(args?: SelectSubset<T, app_midiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_midia.
     * @param {app_midiaCreateArgs} args - Arguments to create a App_midia.
     * @example
     * // Create one App_midia
     * const App_midia = await prisma.app_midia.create({
     *   data: {
     *     // ... data to create a App_midia
     *   }
     * })
     * 
     */
    create<T extends app_midiaCreateArgs>(args: SelectSubset<T, app_midiaCreateArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_midias.
     * @param {app_midiaCreateManyArgs} args - Arguments to create many App_midias.
     * @example
     * // Create many App_midias
     * const app_midia = await prisma.app_midia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_midiaCreateManyArgs>(args?: SelectSubset<T, app_midiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_midias and returns the data saved in the database.
     * @param {app_midiaCreateManyAndReturnArgs} args - Arguments to create many App_midias.
     * @example
     * // Create many App_midias
     * const app_midia = await prisma.app_midia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_midias and only return the `id`
     * const app_midiaWithIdOnly = await prisma.app_midia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_midiaCreateManyAndReturnArgs>(args?: SelectSubset<T, app_midiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_midia.
     * @param {app_midiaDeleteArgs} args - Arguments to delete one App_midia.
     * @example
     * // Delete one App_midia
     * const App_midia = await prisma.app_midia.delete({
     *   where: {
     *     // ... filter to delete one App_midia
     *   }
     * })
     * 
     */
    delete<T extends app_midiaDeleteArgs>(args: SelectSubset<T, app_midiaDeleteArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_midia.
     * @param {app_midiaUpdateArgs} args - Arguments to update one App_midia.
     * @example
     * // Update one App_midia
     * const app_midia = await prisma.app_midia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_midiaUpdateArgs>(args: SelectSubset<T, app_midiaUpdateArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_midias.
     * @param {app_midiaDeleteManyArgs} args - Arguments to filter App_midias to delete.
     * @example
     * // Delete a few App_midias
     * const { count } = await prisma.app_midia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_midiaDeleteManyArgs>(args?: SelectSubset<T, app_midiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_midias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_midiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_midias
     * const app_midia = await prisma.app_midia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_midiaUpdateManyArgs>(args: SelectSubset<T, app_midiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_midia.
     * @param {app_midiaUpsertArgs} args - Arguments to update or create a App_midia.
     * @example
     * // Update or create a App_midia
     * const app_midia = await prisma.app_midia.upsert({
     *   create: {
     *     // ... data to create a App_midia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_midia we want to update
     *   }
     * })
     */
    upsert<T extends app_midiaUpsertArgs>(args: SelectSubset<T, app_midiaUpsertArgs<ExtArgs>>): Prisma__app_midiaClient<$Result.GetResult<Prisma.$app_midiaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_midias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_midiaCountArgs} args - Arguments to filter App_midias to count.
     * @example
     * // Count the number of App_midias
     * const count = await prisma.app_midia.count({
     *   where: {
     *     // ... the filter for the App_midias we want to count
     *   }
     * })
    **/
    count<T extends app_midiaCountArgs>(
      args?: Subset<T, app_midiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_midiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_midia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_midiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_midiaAggregateArgs>(args: Subset<T, App_midiaAggregateArgs>): Prisma.PrismaPromise<GetApp_midiaAggregateType<T>>

    /**
     * Group by App_midia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_midiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_midiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_midiaGroupByArgs['orderBy'] }
        : { orderBy?: app_midiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_midiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_midiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_midia model
   */
  readonly fields: app_midiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_midia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_midiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_mensagem<T extends app_mensagemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_mensagemDefaultArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_midia model
   */ 
  interface app_midiaFieldRefs {
    readonly id: FieldRef<"app_midia", 'Int'>
    readonly mensagem_id: FieldRef<"app_midia", 'Int'>
    readonly tipo: FieldRef<"app_midia", 'String'>
    readonly file_url: FieldRef<"app_midia", 'String'>
    readonly criado_em: FieldRef<"app_midia", 'DateTime'>
    readonly mime_type: FieldRef<"app_midia", 'String'>
    readonly caption: FieldRef<"app_midia", 'String'>
    readonly duration: FieldRef<"app_midia", 'Int'>
    readonly file_size: FieldRef<"app_midia", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * app_midia findUnique
   */
  export type app_midiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * Filter, which app_midia to fetch.
     */
    where: app_midiaWhereUniqueInput
  }

  /**
   * app_midia findUniqueOrThrow
   */
  export type app_midiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * Filter, which app_midia to fetch.
     */
    where: app_midiaWhereUniqueInput
  }

  /**
   * app_midia findFirst
   */
  export type app_midiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * Filter, which app_midia to fetch.
     */
    where?: app_midiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_midias to fetch.
     */
    orderBy?: app_midiaOrderByWithRelationInput | app_midiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_midias.
     */
    cursor?: app_midiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_midias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_midias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_midias.
     */
    distinct?: App_midiaScalarFieldEnum | App_midiaScalarFieldEnum[]
  }

  /**
   * app_midia findFirstOrThrow
   */
  export type app_midiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * Filter, which app_midia to fetch.
     */
    where?: app_midiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_midias to fetch.
     */
    orderBy?: app_midiaOrderByWithRelationInput | app_midiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_midias.
     */
    cursor?: app_midiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_midias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_midias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_midias.
     */
    distinct?: App_midiaScalarFieldEnum | App_midiaScalarFieldEnum[]
  }

  /**
   * app_midia findMany
   */
  export type app_midiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * Filter, which app_midias to fetch.
     */
    where?: app_midiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_midias to fetch.
     */
    orderBy?: app_midiaOrderByWithRelationInput | app_midiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_midias.
     */
    cursor?: app_midiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_midias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_midias.
     */
    skip?: number
    distinct?: App_midiaScalarFieldEnum | App_midiaScalarFieldEnum[]
  }

  /**
   * app_midia create
   */
  export type app_midiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * The data needed to create a app_midia.
     */
    data: XOR<app_midiaCreateInput, app_midiaUncheckedCreateInput>
  }

  /**
   * app_midia createMany
   */
  export type app_midiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_midias.
     */
    data: app_midiaCreateManyInput | app_midiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_midia createManyAndReturn
   */
  export type app_midiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_midias.
     */
    data: app_midiaCreateManyInput | app_midiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_midia update
   */
  export type app_midiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * The data needed to update a app_midia.
     */
    data: XOR<app_midiaUpdateInput, app_midiaUncheckedUpdateInput>
    /**
     * Choose, which app_midia to update.
     */
    where: app_midiaWhereUniqueInput
  }

  /**
   * app_midia updateMany
   */
  export type app_midiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_midias.
     */
    data: XOR<app_midiaUpdateManyMutationInput, app_midiaUncheckedUpdateManyInput>
    /**
     * Filter which app_midias to update
     */
    where?: app_midiaWhereInput
  }

  /**
   * app_midia upsert
   */
  export type app_midiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * The filter to search for the app_midia to update in case it exists.
     */
    where: app_midiaWhereUniqueInput
    /**
     * In case the app_midia found by the `where` argument doesn't exist, create a new app_midia with this data.
     */
    create: XOR<app_midiaCreateInput, app_midiaUncheckedCreateInput>
    /**
     * In case the app_midia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_midiaUpdateInput, app_midiaUncheckedUpdateInput>
  }

  /**
   * app_midia delete
   */
  export type app_midiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
    /**
     * Filter which app_midia to delete.
     */
    where: app_midiaWhereUniqueInput
  }

  /**
   * app_midia deleteMany
   */
  export type app_midiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_midias to delete
     */
    where?: app_midiaWhereInput
  }

  /**
   * app_midia without action
   */
  export type app_midiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_midia
     */
    select?: app_midiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_midiaInclude<ExtArgs> | null
  }


  /**
   * Model app_paciente
   */

  export type AggregateApp_paciente = {
    _count: App_pacienteCountAggregateOutputType | null
    _avg: App_pacienteAvgAggregateOutputType | null
    _sum: App_pacienteSumAggregateOutputType | null
    _min: App_pacienteMinAggregateOutputType | null
    _max: App_pacienteMaxAggregateOutputType | null
  }

  export type App_pacienteAvgAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_pacienteSumAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_pacienteMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    telefone: string | null
    criado_em: Date | null
    atualizado_em: Date | null
    clinica_id: number | null
  }

  export type App_pacienteMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    telefone: string | null
    criado_em: Date | null
    atualizado_em: Date | null
    clinica_id: number | null
  }

  export type App_pacienteCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    telefone: number
    criado_em: number
    atualizado_em: number
    clinica_id: number
    _all: number
  }


  export type App_pacienteAvgAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_pacienteSumAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_pacienteMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    telefone?: true
    criado_em?: true
    atualizado_em?: true
    clinica_id?: true
  }

  export type App_pacienteMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    telefone?: true
    criado_em?: true
    atualizado_em?: true
    clinica_id?: true
  }

  export type App_pacienteCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    telefone?: true
    criado_em?: true
    atualizado_em?: true
    clinica_id?: true
    _all?: true
  }

  export type App_pacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_paciente to aggregate.
     */
    where?: app_pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_pacientes to fetch.
     */
    orderBy?: app_pacienteOrderByWithRelationInput | app_pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_pacientes
    **/
    _count?: true | App_pacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_pacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_pacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_pacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_pacienteMaxAggregateInputType
  }

  export type GetApp_pacienteAggregateType<T extends App_pacienteAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_paciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_paciente[P]>
      : GetScalarType<T[P], AggregateApp_paciente[P]>
  }




  export type app_pacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_pacienteWhereInput
    orderBy?: app_pacienteOrderByWithAggregationInput | app_pacienteOrderByWithAggregationInput[]
    by: App_pacienteScalarFieldEnum[] | App_pacienteScalarFieldEnum
    having?: app_pacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_pacienteCountAggregateInputType | true
    _avg?: App_pacienteAvgAggregateInputType
    _sum?: App_pacienteSumAggregateInputType
    _min?: App_pacienteMinAggregateInputType
    _max?: App_pacienteMaxAggregateInputType
  }

  export type App_pacienteGroupByOutputType = {
    id: number
    nome: string
    email: string | null
    telefone: string
    criado_em: Date | null
    atualizado_em: Date | null
    clinica_id: number | null
    _count: App_pacienteCountAggregateOutputType | null
    _avg: App_pacienteAvgAggregateOutputType | null
    _sum: App_pacienteSumAggregateOutputType | null
    _min: App_pacienteMinAggregateOutputType | null
    _max: App_pacienteMaxAggregateOutputType | null
  }

  type GetApp_pacienteGroupByPayload<T extends app_pacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_pacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_pacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_pacienteGroupByOutputType[P]>
            : GetScalarType<T[P], App_pacienteGroupByOutputType[P]>
        }
      >
    >


  export type app_pacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    criado_em?: boolean
    atualizado_em?: boolean
    clinica_id?: boolean
    app_conversa?: boolean | app_paciente$app_conversaArgs<ExtArgs>
    app_clinica?: boolean | app_paciente$app_clinicaArgs<ExtArgs>
    app_paciente_clinica?: boolean | app_paciente$app_paciente_clinicaArgs<ExtArgs>
    _count?: boolean | App_pacienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_paciente"]>

  export type app_pacienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    criado_em?: boolean
    atualizado_em?: boolean
    clinica_id?: boolean
    app_clinica?: boolean | app_paciente$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_paciente"]>

  export type app_pacienteSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    telefone?: boolean
    criado_em?: boolean
    atualizado_em?: boolean
    clinica_id?: boolean
  }

  export type app_pacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | app_paciente$app_conversaArgs<ExtArgs>
    app_clinica?: boolean | app_paciente$app_clinicaArgs<ExtArgs>
    app_paciente_clinica?: boolean | app_paciente$app_paciente_clinicaArgs<ExtArgs>
    _count?: boolean | App_pacienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type app_pacienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_paciente$app_clinicaArgs<ExtArgs>
  }

  export type $app_pacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_paciente"
    objects: {
      app_conversa: Prisma.$app_conversaPayload<ExtArgs>[]
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
      app_paciente_clinica: Prisma.$app_paciente_clinicaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string | null
      telefone: string
      criado_em: Date | null
      atualizado_em: Date | null
      clinica_id: number | null
    }, ExtArgs["result"]["app_paciente"]>
    composites: {}
  }

  type app_pacienteGetPayload<S extends boolean | null | undefined | app_pacienteDefaultArgs> = $Result.GetResult<Prisma.$app_pacientePayload, S>

  type app_pacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_pacienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_pacienteCountAggregateInputType | true
    }

  export interface app_pacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_paciente'], meta: { name: 'app_paciente' } }
    /**
     * Find zero or one App_paciente that matches the filter.
     * @param {app_pacienteFindUniqueArgs} args - Arguments to find a App_paciente
     * @example
     * // Get one App_paciente
     * const app_paciente = await prisma.app_paciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_pacienteFindUniqueArgs>(args: SelectSubset<T, app_pacienteFindUniqueArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_paciente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_pacienteFindUniqueOrThrowArgs} args - Arguments to find a App_paciente
     * @example
     * // Get one App_paciente
     * const app_paciente = await prisma.app_paciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_pacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, app_pacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_paciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_pacienteFindFirstArgs} args - Arguments to find a App_paciente
     * @example
     * // Get one App_paciente
     * const app_paciente = await prisma.app_paciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_pacienteFindFirstArgs>(args?: SelectSubset<T, app_pacienteFindFirstArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_paciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_pacienteFindFirstOrThrowArgs} args - Arguments to find a App_paciente
     * @example
     * // Get one App_paciente
     * const app_paciente = await prisma.app_paciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_pacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, app_pacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_pacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_pacientes
     * const app_pacientes = await prisma.app_paciente.findMany()
     * 
     * // Get first 10 App_pacientes
     * const app_pacientes = await prisma.app_paciente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_pacienteWithIdOnly = await prisma.app_paciente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_pacienteFindManyArgs>(args?: SelectSubset<T, app_pacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_paciente.
     * @param {app_pacienteCreateArgs} args - Arguments to create a App_paciente.
     * @example
     * // Create one App_paciente
     * const App_paciente = await prisma.app_paciente.create({
     *   data: {
     *     // ... data to create a App_paciente
     *   }
     * })
     * 
     */
    create<T extends app_pacienteCreateArgs>(args: SelectSubset<T, app_pacienteCreateArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_pacientes.
     * @param {app_pacienteCreateManyArgs} args - Arguments to create many App_pacientes.
     * @example
     * // Create many App_pacientes
     * const app_paciente = await prisma.app_paciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_pacienteCreateManyArgs>(args?: SelectSubset<T, app_pacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_pacientes and returns the data saved in the database.
     * @param {app_pacienteCreateManyAndReturnArgs} args - Arguments to create many App_pacientes.
     * @example
     * // Create many App_pacientes
     * const app_paciente = await prisma.app_paciente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_pacientes and only return the `id`
     * const app_pacienteWithIdOnly = await prisma.app_paciente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_pacienteCreateManyAndReturnArgs>(args?: SelectSubset<T, app_pacienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_paciente.
     * @param {app_pacienteDeleteArgs} args - Arguments to delete one App_paciente.
     * @example
     * // Delete one App_paciente
     * const App_paciente = await prisma.app_paciente.delete({
     *   where: {
     *     // ... filter to delete one App_paciente
     *   }
     * })
     * 
     */
    delete<T extends app_pacienteDeleteArgs>(args: SelectSubset<T, app_pacienteDeleteArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_paciente.
     * @param {app_pacienteUpdateArgs} args - Arguments to update one App_paciente.
     * @example
     * // Update one App_paciente
     * const app_paciente = await prisma.app_paciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_pacienteUpdateArgs>(args: SelectSubset<T, app_pacienteUpdateArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_pacientes.
     * @param {app_pacienteDeleteManyArgs} args - Arguments to filter App_pacientes to delete.
     * @example
     * // Delete a few App_pacientes
     * const { count } = await prisma.app_paciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_pacienteDeleteManyArgs>(args?: SelectSubset<T, app_pacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_pacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_pacientes
     * const app_paciente = await prisma.app_paciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_pacienteUpdateManyArgs>(args: SelectSubset<T, app_pacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_paciente.
     * @param {app_pacienteUpsertArgs} args - Arguments to update or create a App_paciente.
     * @example
     * // Update or create a App_paciente
     * const app_paciente = await prisma.app_paciente.upsert({
     *   create: {
     *     // ... data to create a App_paciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_paciente we want to update
     *   }
     * })
     */
    upsert<T extends app_pacienteUpsertArgs>(args: SelectSubset<T, app_pacienteUpsertArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_pacienteCountArgs} args - Arguments to filter App_pacientes to count.
     * @example
     * // Count the number of App_pacientes
     * const count = await prisma.app_paciente.count({
     *   where: {
     *     // ... the filter for the App_pacientes we want to count
     *   }
     * })
    **/
    count<T extends app_pacienteCountArgs>(
      args?: Subset<T, app_pacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_pacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_pacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_pacienteAggregateArgs>(args: Subset<T, App_pacienteAggregateArgs>): Prisma.PrismaPromise<GetApp_pacienteAggregateType<T>>

    /**
     * Group by App_paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_pacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_pacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_pacienteGroupByArgs['orderBy'] }
        : { orderBy?: app_pacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_pacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_pacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_paciente model
   */
  readonly fields: app_pacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_paciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_pacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_conversa<T extends app_paciente$app_conversaArgs<ExtArgs> = {}>(args?: Subset<T, app_paciente$app_conversaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findMany"> | Null>
    app_clinica<T extends app_paciente$app_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_paciente$app_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    app_paciente_clinica<T extends app_paciente$app_paciente_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_paciente$app_paciente_clinicaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_paciente model
   */ 
  interface app_pacienteFieldRefs {
    readonly id: FieldRef<"app_paciente", 'Int'>
    readonly nome: FieldRef<"app_paciente", 'String'>
    readonly email: FieldRef<"app_paciente", 'String'>
    readonly telefone: FieldRef<"app_paciente", 'String'>
    readonly criado_em: FieldRef<"app_paciente", 'DateTime'>
    readonly atualizado_em: FieldRef<"app_paciente", 'DateTime'>
    readonly clinica_id: FieldRef<"app_paciente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * app_paciente findUnique
   */
  export type app_pacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente to fetch.
     */
    where: app_pacienteWhereUniqueInput
  }

  /**
   * app_paciente findUniqueOrThrow
   */
  export type app_pacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente to fetch.
     */
    where: app_pacienteWhereUniqueInput
  }

  /**
   * app_paciente findFirst
   */
  export type app_pacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente to fetch.
     */
    where?: app_pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_pacientes to fetch.
     */
    orderBy?: app_pacienteOrderByWithRelationInput | app_pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_pacientes.
     */
    cursor?: app_pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_pacientes.
     */
    distinct?: App_pacienteScalarFieldEnum | App_pacienteScalarFieldEnum[]
  }

  /**
   * app_paciente findFirstOrThrow
   */
  export type app_pacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente to fetch.
     */
    where?: app_pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_pacientes to fetch.
     */
    orderBy?: app_pacienteOrderByWithRelationInput | app_pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_pacientes.
     */
    cursor?: app_pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_pacientes.
     */
    distinct?: App_pacienteScalarFieldEnum | App_pacienteScalarFieldEnum[]
  }

  /**
   * app_paciente findMany
   */
  export type app_pacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * Filter, which app_pacientes to fetch.
     */
    where?: app_pacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_pacientes to fetch.
     */
    orderBy?: app_pacienteOrderByWithRelationInput | app_pacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_pacientes.
     */
    cursor?: app_pacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_pacientes.
     */
    skip?: number
    distinct?: App_pacienteScalarFieldEnum | App_pacienteScalarFieldEnum[]
  }

  /**
   * app_paciente create
   */
  export type app_pacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a app_paciente.
     */
    data: XOR<app_pacienteCreateInput, app_pacienteUncheckedCreateInput>
  }

  /**
   * app_paciente createMany
   */
  export type app_pacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_pacientes.
     */
    data: app_pacienteCreateManyInput | app_pacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_paciente createManyAndReturn
   */
  export type app_pacienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_pacientes.
     */
    data: app_pacienteCreateManyInput | app_pacienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_paciente update
   */
  export type app_pacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a app_paciente.
     */
    data: XOR<app_pacienteUpdateInput, app_pacienteUncheckedUpdateInput>
    /**
     * Choose, which app_paciente to update.
     */
    where: app_pacienteWhereUniqueInput
  }

  /**
   * app_paciente updateMany
   */
  export type app_pacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_pacientes.
     */
    data: XOR<app_pacienteUpdateManyMutationInput, app_pacienteUncheckedUpdateManyInput>
    /**
     * Filter which app_pacientes to update
     */
    where?: app_pacienteWhereInput
  }

  /**
   * app_paciente upsert
   */
  export type app_pacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the app_paciente to update in case it exists.
     */
    where: app_pacienteWhereUniqueInput
    /**
     * In case the app_paciente found by the `where` argument doesn't exist, create a new app_paciente with this data.
     */
    create: XOR<app_pacienteCreateInput, app_pacienteUncheckedCreateInput>
    /**
     * In case the app_paciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_pacienteUpdateInput, app_pacienteUncheckedUpdateInput>
  }

  /**
   * app_paciente delete
   */
  export type app_pacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
    /**
     * Filter which app_paciente to delete.
     */
    where: app_pacienteWhereUniqueInput
  }

  /**
   * app_paciente deleteMany
   */
  export type app_pacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_pacientes to delete
     */
    where?: app_pacienteWhereInput
  }

  /**
   * app_paciente.app_conversa
   */
  export type app_paciente$app_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    where?: app_conversaWhereInput
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    cursor?: app_conversaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_conversaScalarFieldEnum | App_conversaScalarFieldEnum[]
  }

  /**
   * app_paciente.app_clinica
   */
  export type app_paciente$app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_paciente.app_paciente_clinica
   */
  export type app_paciente$app_paciente_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    where?: app_paciente_clinicaWhereInput
    orderBy?: app_paciente_clinicaOrderByWithRelationInput | app_paciente_clinicaOrderByWithRelationInput[]
    cursor?: app_paciente_clinicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_paciente_clinicaScalarFieldEnum | App_paciente_clinicaScalarFieldEnum[]
  }

  /**
   * app_paciente without action
   */
  export type app_pacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente
     */
    select?: app_pacienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_pacienteInclude<ExtArgs> | null
  }


  /**
   * Model app_paciente_clinica
   */

  export type AggregateApp_paciente_clinica = {
    _count: App_paciente_clinicaCountAggregateOutputType | null
    _avg: App_paciente_clinicaAvgAggregateOutputType | null
    _sum: App_paciente_clinicaSumAggregateOutputType | null
    _min: App_paciente_clinicaMinAggregateOutputType | null
    _max: App_paciente_clinicaMaxAggregateOutputType | null
  }

  export type App_paciente_clinicaAvgAggregateOutputType = {
    paciente_id: number | null
    clinica_id: number | null
  }

  export type App_paciente_clinicaSumAggregateOutputType = {
    paciente_id: number | null
    clinica_id: number | null
  }

  export type App_paciente_clinicaMinAggregateOutputType = {
    paciente_id: number | null
    clinica_id: number | null
  }

  export type App_paciente_clinicaMaxAggregateOutputType = {
    paciente_id: number | null
    clinica_id: number | null
  }

  export type App_paciente_clinicaCountAggregateOutputType = {
    paciente_id: number
    clinica_id: number
    _all: number
  }


  export type App_paciente_clinicaAvgAggregateInputType = {
    paciente_id?: true
    clinica_id?: true
  }

  export type App_paciente_clinicaSumAggregateInputType = {
    paciente_id?: true
    clinica_id?: true
  }

  export type App_paciente_clinicaMinAggregateInputType = {
    paciente_id?: true
    clinica_id?: true
  }

  export type App_paciente_clinicaMaxAggregateInputType = {
    paciente_id?: true
    clinica_id?: true
  }

  export type App_paciente_clinicaCountAggregateInputType = {
    paciente_id?: true
    clinica_id?: true
    _all?: true
  }

  export type App_paciente_clinicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_paciente_clinica to aggregate.
     */
    where?: app_paciente_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_paciente_clinicas to fetch.
     */
    orderBy?: app_paciente_clinicaOrderByWithRelationInput | app_paciente_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_paciente_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_paciente_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_paciente_clinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_paciente_clinicas
    **/
    _count?: true | App_paciente_clinicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_paciente_clinicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_paciente_clinicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_paciente_clinicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_paciente_clinicaMaxAggregateInputType
  }

  export type GetApp_paciente_clinicaAggregateType<T extends App_paciente_clinicaAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_paciente_clinica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_paciente_clinica[P]>
      : GetScalarType<T[P], AggregateApp_paciente_clinica[P]>
  }




  export type app_paciente_clinicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_paciente_clinicaWhereInput
    orderBy?: app_paciente_clinicaOrderByWithAggregationInput | app_paciente_clinicaOrderByWithAggregationInput[]
    by: App_paciente_clinicaScalarFieldEnum[] | App_paciente_clinicaScalarFieldEnum
    having?: app_paciente_clinicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_paciente_clinicaCountAggregateInputType | true
    _avg?: App_paciente_clinicaAvgAggregateInputType
    _sum?: App_paciente_clinicaSumAggregateInputType
    _min?: App_paciente_clinicaMinAggregateInputType
    _max?: App_paciente_clinicaMaxAggregateInputType
  }

  export type App_paciente_clinicaGroupByOutputType = {
    paciente_id: number
    clinica_id: number
    _count: App_paciente_clinicaCountAggregateOutputType | null
    _avg: App_paciente_clinicaAvgAggregateOutputType | null
    _sum: App_paciente_clinicaSumAggregateOutputType | null
    _min: App_paciente_clinicaMinAggregateOutputType | null
    _max: App_paciente_clinicaMaxAggregateOutputType | null
  }

  type GetApp_paciente_clinicaGroupByPayload<T extends app_paciente_clinicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_paciente_clinicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_paciente_clinicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_paciente_clinicaGroupByOutputType[P]>
            : GetScalarType<T[P], App_paciente_clinicaGroupByOutputType[P]>
        }
      >
    >


  export type app_paciente_clinicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paciente_id?: boolean
    clinica_id?: boolean
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
    app_paciente?: boolean | app_pacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_paciente_clinica"]>

  export type app_paciente_clinicaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paciente_id?: boolean
    clinica_id?: boolean
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
    app_paciente?: boolean | app_pacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_paciente_clinica"]>

  export type app_paciente_clinicaSelectScalar = {
    paciente_id?: boolean
    clinica_id?: boolean
  }

  export type app_paciente_clinicaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
    app_paciente?: boolean | app_pacienteDefaultArgs<ExtArgs>
  }
  export type app_paciente_clinicaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
    app_paciente?: boolean | app_pacienteDefaultArgs<ExtArgs>
  }

  export type $app_paciente_clinicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_paciente_clinica"
    objects: {
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs>
      app_paciente: Prisma.$app_pacientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      paciente_id: number
      clinica_id: number
    }, ExtArgs["result"]["app_paciente_clinica"]>
    composites: {}
  }

  type app_paciente_clinicaGetPayload<S extends boolean | null | undefined | app_paciente_clinicaDefaultArgs> = $Result.GetResult<Prisma.$app_paciente_clinicaPayload, S>

  type app_paciente_clinicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_paciente_clinicaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_paciente_clinicaCountAggregateInputType | true
    }

  export interface app_paciente_clinicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_paciente_clinica'], meta: { name: 'app_paciente_clinica' } }
    /**
     * Find zero or one App_paciente_clinica that matches the filter.
     * @param {app_paciente_clinicaFindUniqueArgs} args - Arguments to find a App_paciente_clinica
     * @example
     * // Get one App_paciente_clinica
     * const app_paciente_clinica = await prisma.app_paciente_clinica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_paciente_clinicaFindUniqueArgs>(args: SelectSubset<T, app_paciente_clinicaFindUniqueArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_paciente_clinica that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_paciente_clinicaFindUniqueOrThrowArgs} args - Arguments to find a App_paciente_clinica
     * @example
     * // Get one App_paciente_clinica
     * const app_paciente_clinica = await prisma.app_paciente_clinica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_paciente_clinicaFindUniqueOrThrowArgs>(args: SelectSubset<T, app_paciente_clinicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_paciente_clinica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_paciente_clinicaFindFirstArgs} args - Arguments to find a App_paciente_clinica
     * @example
     * // Get one App_paciente_clinica
     * const app_paciente_clinica = await prisma.app_paciente_clinica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_paciente_clinicaFindFirstArgs>(args?: SelectSubset<T, app_paciente_clinicaFindFirstArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_paciente_clinica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_paciente_clinicaFindFirstOrThrowArgs} args - Arguments to find a App_paciente_clinica
     * @example
     * // Get one App_paciente_clinica
     * const app_paciente_clinica = await prisma.app_paciente_clinica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_paciente_clinicaFindFirstOrThrowArgs>(args?: SelectSubset<T, app_paciente_clinicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_paciente_clinicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_paciente_clinicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_paciente_clinicas
     * const app_paciente_clinicas = await prisma.app_paciente_clinica.findMany()
     * 
     * // Get first 10 App_paciente_clinicas
     * const app_paciente_clinicas = await prisma.app_paciente_clinica.findMany({ take: 10 })
     * 
     * // Only select the `paciente_id`
     * const app_paciente_clinicaWithPaciente_idOnly = await prisma.app_paciente_clinica.findMany({ select: { paciente_id: true } })
     * 
     */
    findMany<T extends app_paciente_clinicaFindManyArgs>(args?: SelectSubset<T, app_paciente_clinicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_paciente_clinica.
     * @param {app_paciente_clinicaCreateArgs} args - Arguments to create a App_paciente_clinica.
     * @example
     * // Create one App_paciente_clinica
     * const App_paciente_clinica = await prisma.app_paciente_clinica.create({
     *   data: {
     *     // ... data to create a App_paciente_clinica
     *   }
     * })
     * 
     */
    create<T extends app_paciente_clinicaCreateArgs>(args: SelectSubset<T, app_paciente_clinicaCreateArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_paciente_clinicas.
     * @param {app_paciente_clinicaCreateManyArgs} args - Arguments to create many App_paciente_clinicas.
     * @example
     * // Create many App_paciente_clinicas
     * const app_paciente_clinica = await prisma.app_paciente_clinica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_paciente_clinicaCreateManyArgs>(args?: SelectSubset<T, app_paciente_clinicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_paciente_clinicas and returns the data saved in the database.
     * @param {app_paciente_clinicaCreateManyAndReturnArgs} args - Arguments to create many App_paciente_clinicas.
     * @example
     * // Create many App_paciente_clinicas
     * const app_paciente_clinica = await prisma.app_paciente_clinica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_paciente_clinicas and only return the `paciente_id`
     * const app_paciente_clinicaWithPaciente_idOnly = await prisma.app_paciente_clinica.createManyAndReturn({ 
     *   select: { paciente_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_paciente_clinicaCreateManyAndReturnArgs>(args?: SelectSubset<T, app_paciente_clinicaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_paciente_clinica.
     * @param {app_paciente_clinicaDeleteArgs} args - Arguments to delete one App_paciente_clinica.
     * @example
     * // Delete one App_paciente_clinica
     * const App_paciente_clinica = await prisma.app_paciente_clinica.delete({
     *   where: {
     *     // ... filter to delete one App_paciente_clinica
     *   }
     * })
     * 
     */
    delete<T extends app_paciente_clinicaDeleteArgs>(args: SelectSubset<T, app_paciente_clinicaDeleteArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_paciente_clinica.
     * @param {app_paciente_clinicaUpdateArgs} args - Arguments to update one App_paciente_clinica.
     * @example
     * // Update one App_paciente_clinica
     * const app_paciente_clinica = await prisma.app_paciente_clinica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_paciente_clinicaUpdateArgs>(args: SelectSubset<T, app_paciente_clinicaUpdateArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_paciente_clinicas.
     * @param {app_paciente_clinicaDeleteManyArgs} args - Arguments to filter App_paciente_clinicas to delete.
     * @example
     * // Delete a few App_paciente_clinicas
     * const { count } = await prisma.app_paciente_clinica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_paciente_clinicaDeleteManyArgs>(args?: SelectSubset<T, app_paciente_clinicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_paciente_clinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_paciente_clinicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_paciente_clinicas
     * const app_paciente_clinica = await prisma.app_paciente_clinica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_paciente_clinicaUpdateManyArgs>(args: SelectSubset<T, app_paciente_clinicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_paciente_clinica.
     * @param {app_paciente_clinicaUpsertArgs} args - Arguments to update or create a App_paciente_clinica.
     * @example
     * // Update or create a App_paciente_clinica
     * const app_paciente_clinica = await prisma.app_paciente_clinica.upsert({
     *   create: {
     *     // ... data to create a App_paciente_clinica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_paciente_clinica we want to update
     *   }
     * })
     */
    upsert<T extends app_paciente_clinicaUpsertArgs>(args: SelectSubset<T, app_paciente_clinicaUpsertArgs<ExtArgs>>): Prisma__app_paciente_clinicaClient<$Result.GetResult<Prisma.$app_paciente_clinicaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_paciente_clinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_paciente_clinicaCountArgs} args - Arguments to filter App_paciente_clinicas to count.
     * @example
     * // Count the number of App_paciente_clinicas
     * const count = await prisma.app_paciente_clinica.count({
     *   where: {
     *     // ... the filter for the App_paciente_clinicas we want to count
     *   }
     * })
    **/
    count<T extends app_paciente_clinicaCountArgs>(
      args?: Subset<T, app_paciente_clinicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_paciente_clinicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_paciente_clinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_paciente_clinicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_paciente_clinicaAggregateArgs>(args: Subset<T, App_paciente_clinicaAggregateArgs>): Prisma.PrismaPromise<GetApp_paciente_clinicaAggregateType<T>>

    /**
     * Group by App_paciente_clinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_paciente_clinicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_paciente_clinicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_paciente_clinicaGroupByArgs['orderBy'] }
        : { orderBy?: app_paciente_clinicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_paciente_clinicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_paciente_clinicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_paciente_clinica model
   */
  readonly fields: app_paciente_clinicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_paciente_clinica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_paciente_clinicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_clinica<T extends app_clinicaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_clinicaDefaultArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    app_paciente<T extends app_pacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_pacienteDefaultArgs<ExtArgs>>): Prisma__app_pacienteClient<$Result.GetResult<Prisma.$app_pacientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_paciente_clinica model
   */ 
  interface app_paciente_clinicaFieldRefs {
    readonly paciente_id: FieldRef<"app_paciente_clinica", 'Int'>
    readonly clinica_id: FieldRef<"app_paciente_clinica", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * app_paciente_clinica findUnique
   */
  export type app_paciente_clinicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente_clinica to fetch.
     */
    where: app_paciente_clinicaWhereUniqueInput
  }

  /**
   * app_paciente_clinica findUniqueOrThrow
   */
  export type app_paciente_clinicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente_clinica to fetch.
     */
    where: app_paciente_clinicaWhereUniqueInput
  }

  /**
   * app_paciente_clinica findFirst
   */
  export type app_paciente_clinicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente_clinica to fetch.
     */
    where?: app_paciente_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_paciente_clinicas to fetch.
     */
    orderBy?: app_paciente_clinicaOrderByWithRelationInput | app_paciente_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_paciente_clinicas.
     */
    cursor?: app_paciente_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_paciente_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_paciente_clinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_paciente_clinicas.
     */
    distinct?: App_paciente_clinicaScalarFieldEnum | App_paciente_clinicaScalarFieldEnum[]
  }

  /**
   * app_paciente_clinica findFirstOrThrow
   */
  export type app_paciente_clinicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente_clinica to fetch.
     */
    where?: app_paciente_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_paciente_clinicas to fetch.
     */
    orderBy?: app_paciente_clinicaOrderByWithRelationInput | app_paciente_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_paciente_clinicas.
     */
    cursor?: app_paciente_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_paciente_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_paciente_clinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_paciente_clinicas.
     */
    distinct?: App_paciente_clinicaScalarFieldEnum | App_paciente_clinicaScalarFieldEnum[]
  }

  /**
   * app_paciente_clinica findMany
   */
  export type app_paciente_clinicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * Filter, which app_paciente_clinicas to fetch.
     */
    where?: app_paciente_clinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_paciente_clinicas to fetch.
     */
    orderBy?: app_paciente_clinicaOrderByWithRelationInput | app_paciente_clinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_paciente_clinicas.
     */
    cursor?: app_paciente_clinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_paciente_clinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_paciente_clinicas.
     */
    skip?: number
    distinct?: App_paciente_clinicaScalarFieldEnum | App_paciente_clinicaScalarFieldEnum[]
  }

  /**
   * app_paciente_clinica create
   */
  export type app_paciente_clinicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * The data needed to create a app_paciente_clinica.
     */
    data: XOR<app_paciente_clinicaCreateInput, app_paciente_clinicaUncheckedCreateInput>
  }

  /**
   * app_paciente_clinica createMany
   */
  export type app_paciente_clinicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_paciente_clinicas.
     */
    data: app_paciente_clinicaCreateManyInput | app_paciente_clinicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_paciente_clinica createManyAndReturn
   */
  export type app_paciente_clinicaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_paciente_clinicas.
     */
    data: app_paciente_clinicaCreateManyInput | app_paciente_clinicaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_paciente_clinica update
   */
  export type app_paciente_clinicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * The data needed to update a app_paciente_clinica.
     */
    data: XOR<app_paciente_clinicaUpdateInput, app_paciente_clinicaUncheckedUpdateInput>
    /**
     * Choose, which app_paciente_clinica to update.
     */
    where: app_paciente_clinicaWhereUniqueInput
  }

  /**
   * app_paciente_clinica updateMany
   */
  export type app_paciente_clinicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_paciente_clinicas.
     */
    data: XOR<app_paciente_clinicaUpdateManyMutationInput, app_paciente_clinicaUncheckedUpdateManyInput>
    /**
     * Filter which app_paciente_clinicas to update
     */
    where?: app_paciente_clinicaWhereInput
  }

  /**
   * app_paciente_clinica upsert
   */
  export type app_paciente_clinicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * The filter to search for the app_paciente_clinica to update in case it exists.
     */
    where: app_paciente_clinicaWhereUniqueInput
    /**
     * In case the app_paciente_clinica found by the `where` argument doesn't exist, create a new app_paciente_clinica with this data.
     */
    create: XOR<app_paciente_clinicaCreateInput, app_paciente_clinicaUncheckedCreateInput>
    /**
     * In case the app_paciente_clinica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_paciente_clinicaUpdateInput, app_paciente_clinicaUncheckedUpdateInput>
  }

  /**
   * app_paciente_clinica delete
   */
  export type app_paciente_clinicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
    /**
     * Filter which app_paciente_clinica to delete.
     */
    where: app_paciente_clinicaWhereUniqueInput
  }

  /**
   * app_paciente_clinica deleteMany
   */
  export type app_paciente_clinicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_paciente_clinicas to delete
     */
    where?: app_paciente_clinicaWhereInput
  }

  /**
   * app_paciente_clinica without action
   */
  export type app_paciente_clinicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_paciente_clinica
     */
    select?: app_paciente_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_paciente_clinicaInclude<ExtArgs> | null
  }


  /**
   * Model app_resposta_pronta
   */

  export type AggregateApp_resposta_pronta = {
    _count: App_resposta_prontaCountAggregateOutputType | null
    _avg: App_resposta_prontaAvgAggregateOutputType | null
    _sum: App_resposta_prontaSumAggregateOutputType | null
    _min: App_resposta_prontaMinAggregateOutputType | null
    _max: App_resposta_prontaMaxAggregateOutputType | null
  }

  export type App_resposta_prontaAvgAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_resposta_prontaSumAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_resposta_prontaMinAggregateOutputType = {
    id: number | null
    clinica_id: number | null
    titulo: string | null
    conteudo: string | null
    criada_em: Date | null
  }

  export type App_resposta_prontaMaxAggregateOutputType = {
    id: number | null
    clinica_id: number | null
    titulo: string | null
    conteudo: string | null
    criada_em: Date | null
  }

  export type App_resposta_prontaCountAggregateOutputType = {
    id: number
    clinica_id: number
    titulo: number
    conteudo: number
    criada_em: number
    _all: number
  }


  export type App_resposta_prontaAvgAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_resposta_prontaSumAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_resposta_prontaMinAggregateInputType = {
    id?: true
    clinica_id?: true
    titulo?: true
    conteudo?: true
    criada_em?: true
  }

  export type App_resposta_prontaMaxAggregateInputType = {
    id?: true
    clinica_id?: true
    titulo?: true
    conteudo?: true
    criada_em?: true
  }

  export type App_resposta_prontaCountAggregateInputType = {
    id?: true
    clinica_id?: true
    titulo?: true
    conteudo?: true
    criada_em?: true
    _all?: true
  }

  export type App_resposta_prontaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_resposta_pronta to aggregate.
     */
    where?: app_resposta_prontaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_resposta_prontas to fetch.
     */
    orderBy?: app_resposta_prontaOrderByWithRelationInput | app_resposta_prontaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_resposta_prontaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_resposta_prontas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_resposta_prontas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_resposta_prontas
    **/
    _count?: true | App_resposta_prontaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_resposta_prontaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_resposta_prontaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_resposta_prontaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_resposta_prontaMaxAggregateInputType
  }

  export type GetApp_resposta_prontaAggregateType<T extends App_resposta_prontaAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_resposta_pronta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_resposta_pronta[P]>
      : GetScalarType<T[P], AggregateApp_resposta_pronta[P]>
  }




  export type app_resposta_prontaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_resposta_prontaWhereInput
    orderBy?: app_resposta_prontaOrderByWithAggregationInput | app_resposta_prontaOrderByWithAggregationInput[]
    by: App_resposta_prontaScalarFieldEnum[] | App_resposta_prontaScalarFieldEnum
    having?: app_resposta_prontaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_resposta_prontaCountAggregateInputType | true
    _avg?: App_resposta_prontaAvgAggregateInputType
    _sum?: App_resposta_prontaSumAggregateInputType
    _min?: App_resposta_prontaMinAggregateInputType
    _max?: App_resposta_prontaMaxAggregateInputType
  }

  export type App_resposta_prontaGroupByOutputType = {
    id: number
    clinica_id: number | null
    titulo: string | null
    conteudo: string | null
    criada_em: Date | null
    _count: App_resposta_prontaCountAggregateOutputType | null
    _avg: App_resposta_prontaAvgAggregateOutputType | null
    _sum: App_resposta_prontaSumAggregateOutputType | null
    _min: App_resposta_prontaMinAggregateOutputType | null
    _max: App_resposta_prontaMaxAggregateOutputType | null
  }

  type GetApp_resposta_prontaGroupByPayload<T extends app_resposta_prontaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_resposta_prontaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_resposta_prontaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_resposta_prontaGroupByOutputType[P]>
            : GetScalarType<T[P], App_resposta_prontaGroupByOutputType[P]>
        }
      >
    >


  export type app_resposta_prontaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinica_id?: boolean
    titulo?: boolean
    conteudo?: boolean
    criada_em?: boolean
    app_clinica?: boolean | app_resposta_pronta$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_resposta_pronta"]>

  export type app_resposta_prontaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinica_id?: boolean
    titulo?: boolean
    conteudo?: boolean
    criada_em?: boolean
    app_clinica?: boolean | app_resposta_pronta$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_resposta_pronta"]>

  export type app_resposta_prontaSelectScalar = {
    id?: boolean
    clinica_id?: boolean
    titulo?: boolean
    conteudo?: boolean
    criada_em?: boolean
  }

  export type app_resposta_prontaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_resposta_pronta$app_clinicaArgs<ExtArgs>
  }
  export type app_resposta_prontaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_resposta_pronta$app_clinicaArgs<ExtArgs>
  }

  export type $app_resposta_prontaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_resposta_pronta"
    objects: {
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinica_id: number | null
      titulo: string | null
      conteudo: string | null
      criada_em: Date | null
    }, ExtArgs["result"]["app_resposta_pronta"]>
    composites: {}
  }

  type app_resposta_prontaGetPayload<S extends boolean | null | undefined | app_resposta_prontaDefaultArgs> = $Result.GetResult<Prisma.$app_resposta_prontaPayload, S>

  type app_resposta_prontaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_resposta_prontaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_resposta_prontaCountAggregateInputType | true
    }

  export interface app_resposta_prontaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_resposta_pronta'], meta: { name: 'app_resposta_pronta' } }
    /**
     * Find zero or one App_resposta_pronta that matches the filter.
     * @param {app_resposta_prontaFindUniqueArgs} args - Arguments to find a App_resposta_pronta
     * @example
     * // Get one App_resposta_pronta
     * const app_resposta_pronta = await prisma.app_resposta_pronta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_resposta_prontaFindUniqueArgs>(args: SelectSubset<T, app_resposta_prontaFindUniqueArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_resposta_pronta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_resposta_prontaFindUniqueOrThrowArgs} args - Arguments to find a App_resposta_pronta
     * @example
     * // Get one App_resposta_pronta
     * const app_resposta_pronta = await prisma.app_resposta_pronta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_resposta_prontaFindUniqueOrThrowArgs>(args: SelectSubset<T, app_resposta_prontaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_resposta_pronta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_resposta_prontaFindFirstArgs} args - Arguments to find a App_resposta_pronta
     * @example
     * // Get one App_resposta_pronta
     * const app_resposta_pronta = await prisma.app_resposta_pronta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_resposta_prontaFindFirstArgs>(args?: SelectSubset<T, app_resposta_prontaFindFirstArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_resposta_pronta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_resposta_prontaFindFirstOrThrowArgs} args - Arguments to find a App_resposta_pronta
     * @example
     * // Get one App_resposta_pronta
     * const app_resposta_pronta = await prisma.app_resposta_pronta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_resposta_prontaFindFirstOrThrowArgs>(args?: SelectSubset<T, app_resposta_prontaFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_resposta_prontas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_resposta_prontaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_resposta_prontas
     * const app_resposta_prontas = await prisma.app_resposta_pronta.findMany()
     * 
     * // Get first 10 App_resposta_prontas
     * const app_resposta_prontas = await prisma.app_resposta_pronta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_resposta_prontaWithIdOnly = await prisma.app_resposta_pronta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_resposta_prontaFindManyArgs>(args?: SelectSubset<T, app_resposta_prontaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_resposta_pronta.
     * @param {app_resposta_prontaCreateArgs} args - Arguments to create a App_resposta_pronta.
     * @example
     * // Create one App_resposta_pronta
     * const App_resposta_pronta = await prisma.app_resposta_pronta.create({
     *   data: {
     *     // ... data to create a App_resposta_pronta
     *   }
     * })
     * 
     */
    create<T extends app_resposta_prontaCreateArgs>(args: SelectSubset<T, app_resposta_prontaCreateArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_resposta_prontas.
     * @param {app_resposta_prontaCreateManyArgs} args - Arguments to create many App_resposta_prontas.
     * @example
     * // Create many App_resposta_prontas
     * const app_resposta_pronta = await prisma.app_resposta_pronta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_resposta_prontaCreateManyArgs>(args?: SelectSubset<T, app_resposta_prontaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_resposta_prontas and returns the data saved in the database.
     * @param {app_resposta_prontaCreateManyAndReturnArgs} args - Arguments to create many App_resposta_prontas.
     * @example
     * // Create many App_resposta_prontas
     * const app_resposta_pronta = await prisma.app_resposta_pronta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_resposta_prontas and only return the `id`
     * const app_resposta_prontaWithIdOnly = await prisma.app_resposta_pronta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_resposta_prontaCreateManyAndReturnArgs>(args?: SelectSubset<T, app_resposta_prontaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_resposta_pronta.
     * @param {app_resposta_prontaDeleteArgs} args - Arguments to delete one App_resposta_pronta.
     * @example
     * // Delete one App_resposta_pronta
     * const App_resposta_pronta = await prisma.app_resposta_pronta.delete({
     *   where: {
     *     // ... filter to delete one App_resposta_pronta
     *   }
     * })
     * 
     */
    delete<T extends app_resposta_prontaDeleteArgs>(args: SelectSubset<T, app_resposta_prontaDeleteArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_resposta_pronta.
     * @param {app_resposta_prontaUpdateArgs} args - Arguments to update one App_resposta_pronta.
     * @example
     * // Update one App_resposta_pronta
     * const app_resposta_pronta = await prisma.app_resposta_pronta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_resposta_prontaUpdateArgs>(args: SelectSubset<T, app_resposta_prontaUpdateArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_resposta_prontas.
     * @param {app_resposta_prontaDeleteManyArgs} args - Arguments to filter App_resposta_prontas to delete.
     * @example
     * // Delete a few App_resposta_prontas
     * const { count } = await prisma.app_resposta_pronta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_resposta_prontaDeleteManyArgs>(args?: SelectSubset<T, app_resposta_prontaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_resposta_prontas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_resposta_prontaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_resposta_prontas
     * const app_resposta_pronta = await prisma.app_resposta_pronta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_resposta_prontaUpdateManyArgs>(args: SelectSubset<T, app_resposta_prontaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_resposta_pronta.
     * @param {app_resposta_prontaUpsertArgs} args - Arguments to update or create a App_resposta_pronta.
     * @example
     * // Update or create a App_resposta_pronta
     * const app_resposta_pronta = await prisma.app_resposta_pronta.upsert({
     *   create: {
     *     // ... data to create a App_resposta_pronta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_resposta_pronta we want to update
     *   }
     * })
     */
    upsert<T extends app_resposta_prontaUpsertArgs>(args: SelectSubset<T, app_resposta_prontaUpsertArgs<ExtArgs>>): Prisma__app_resposta_prontaClient<$Result.GetResult<Prisma.$app_resposta_prontaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_resposta_prontas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_resposta_prontaCountArgs} args - Arguments to filter App_resposta_prontas to count.
     * @example
     * // Count the number of App_resposta_prontas
     * const count = await prisma.app_resposta_pronta.count({
     *   where: {
     *     // ... the filter for the App_resposta_prontas we want to count
     *   }
     * })
    **/
    count<T extends app_resposta_prontaCountArgs>(
      args?: Subset<T, app_resposta_prontaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_resposta_prontaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_resposta_pronta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_resposta_prontaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_resposta_prontaAggregateArgs>(args: Subset<T, App_resposta_prontaAggregateArgs>): Prisma.PrismaPromise<GetApp_resposta_prontaAggregateType<T>>

    /**
     * Group by App_resposta_pronta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_resposta_prontaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_resposta_prontaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_resposta_prontaGroupByArgs['orderBy'] }
        : { orderBy?: app_resposta_prontaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_resposta_prontaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_resposta_prontaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_resposta_pronta model
   */
  readonly fields: app_resposta_prontaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_resposta_pronta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_resposta_prontaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_clinica<T extends app_resposta_pronta$app_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_resposta_pronta$app_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_resposta_pronta model
   */ 
  interface app_resposta_prontaFieldRefs {
    readonly id: FieldRef<"app_resposta_pronta", 'Int'>
    readonly clinica_id: FieldRef<"app_resposta_pronta", 'Int'>
    readonly titulo: FieldRef<"app_resposta_pronta", 'String'>
    readonly conteudo: FieldRef<"app_resposta_pronta", 'String'>
    readonly criada_em: FieldRef<"app_resposta_pronta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_resposta_pronta findUnique
   */
  export type app_resposta_prontaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * Filter, which app_resposta_pronta to fetch.
     */
    where: app_resposta_prontaWhereUniqueInput
  }

  /**
   * app_resposta_pronta findUniqueOrThrow
   */
  export type app_resposta_prontaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * Filter, which app_resposta_pronta to fetch.
     */
    where: app_resposta_prontaWhereUniqueInput
  }

  /**
   * app_resposta_pronta findFirst
   */
  export type app_resposta_prontaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * Filter, which app_resposta_pronta to fetch.
     */
    where?: app_resposta_prontaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_resposta_prontas to fetch.
     */
    orderBy?: app_resposta_prontaOrderByWithRelationInput | app_resposta_prontaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_resposta_prontas.
     */
    cursor?: app_resposta_prontaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_resposta_prontas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_resposta_prontas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_resposta_prontas.
     */
    distinct?: App_resposta_prontaScalarFieldEnum | App_resposta_prontaScalarFieldEnum[]
  }

  /**
   * app_resposta_pronta findFirstOrThrow
   */
  export type app_resposta_prontaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * Filter, which app_resposta_pronta to fetch.
     */
    where?: app_resposta_prontaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_resposta_prontas to fetch.
     */
    orderBy?: app_resposta_prontaOrderByWithRelationInput | app_resposta_prontaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_resposta_prontas.
     */
    cursor?: app_resposta_prontaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_resposta_prontas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_resposta_prontas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_resposta_prontas.
     */
    distinct?: App_resposta_prontaScalarFieldEnum | App_resposta_prontaScalarFieldEnum[]
  }

  /**
   * app_resposta_pronta findMany
   */
  export type app_resposta_prontaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * Filter, which app_resposta_prontas to fetch.
     */
    where?: app_resposta_prontaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_resposta_prontas to fetch.
     */
    orderBy?: app_resposta_prontaOrderByWithRelationInput | app_resposta_prontaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_resposta_prontas.
     */
    cursor?: app_resposta_prontaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_resposta_prontas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_resposta_prontas.
     */
    skip?: number
    distinct?: App_resposta_prontaScalarFieldEnum | App_resposta_prontaScalarFieldEnum[]
  }

  /**
   * app_resposta_pronta create
   */
  export type app_resposta_prontaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * The data needed to create a app_resposta_pronta.
     */
    data?: XOR<app_resposta_prontaCreateInput, app_resposta_prontaUncheckedCreateInput>
  }

  /**
   * app_resposta_pronta createMany
   */
  export type app_resposta_prontaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_resposta_prontas.
     */
    data: app_resposta_prontaCreateManyInput | app_resposta_prontaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_resposta_pronta createManyAndReturn
   */
  export type app_resposta_prontaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_resposta_prontas.
     */
    data: app_resposta_prontaCreateManyInput | app_resposta_prontaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_resposta_pronta update
   */
  export type app_resposta_prontaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * The data needed to update a app_resposta_pronta.
     */
    data: XOR<app_resposta_prontaUpdateInput, app_resposta_prontaUncheckedUpdateInput>
    /**
     * Choose, which app_resposta_pronta to update.
     */
    where: app_resposta_prontaWhereUniqueInput
  }

  /**
   * app_resposta_pronta updateMany
   */
  export type app_resposta_prontaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_resposta_prontas.
     */
    data: XOR<app_resposta_prontaUpdateManyMutationInput, app_resposta_prontaUncheckedUpdateManyInput>
    /**
     * Filter which app_resposta_prontas to update
     */
    where?: app_resposta_prontaWhereInput
  }

  /**
   * app_resposta_pronta upsert
   */
  export type app_resposta_prontaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * The filter to search for the app_resposta_pronta to update in case it exists.
     */
    where: app_resposta_prontaWhereUniqueInput
    /**
     * In case the app_resposta_pronta found by the `where` argument doesn't exist, create a new app_resposta_pronta with this data.
     */
    create: XOR<app_resposta_prontaCreateInput, app_resposta_prontaUncheckedCreateInput>
    /**
     * In case the app_resposta_pronta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_resposta_prontaUpdateInput, app_resposta_prontaUncheckedUpdateInput>
  }

  /**
   * app_resposta_pronta delete
   */
  export type app_resposta_prontaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
    /**
     * Filter which app_resposta_pronta to delete.
     */
    where: app_resposta_prontaWhereUniqueInput
  }

  /**
   * app_resposta_pronta deleteMany
   */
  export type app_resposta_prontaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_resposta_prontas to delete
     */
    where?: app_resposta_prontaWhereInput
  }

  /**
   * app_resposta_pronta.app_clinica
   */
  export type app_resposta_pronta$app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_resposta_pronta without action
   */
  export type app_resposta_prontaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_resposta_pronta
     */
    select?: app_resposta_prontaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_resposta_prontaInclude<ExtArgs> | null
  }


  /**
   * Model app_tag
   */

  export type AggregateApp_tag = {
    _count: App_tagCountAggregateOutputType | null
    _avg: App_tagAvgAggregateOutputType | null
    _sum: App_tagSumAggregateOutputType | null
    _min: App_tagMinAggregateOutputType | null
    _max: App_tagMaxAggregateOutputType | null
  }

  export type App_tagAvgAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_tagSumAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_tagMinAggregateOutputType = {
    id: number | null
    nome: string | null
    clinica_id: number | null
    criada_em: Date | null
  }

  export type App_tagMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    clinica_id: number | null
    criada_em: Date | null
  }

  export type App_tagCountAggregateOutputType = {
    id: number
    nome: number
    clinica_id: number
    criada_em: number
    _all: number
  }


  export type App_tagAvgAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_tagSumAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_tagMinAggregateInputType = {
    id?: true
    nome?: true
    clinica_id?: true
    criada_em?: true
  }

  export type App_tagMaxAggregateInputType = {
    id?: true
    nome?: true
    clinica_id?: true
    criada_em?: true
  }

  export type App_tagCountAggregateInputType = {
    id?: true
    nome?: true
    clinica_id?: true
    criada_em?: true
    _all?: true
  }

  export type App_tagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_tag to aggregate.
     */
    where?: app_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_tags to fetch.
     */
    orderBy?: app_tagOrderByWithRelationInput | app_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_tags
    **/
    _count?: true | App_tagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_tagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_tagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_tagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_tagMaxAggregateInputType
  }

  export type GetApp_tagAggregateType<T extends App_tagAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_tag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_tag[P]>
      : GetScalarType<T[P], AggregateApp_tag[P]>
  }




  export type app_tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_tagWhereInput
    orderBy?: app_tagOrderByWithAggregationInput | app_tagOrderByWithAggregationInput[]
    by: App_tagScalarFieldEnum[] | App_tagScalarFieldEnum
    having?: app_tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_tagCountAggregateInputType | true
    _avg?: App_tagAvgAggregateInputType
    _sum?: App_tagSumAggregateInputType
    _min?: App_tagMinAggregateInputType
    _max?: App_tagMaxAggregateInputType
  }

  export type App_tagGroupByOutputType = {
    id: number
    nome: string | null
    clinica_id: number | null
    criada_em: Date | null
    _count: App_tagCountAggregateOutputType | null
    _avg: App_tagAvgAggregateOutputType | null
    _sum: App_tagSumAggregateOutputType | null
    _min: App_tagMinAggregateOutputType | null
    _max: App_tagMaxAggregateOutputType | null
  }

  type GetApp_tagGroupByPayload<T extends app_tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_tagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_tagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_tagGroupByOutputType[P]>
            : GetScalarType<T[P], App_tagGroupByOutputType[P]>
        }
      >
    >


  export type app_tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    clinica_id?: boolean
    criada_em?: boolean
    app_clinica?: boolean | app_tag$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_tag"]>

  export type app_tagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    clinica_id?: boolean
    criada_em?: boolean
    app_clinica?: boolean | app_tag$app_clinicaArgs<ExtArgs>
  }, ExtArgs["result"]["app_tag"]>

  export type app_tagSelectScalar = {
    id?: boolean
    nome?: boolean
    clinica_id?: boolean
    criada_em?: boolean
  }

  export type app_tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_tag$app_clinicaArgs<ExtArgs>
  }
  export type app_tagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_tag$app_clinicaArgs<ExtArgs>
  }

  export type $app_tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_tag"
    objects: {
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string | null
      clinica_id: number | null
      criada_em: Date | null
    }, ExtArgs["result"]["app_tag"]>
    composites: {}
  }

  type app_tagGetPayload<S extends boolean | null | undefined | app_tagDefaultArgs> = $Result.GetResult<Prisma.$app_tagPayload, S>

  type app_tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_tagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_tagCountAggregateInputType | true
    }

  export interface app_tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_tag'], meta: { name: 'app_tag' } }
    /**
     * Find zero or one App_tag that matches the filter.
     * @param {app_tagFindUniqueArgs} args - Arguments to find a App_tag
     * @example
     * // Get one App_tag
     * const app_tag = await prisma.app_tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_tagFindUniqueArgs>(args: SelectSubset<T, app_tagFindUniqueArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_tagFindUniqueOrThrowArgs} args - Arguments to find a App_tag
     * @example
     * // Get one App_tag
     * const app_tag = await prisma.app_tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_tagFindUniqueOrThrowArgs>(args: SelectSubset<T, app_tagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_tagFindFirstArgs} args - Arguments to find a App_tag
     * @example
     * // Get one App_tag
     * const app_tag = await prisma.app_tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_tagFindFirstArgs>(args?: SelectSubset<T, app_tagFindFirstArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_tagFindFirstOrThrowArgs} args - Arguments to find a App_tag
     * @example
     * // Get one App_tag
     * const app_tag = await prisma.app_tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_tagFindFirstOrThrowArgs>(args?: SelectSubset<T, app_tagFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_tagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_tags
     * const app_tags = await prisma.app_tag.findMany()
     * 
     * // Get first 10 App_tags
     * const app_tags = await prisma.app_tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_tagWithIdOnly = await prisma.app_tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_tagFindManyArgs>(args?: SelectSubset<T, app_tagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_tag.
     * @param {app_tagCreateArgs} args - Arguments to create a App_tag.
     * @example
     * // Create one App_tag
     * const App_tag = await prisma.app_tag.create({
     *   data: {
     *     // ... data to create a App_tag
     *   }
     * })
     * 
     */
    create<T extends app_tagCreateArgs>(args: SelectSubset<T, app_tagCreateArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_tags.
     * @param {app_tagCreateManyArgs} args - Arguments to create many App_tags.
     * @example
     * // Create many App_tags
     * const app_tag = await prisma.app_tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_tagCreateManyArgs>(args?: SelectSubset<T, app_tagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_tags and returns the data saved in the database.
     * @param {app_tagCreateManyAndReturnArgs} args - Arguments to create many App_tags.
     * @example
     * // Create many App_tags
     * const app_tag = await prisma.app_tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_tags and only return the `id`
     * const app_tagWithIdOnly = await prisma.app_tag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_tagCreateManyAndReturnArgs>(args?: SelectSubset<T, app_tagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_tag.
     * @param {app_tagDeleteArgs} args - Arguments to delete one App_tag.
     * @example
     * // Delete one App_tag
     * const App_tag = await prisma.app_tag.delete({
     *   where: {
     *     // ... filter to delete one App_tag
     *   }
     * })
     * 
     */
    delete<T extends app_tagDeleteArgs>(args: SelectSubset<T, app_tagDeleteArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_tag.
     * @param {app_tagUpdateArgs} args - Arguments to update one App_tag.
     * @example
     * // Update one App_tag
     * const app_tag = await prisma.app_tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_tagUpdateArgs>(args: SelectSubset<T, app_tagUpdateArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_tags.
     * @param {app_tagDeleteManyArgs} args - Arguments to filter App_tags to delete.
     * @example
     * // Delete a few App_tags
     * const { count } = await prisma.app_tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_tagDeleteManyArgs>(args?: SelectSubset<T, app_tagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_tags
     * const app_tag = await prisma.app_tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_tagUpdateManyArgs>(args: SelectSubset<T, app_tagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_tag.
     * @param {app_tagUpsertArgs} args - Arguments to update or create a App_tag.
     * @example
     * // Update or create a App_tag
     * const app_tag = await prisma.app_tag.upsert({
     *   create: {
     *     // ... data to create a App_tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_tag we want to update
     *   }
     * })
     */
    upsert<T extends app_tagUpsertArgs>(args: SelectSubset<T, app_tagUpsertArgs<ExtArgs>>): Prisma__app_tagClient<$Result.GetResult<Prisma.$app_tagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_tagCountArgs} args - Arguments to filter App_tags to count.
     * @example
     * // Count the number of App_tags
     * const count = await prisma.app_tag.count({
     *   where: {
     *     // ... the filter for the App_tags we want to count
     *   }
     * })
    **/
    count<T extends app_tagCountArgs>(
      args?: Subset<T, app_tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_tagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_tagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_tagAggregateArgs>(args: Subset<T, App_tagAggregateArgs>): Prisma.PrismaPromise<GetApp_tagAggregateType<T>>

    /**
     * Group by App_tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_tagGroupByArgs['orderBy'] }
        : { orderBy?: app_tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_tagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_tag model
   */
  readonly fields: app_tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_clinica<T extends app_tag$app_clinicaArgs<ExtArgs> = {}>(args?: Subset<T, app_tag$app_clinicaArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_tag model
   */ 
  interface app_tagFieldRefs {
    readonly id: FieldRef<"app_tag", 'Int'>
    readonly nome: FieldRef<"app_tag", 'String'>
    readonly clinica_id: FieldRef<"app_tag", 'Int'>
    readonly criada_em: FieldRef<"app_tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_tag findUnique
   */
  export type app_tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * Filter, which app_tag to fetch.
     */
    where: app_tagWhereUniqueInput
  }

  /**
   * app_tag findUniqueOrThrow
   */
  export type app_tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * Filter, which app_tag to fetch.
     */
    where: app_tagWhereUniqueInput
  }

  /**
   * app_tag findFirst
   */
  export type app_tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * Filter, which app_tag to fetch.
     */
    where?: app_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_tags to fetch.
     */
    orderBy?: app_tagOrderByWithRelationInput | app_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_tags.
     */
    cursor?: app_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_tags.
     */
    distinct?: App_tagScalarFieldEnum | App_tagScalarFieldEnum[]
  }

  /**
   * app_tag findFirstOrThrow
   */
  export type app_tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * Filter, which app_tag to fetch.
     */
    where?: app_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_tags to fetch.
     */
    orderBy?: app_tagOrderByWithRelationInput | app_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_tags.
     */
    cursor?: app_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_tags.
     */
    distinct?: App_tagScalarFieldEnum | App_tagScalarFieldEnum[]
  }

  /**
   * app_tag findMany
   */
  export type app_tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * Filter, which app_tags to fetch.
     */
    where?: app_tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_tags to fetch.
     */
    orderBy?: app_tagOrderByWithRelationInput | app_tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_tags.
     */
    cursor?: app_tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_tags.
     */
    skip?: number
    distinct?: App_tagScalarFieldEnum | App_tagScalarFieldEnum[]
  }

  /**
   * app_tag create
   */
  export type app_tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * The data needed to create a app_tag.
     */
    data?: XOR<app_tagCreateInput, app_tagUncheckedCreateInput>
  }

  /**
   * app_tag createMany
   */
  export type app_tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_tags.
     */
    data: app_tagCreateManyInput | app_tagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_tag createManyAndReturn
   */
  export type app_tagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_tags.
     */
    data: app_tagCreateManyInput | app_tagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_tag update
   */
  export type app_tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * The data needed to update a app_tag.
     */
    data: XOR<app_tagUpdateInput, app_tagUncheckedUpdateInput>
    /**
     * Choose, which app_tag to update.
     */
    where: app_tagWhereUniqueInput
  }

  /**
   * app_tag updateMany
   */
  export type app_tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_tags.
     */
    data: XOR<app_tagUpdateManyMutationInput, app_tagUncheckedUpdateManyInput>
    /**
     * Filter which app_tags to update
     */
    where?: app_tagWhereInput
  }

  /**
   * app_tag upsert
   */
  export type app_tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * The filter to search for the app_tag to update in case it exists.
     */
    where: app_tagWhereUniqueInput
    /**
     * In case the app_tag found by the `where` argument doesn't exist, create a new app_tag with this data.
     */
    create: XOR<app_tagCreateInput, app_tagUncheckedCreateInput>
    /**
     * In case the app_tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_tagUpdateInput, app_tagUncheckedUpdateInput>
  }

  /**
   * app_tag delete
   */
  export type app_tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
    /**
     * Filter which app_tag to delete.
     */
    where: app_tagWhereUniqueInput
  }

  /**
   * app_tag deleteMany
   */
  export type app_tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_tags to delete
     */
    where?: app_tagWhereInput
  }

  /**
   * app_tag.app_clinica
   */
  export type app_tag$app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_clinica
     */
    select?: app_clinicaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_clinicaInclude<ExtArgs> | null
    where?: app_clinicaWhereInput
  }

  /**
   * app_tag without action
   */
  export type app_tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_tag
     */
    select?: app_tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_tagInclude<ExtArgs> | null
  }


  /**
   * Model consultas
   */

  export type AggregateConsultas = {
    _count: ConsultasCountAggregateOutputType | null
    _avg: ConsultasAvgAggregateOutputType | null
    _sum: ConsultasSumAggregateOutputType | null
    _min: ConsultasMinAggregateOutputType | null
    _max: ConsultasMaxAggregateOutputType | null
  }

  export type ConsultasAvgAggregateOutputType = {
    id: number | null
    medico_id: number | null
  }

  export type ConsultasSumAggregateOutputType = {
    id: number | null
    medico_id: number | null
  }

  export type ConsultasMinAggregateOutputType = {
    id: number | null
    medico_id: number | null
    data_hora: Date | null
    tipo: string | null
    status: string | null
    paciente_id: string | null
  }

  export type ConsultasMaxAggregateOutputType = {
    id: number | null
    medico_id: number | null
    data_hora: Date | null
    tipo: string | null
    status: string | null
    paciente_id: string | null
  }

  export type ConsultasCountAggregateOutputType = {
    id: number
    medico_id: number
    data_hora: number
    tipo: number
    status: number
    paciente_id: number
    _all: number
  }


  export type ConsultasAvgAggregateInputType = {
    id?: true
    medico_id?: true
  }

  export type ConsultasSumAggregateInputType = {
    id?: true
    medico_id?: true
  }

  export type ConsultasMinAggregateInputType = {
    id?: true
    medico_id?: true
    data_hora?: true
    tipo?: true
    status?: true
    paciente_id?: true
  }

  export type ConsultasMaxAggregateInputType = {
    id?: true
    medico_id?: true
    data_hora?: true
    tipo?: true
    status?: true
    paciente_id?: true
  }

  export type ConsultasCountAggregateInputType = {
    id?: true
    medico_id?: true
    data_hora?: true
    tipo?: true
    status?: true
    paciente_id?: true
    _all?: true
  }

  export type ConsultasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultas to aggregate.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consultas
    **/
    _count?: true | ConsultasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultasMaxAggregateInputType
  }

  export type GetConsultasAggregateType<T extends ConsultasAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultas[P]>
      : GetScalarType<T[P], AggregateConsultas[P]>
  }




  export type consultasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultasWhereInput
    orderBy?: consultasOrderByWithAggregationInput | consultasOrderByWithAggregationInput[]
    by: ConsultasScalarFieldEnum[] | ConsultasScalarFieldEnum
    having?: consultasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultasCountAggregateInputType | true
    _avg?: ConsultasAvgAggregateInputType
    _sum?: ConsultasSumAggregateInputType
    _min?: ConsultasMinAggregateInputType
    _max?: ConsultasMaxAggregateInputType
  }

  export type ConsultasGroupByOutputType = {
    id: number
    medico_id: number | null
    data_hora: Date
    tipo: string
    status: string
    paciente_id: string | null
    _count: ConsultasCountAggregateOutputType | null
    _avg: ConsultasAvgAggregateOutputType | null
    _sum: ConsultasSumAggregateOutputType | null
    _min: ConsultasMinAggregateOutputType | null
    _max: ConsultasMaxAggregateOutputType | null
  }

  type GetConsultasGroupByPayload<T extends consultasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultasGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultasGroupByOutputType[P]>
        }
      >
    >


  export type consultasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medico_id?: boolean
    data_hora?: boolean
    tipo?: boolean
    status?: boolean
    paciente_id?: boolean
    medicos?: boolean | consultas$medicosArgs<ExtArgs>
    pacientes?: boolean | consultas$pacientesArgs<ExtArgs>
  }, ExtArgs["result"]["consultas"]>

  export type consultasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medico_id?: boolean
    data_hora?: boolean
    tipo?: boolean
    status?: boolean
    paciente_id?: boolean
    medicos?: boolean | consultas$medicosArgs<ExtArgs>
    pacientes?: boolean | consultas$pacientesArgs<ExtArgs>
  }, ExtArgs["result"]["consultas"]>

  export type consultasSelectScalar = {
    id?: boolean
    medico_id?: boolean
    data_hora?: boolean
    tipo?: boolean
    status?: boolean
    paciente_id?: boolean
  }

  export type consultasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | consultas$medicosArgs<ExtArgs>
    pacientes?: boolean | consultas$pacientesArgs<ExtArgs>
  }
  export type consultasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | consultas$medicosArgs<ExtArgs>
    pacientes?: boolean | consultas$pacientesArgs<ExtArgs>
  }

  export type $consultasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consultas"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs> | null
      pacientes: Prisma.$pacientesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medico_id: number | null
      data_hora: Date
      tipo: string
      status: string
      paciente_id: string | null
    }, ExtArgs["result"]["consultas"]>
    composites: {}
  }

  type consultasGetPayload<S extends boolean | null | undefined | consultasDefaultArgs> = $Result.GetResult<Prisma.$consultasPayload, S>

  type consultasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<consultasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultasCountAggregateInputType | true
    }

  export interface consultasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consultas'], meta: { name: 'consultas' } }
    /**
     * Find zero or one Consultas that matches the filter.
     * @param {consultasFindUniqueArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consultasFindUniqueArgs>(args: SelectSubset<T, consultasFindUniqueArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Consultas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {consultasFindUniqueOrThrowArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consultasFindUniqueOrThrowArgs>(args: SelectSubset<T, consultasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasFindFirstArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consultasFindFirstArgs>(args?: SelectSubset<T, consultasFindFirstArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Consultas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasFindFirstOrThrowArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consultasFindFirstOrThrowArgs>(args?: SelectSubset<T, consultasFindFirstOrThrowArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultas
     * const consultas = await prisma.consultas.findMany()
     * 
     * // Get first 10 Consultas
     * const consultas = await prisma.consultas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultasWithIdOnly = await prisma.consultas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consultasFindManyArgs>(args?: SelectSubset<T, consultasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Consultas.
     * @param {consultasCreateArgs} args - Arguments to create a Consultas.
     * @example
     * // Create one Consultas
     * const Consultas = await prisma.consultas.create({
     *   data: {
     *     // ... data to create a Consultas
     *   }
     * })
     * 
     */
    create<T extends consultasCreateArgs>(args: SelectSubset<T, consultasCreateArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Consultas.
     * @param {consultasCreateManyArgs} args - Arguments to create many Consultas.
     * @example
     * // Create many Consultas
     * const consultas = await prisma.consultas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consultasCreateManyArgs>(args?: SelectSubset<T, consultasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consultas and returns the data saved in the database.
     * @param {consultasCreateManyAndReturnArgs} args - Arguments to create many Consultas.
     * @example
     * // Create many Consultas
     * const consultas = await prisma.consultas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consultas and only return the `id`
     * const consultasWithIdOnly = await prisma.consultas.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consultasCreateManyAndReturnArgs>(args?: SelectSubset<T, consultasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Consultas.
     * @param {consultasDeleteArgs} args - Arguments to delete one Consultas.
     * @example
     * // Delete one Consultas
     * const Consultas = await prisma.consultas.delete({
     *   where: {
     *     // ... filter to delete one Consultas
     *   }
     * })
     * 
     */
    delete<T extends consultasDeleteArgs>(args: SelectSubset<T, consultasDeleteArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Consultas.
     * @param {consultasUpdateArgs} args - Arguments to update one Consultas.
     * @example
     * // Update one Consultas
     * const consultas = await prisma.consultas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consultasUpdateArgs>(args: SelectSubset<T, consultasUpdateArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Consultas.
     * @param {consultasDeleteManyArgs} args - Arguments to filter Consultas to delete.
     * @example
     * // Delete a few Consultas
     * const { count } = await prisma.consultas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consultasDeleteManyArgs>(args?: SelectSubset<T, consultasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultas
     * const consultas = await prisma.consultas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consultasUpdateManyArgs>(args: SelectSubset<T, consultasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultas.
     * @param {consultasUpsertArgs} args - Arguments to update or create a Consultas.
     * @example
     * // Update or create a Consultas
     * const consultas = await prisma.consultas.upsert({
     *   create: {
     *     // ... data to create a Consultas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultas we want to update
     *   }
     * })
     */
    upsert<T extends consultasUpsertArgs>(args: SelectSubset<T, consultasUpsertArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasCountArgs} args - Arguments to filter Consultas to count.
     * @example
     * // Count the number of Consultas
     * const count = await prisma.consultas.count({
     *   where: {
     *     // ... the filter for the Consultas we want to count
     *   }
     * })
    **/
    count<T extends consultasCountArgs>(
      args?: Subset<T, consultasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultasAggregateArgs>(args: Subset<T, ConsultasAggregateArgs>): Prisma.PrismaPromise<GetConsultasAggregateType<T>>

    /**
     * Group by Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consultasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consultasGroupByArgs['orderBy'] }
        : { orderBy?: consultasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consultasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consultas model
   */
  readonly fields: consultasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consultas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consultasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends consultas$medicosArgs<ExtArgs> = {}>(args?: Subset<T, consultas$medicosArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pacientes<T extends consultas$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, consultas$pacientesArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consultas model
   */ 
  interface consultasFieldRefs {
    readonly id: FieldRef<"consultas", 'Int'>
    readonly medico_id: FieldRef<"consultas", 'Int'>
    readonly data_hora: FieldRef<"consultas", 'DateTime'>
    readonly tipo: FieldRef<"consultas", 'String'>
    readonly status: FieldRef<"consultas", 'String'>
    readonly paciente_id: FieldRef<"consultas", 'String'>
  }
    

  // Custom InputTypes
  /**
   * consultas findUnique
   */
  export type consultasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas findUniqueOrThrow
   */
  export type consultasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas findFirst
   */
  export type consultasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultas.
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultas.
     */
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * consultas findFirstOrThrow
   */
  export type consultasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultas.
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultas.
     */
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * consultas findMany
   */
  export type consultasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consultas.
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * consultas create
   */
  export type consultasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * The data needed to create a consultas.
     */
    data: XOR<consultasCreateInput, consultasUncheckedCreateInput>
  }

  /**
   * consultas createMany
   */
  export type consultasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consultas.
     */
    data: consultasCreateManyInput | consultasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consultas createManyAndReturn
   */
  export type consultasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many consultas.
     */
    data: consultasCreateManyInput | consultasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * consultas update
   */
  export type consultasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * The data needed to update a consultas.
     */
    data: XOR<consultasUpdateInput, consultasUncheckedUpdateInput>
    /**
     * Choose, which consultas to update.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas updateMany
   */
  export type consultasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consultas.
     */
    data: XOR<consultasUpdateManyMutationInput, consultasUncheckedUpdateManyInput>
    /**
     * Filter which consultas to update
     */
    where?: consultasWhereInput
  }

  /**
   * consultas upsert
   */
  export type consultasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * The filter to search for the consultas to update in case it exists.
     */
    where: consultasWhereUniqueInput
    /**
     * In case the consultas found by the `where` argument doesn't exist, create a new consultas with this data.
     */
    create: XOR<consultasCreateInput, consultasUncheckedCreateInput>
    /**
     * In case the consultas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consultasUpdateInput, consultasUncheckedUpdateInput>
  }

  /**
   * consultas delete
   */
  export type consultasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    /**
     * Filter which consultas to delete.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas deleteMany
   */
  export type consultasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultas to delete
     */
    where?: consultasWhereInput
  }

  /**
   * consultas.medicos
   */
  export type consultas$medicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    where?: medicosWhereInput
  }

  /**
   * consultas.pacientes
   */
  export type consultas$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    where?: pacientesWhereInput
  }

  /**
   * consultas without action
   */
  export type consultasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
  }


  /**
   * Model conversations
   */

  export type AggregateConversations = {
    _count: ConversationsCountAggregateOutputType | null
    _avg: ConversationsAvgAggregateOutputType | null
    _sum: ConversationsSumAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  export type ConversationsAvgAggregateOutputType = {
    id: number | null
  }

  export type ConversationsSumAggregateOutputType = {
    id: number | null
  }

  export type ConversationsMinAggregateOutputType = {
    id: number | null
    telefone_user: string | null
    created_at: Date | null
  }

  export type ConversationsMaxAggregateOutputType = {
    id: number | null
    telefone_user: string | null
    created_at: Date | null
  }

  export type ConversationsCountAggregateOutputType = {
    id: number
    telefone_user: number
    messages: number
    created_at: number
    _all: number
  }


  export type ConversationsAvgAggregateInputType = {
    id?: true
  }

  export type ConversationsSumAggregateInputType = {
    id?: true
  }

  export type ConversationsMinAggregateInputType = {
    id?: true
    telefone_user?: true
    created_at?: true
  }

  export type ConversationsMaxAggregateInputType = {
    id?: true
    telefone_user?: true
    created_at?: true
  }

  export type ConversationsCountAggregateInputType = {
    id?: true
    telefone_user?: true
    messages?: true
    created_at?: true
    _all?: true
  }

  export type ConversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to aggregate.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationsMaxAggregateInputType
  }

  export type GetConversationsAggregateType<T extends ConversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations[P]>
      : GetScalarType<T[P], AggregateConversations[P]>
  }




  export type conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithAggregationInput | conversationsOrderByWithAggregationInput[]
    by: ConversationsScalarFieldEnum[] | ConversationsScalarFieldEnum
    having?: conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationsCountAggregateInputType | true
    _avg?: ConversationsAvgAggregateInputType
    _sum?: ConversationsSumAggregateInputType
    _min?: ConversationsMinAggregateInputType
    _max?: ConversationsMaxAggregateInputType
  }

  export type ConversationsGroupByOutputType = {
    id: number
    telefone_user: string
    messages: JsonValue
    created_at: Date | null
    _count: ConversationsCountAggregateOutputType | null
    _avg: ConversationsAvgAggregateOutputType | null
    _sum: ConversationsSumAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  type GetConversationsGroupByPayload<T extends conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
        }
      >
    >


  export type conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telefone_user?: boolean
    messages?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telefone_user?: boolean
    messages?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectScalar = {
    id?: boolean
    telefone_user?: boolean
    messages?: boolean
    created_at?: boolean
  }


  export type $conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telefone_user: string
      messages: Prisma.JsonValue
      created_at: Date | null
    }, ExtArgs["result"]["conversations"]>
    composites: {}
  }

  type conversationsGetPayload<S extends boolean | null | undefined | conversationsDefaultArgs> = $Result.GetResult<Prisma.$conversationsPayload, S>

  type conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<conversationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationsCountAggregateInputType | true
    }

  export interface conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations'], meta: { name: 'conversations' } }
    /**
     * Find zero or one Conversations that matches the filter.
     * @param {conversationsFindUniqueArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationsFindUniqueArgs>(args: SelectSubset<T, conversationsFindUniqueArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {conversationsFindUniqueOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationsFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationsFindFirstArgs>(args?: SelectSubset<T, conversationsFindFirstArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationsFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversations.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationsWithIdOnly = await prisma.conversations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationsFindManyArgs>(args?: SelectSubset<T, conversationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversations.
     * @param {conversationsCreateArgs} args - Arguments to create a Conversations.
     * @example
     * // Create one Conversations
     * const Conversations = await prisma.conversations.create({
     *   data: {
     *     // ... data to create a Conversations
     *   }
     * })
     * 
     */
    create<T extends conversationsCreateArgs>(args: SelectSubset<T, conversationsCreateArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {conversationsCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversations = await prisma.conversations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationsCreateManyArgs>(args?: SelectSubset<T, conversationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {conversationsCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversations = await prisma.conversations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationsWithIdOnly = await prisma.conversations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationsCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversations.
     * @param {conversationsDeleteArgs} args - Arguments to delete one Conversations.
     * @example
     * // Delete one Conversations
     * const Conversations = await prisma.conversations.delete({
     *   where: {
     *     // ... filter to delete one Conversations
     *   }
     * })
     * 
     */
    delete<T extends conversationsDeleteArgs>(args: SelectSubset<T, conversationsDeleteArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversations.
     * @param {conversationsUpdateArgs} args - Arguments to update one Conversations.
     * @example
     * // Update one Conversations
     * const conversations = await prisma.conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationsUpdateArgs>(args: SelectSubset<T, conversationsUpdateArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {conversationsDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationsDeleteManyArgs>(args?: SelectSubset<T, conversationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversations = await prisma.conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationsUpdateManyArgs>(args: SelectSubset<T, conversationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversations.
     * @param {conversationsUpsertArgs} args - Arguments to update or create a Conversations.
     * @example
     * // Update or create a Conversations
     * const conversations = await prisma.conversations.upsert({
     *   create: {
     *     // ... data to create a Conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations we want to update
     *   }
     * })
     */
    upsert<T extends conversationsUpsertArgs>(args: SelectSubset<T, conversationsUpsertArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversations.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationsCountArgs>(
      args?: Subset<T, conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationsAggregateArgs>(args: Subset<T, ConversationsAggregateArgs>): Prisma.PrismaPromise<GetConversationsAggregateType<T>>

    /**
     * Group by Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationsGroupByArgs['orderBy'] }
        : { orderBy?: conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations model
   */
  readonly fields: conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversations model
   */ 
  interface conversationsFieldRefs {
    readonly id: FieldRef<"conversations", 'Int'>
    readonly telefone_user: FieldRef<"conversations", 'String'>
    readonly messages: FieldRef<"conversations", 'Json'>
    readonly created_at: FieldRef<"conversations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversations findUnique
   */
  export type conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations findUniqueOrThrow
   */
  export type conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations findFirst
   */
  export type conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations findFirstOrThrow
   */
  export type conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations findMany
   */
  export type conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations create
   */
  export type conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * The data needed to create a conversations.
     */
    data: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
  }

  /**
   * conversations createMany
   */
  export type conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversations createManyAndReturn
   */
  export type conversationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversations update
   */
  export type conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * The data needed to update a conversations.
     */
    data: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
    /**
     * Choose, which conversations to update.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations updateMany
   */
  export type conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations upsert
   */
  export type conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * The filter to search for the conversations to update in case it exists.
     */
    where: conversationsWhereUniqueInput
    /**
     * In case the conversations found by the `where` argument doesn't exist, create a new conversations with this data.
     */
    create: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
    /**
     * In case the conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
  }

  /**
   * conversations delete
   */
  export type conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Filter which conversations to delete.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations deleteMany
   */
  export type conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations without action
   */
  export type conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
  }


  /**
   * Model documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    id: number | null
  }

  export type DocumentsSumAggregateOutputType = {
    id: bigint | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: bigint | null
    text: string | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: bigint | null
    text: string | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    text: number
    metadata: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    id?: true
  }

  export type DocumentsSumAggregateInputType = {
    id?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    text?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    text?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    text?: true
    metadata?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to aggregate.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithAggregationInput | documentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: bigint
    text: string
    metadata: JsonValue | null
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectScalar = {
    id?: boolean
    text?: boolean
    metadata?: boolean
  }


  export type $documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      text: string
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type documentsGetPayload<S extends boolean | null | undefined | documentsDefaultArgs> = $Result.GetResult<Prisma.$documentsPayload, S>

  type documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<documentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documents'], meta: { name: 'documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {documentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentsFindUniqueArgs>(args: SelectSubset<T, documentsFindUniqueArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {documentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentsFindFirstArgs>(args?: SelectSubset<T, documentsFindFirstArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentsFindManyArgs>(args?: SelectSubset<T, documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Documents.
     * @param {documentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends documentsCreateArgs>(args: SelectSubset<T, documentsCreateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {documentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentsCreateManyArgs>(args?: SelectSubset<T, documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {documentsCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends documentsCreateManyAndReturnArgs>(args?: SelectSubset<T, documentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Documents.
     * @param {documentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends documentsDeleteArgs>(args: SelectSubset<T, documentsDeleteArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Documents.
     * @param {documentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentsUpdateArgs>(args: SelectSubset<T, documentsUpdateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {documentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentsDeleteManyArgs>(args?: SelectSubset<T, documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentsUpdateManyArgs>(args: SelectSubset<T, documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documents.
     * @param {documentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends documentsUpsertArgs>(args: SelectSubset<T, documentsUpsertArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends documentsCountArgs>(
      args?: Subset<T, documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentsGroupByArgs['orderBy'] }
        : { orderBy?: documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documents model
   */
  readonly fields: documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documents model
   */ 
  interface documentsFieldRefs {
    readonly id: FieldRef<"documents", 'BigInt'>
    readonly text: FieldRef<"documents", 'String'>
    readonly metadata: FieldRef<"documents", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * documents findUnique
   */
  export type documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findUniqueOrThrow
   */
  export type documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findFirst
   */
  export type documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findFirstOrThrow
   */
  export type documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findMany
   */
  export type documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents create
   */
  export type documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * The data needed to create a documents.
     */
    data: XOR<documentsCreateInput, documentsUncheckedCreateInput>
  }

  /**
   * documents createMany
   */
  export type documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents createManyAndReturn
   */
  export type documentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents update
   */
  export type documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * The data needed to update a documents.
     */
    data: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
    /**
     * Choose, which documents to update.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents updateMany
   */
  export type documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
  }

  /**
   * documents upsert
   */
  export type documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * The filter to search for the documents to update in case it exists.
     */
    where: documentsWhereUniqueInput
    /**
     * In case the documents found by the `where` argument doesn't exist, create a new documents with this data.
     */
    create: XOR<documentsCreateInput, documentsUncheckedCreateInput>
    /**
     * In case the documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
  }

  /**
   * documents delete
   */
  export type documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Filter which documents to delete.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents deleteMany
   */
  export type documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to delete
     */
    where?: documentsWhereInput
  }

  /**
   * documents without action
   */
  export type documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
  }


  /**
   * Model especialidades
   */

  export type AggregateEspecialidades = {
    _count: EspecialidadesCountAggregateOutputType | null
    _avg: EspecialidadesAvgAggregateOutputType | null
    _sum: EspecialidadesSumAggregateOutputType | null
    _min: EspecialidadesMinAggregateOutputType | null
    _max: EspecialidadesMaxAggregateOutputType | null
  }

  export type EspecialidadesAvgAggregateOutputType = {
    id: number | null
  }

  export type EspecialidadesSumAggregateOutputType = {
    id: number | null
  }

  export type EspecialidadesMinAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
  }

  export type EspecialidadesMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
  }

  export type EspecialidadesCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    _all: number
  }


  export type EspecialidadesAvgAggregateInputType = {
    id?: true
  }

  export type EspecialidadesSumAggregateInputType = {
    id?: true
  }

  export type EspecialidadesMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type EspecialidadesMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type EspecialidadesCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    _all?: true
  }

  export type EspecialidadesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidades to aggregate.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned especialidades
    **/
    _count?: true | EspecialidadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecialidadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecialidadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecialidadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecialidadesMaxAggregateInputType
  }

  export type GetEspecialidadesAggregateType<T extends EspecialidadesAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecialidades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecialidades[P]>
      : GetScalarType<T[P], AggregateEspecialidades[P]>
  }




  export type especialidadesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidadesWhereInput
    orderBy?: especialidadesOrderByWithAggregationInput | especialidadesOrderByWithAggregationInput[]
    by: EspecialidadesScalarFieldEnum[] | EspecialidadesScalarFieldEnum
    having?: especialidadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecialidadesCountAggregateInputType | true
    _avg?: EspecialidadesAvgAggregateInputType
    _sum?: EspecialidadesSumAggregateInputType
    _min?: EspecialidadesMinAggregateInputType
    _max?: EspecialidadesMaxAggregateInputType
  }

  export type EspecialidadesGroupByOutputType = {
    id: number
    nome: string
    descricao: string | null
    _count: EspecialidadesCountAggregateOutputType | null
    _avg: EspecialidadesAvgAggregateOutputType | null
    _sum: EspecialidadesSumAggregateOutputType | null
    _min: EspecialidadesMinAggregateOutputType | null
    _max: EspecialidadesMaxAggregateOutputType | null
  }

  type GetEspecialidadesGroupByPayload<T extends especialidadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecialidadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecialidadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecialidadesGroupByOutputType[P]>
            : GetScalarType<T[P], EspecialidadesGroupByOutputType[P]>
        }
      >
    >


  export type especialidadesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    medicos?: boolean | especialidades$medicosArgs<ExtArgs>
    _count?: boolean | EspecialidadesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especialidades"]>

  export type especialidadesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["especialidades"]>

  export type especialidadesSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }

  export type especialidadesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | especialidades$medicosArgs<ExtArgs>
    _count?: boolean | EspecialidadesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type especialidadesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $especialidadesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "especialidades"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      descricao: string | null
    }, ExtArgs["result"]["especialidades"]>
    composites: {}
  }

  type especialidadesGetPayload<S extends boolean | null | undefined | especialidadesDefaultArgs> = $Result.GetResult<Prisma.$especialidadesPayload, S>

  type especialidadesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<especialidadesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspecialidadesCountAggregateInputType | true
    }

  export interface especialidadesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['especialidades'], meta: { name: 'especialidades' } }
    /**
     * Find zero or one Especialidades that matches the filter.
     * @param {especialidadesFindUniqueArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends especialidadesFindUniqueArgs>(args: SelectSubset<T, especialidadesFindUniqueArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Especialidades that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {especialidadesFindUniqueOrThrowArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends especialidadesFindUniqueOrThrowArgs>(args: SelectSubset<T, especialidadesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Especialidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesFindFirstArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends especialidadesFindFirstArgs>(args?: SelectSubset<T, especialidadesFindFirstArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Especialidades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesFindFirstOrThrowArgs} args - Arguments to find a Especialidades
     * @example
     * // Get one Especialidades
     * const especialidades = await prisma.especialidades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends especialidadesFindFirstOrThrowArgs>(args?: SelectSubset<T, especialidadesFindFirstOrThrowArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Especialidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especialidades
     * const especialidades = await prisma.especialidades.findMany()
     * 
     * // Get first 10 Especialidades
     * const especialidades = await prisma.especialidades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const especialidadesWithIdOnly = await prisma.especialidades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends especialidadesFindManyArgs>(args?: SelectSubset<T, especialidadesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Especialidades.
     * @param {especialidadesCreateArgs} args - Arguments to create a Especialidades.
     * @example
     * // Create one Especialidades
     * const Especialidades = await prisma.especialidades.create({
     *   data: {
     *     // ... data to create a Especialidades
     *   }
     * })
     * 
     */
    create<T extends especialidadesCreateArgs>(args: SelectSubset<T, especialidadesCreateArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Especialidades.
     * @param {especialidadesCreateManyArgs} args - Arguments to create many Especialidades.
     * @example
     * // Create many Especialidades
     * const especialidades = await prisma.especialidades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends especialidadesCreateManyArgs>(args?: SelectSubset<T, especialidadesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Especialidades and returns the data saved in the database.
     * @param {especialidadesCreateManyAndReturnArgs} args - Arguments to create many Especialidades.
     * @example
     * // Create many Especialidades
     * const especialidades = await prisma.especialidades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Especialidades and only return the `id`
     * const especialidadesWithIdOnly = await prisma.especialidades.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends especialidadesCreateManyAndReturnArgs>(args?: SelectSubset<T, especialidadesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Especialidades.
     * @param {especialidadesDeleteArgs} args - Arguments to delete one Especialidades.
     * @example
     * // Delete one Especialidades
     * const Especialidades = await prisma.especialidades.delete({
     *   where: {
     *     // ... filter to delete one Especialidades
     *   }
     * })
     * 
     */
    delete<T extends especialidadesDeleteArgs>(args: SelectSubset<T, especialidadesDeleteArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Especialidades.
     * @param {especialidadesUpdateArgs} args - Arguments to update one Especialidades.
     * @example
     * // Update one Especialidades
     * const especialidades = await prisma.especialidades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends especialidadesUpdateArgs>(args: SelectSubset<T, especialidadesUpdateArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Especialidades.
     * @param {especialidadesDeleteManyArgs} args - Arguments to filter Especialidades to delete.
     * @example
     * // Delete a few Especialidades
     * const { count } = await prisma.especialidades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends especialidadesDeleteManyArgs>(args?: SelectSubset<T, especialidadesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especialidades
     * const especialidades = await prisma.especialidades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends especialidadesUpdateManyArgs>(args: SelectSubset<T, especialidadesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Especialidades.
     * @param {especialidadesUpsertArgs} args - Arguments to update or create a Especialidades.
     * @example
     * // Update or create a Especialidades
     * const especialidades = await prisma.especialidades.upsert({
     *   create: {
     *     // ... data to create a Especialidades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especialidades we want to update
     *   }
     * })
     */
    upsert<T extends especialidadesUpsertArgs>(args: SelectSubset<T, especialidadesUpsertArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesCountArgs} args - Arguments to filter Especialidades to count.
     * @example
     * // Count the number of Especialidades
     * const count = await prisma.especialidades.count({
     *   where: {
     *     // ... the filter for the Especialidades we want to count
     *   }
     * })
    **/
    count<T extends especialidadesCountArgs>(
      args?: Subset<T, especialidadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecialidadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialidadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecialidadesAggregateArgs>(args: Subset<T, EspecialidadesAggregateArgs>): Prisma.PrismaPromise<GetEspecialidadesAggregateType<T>>

    /**
     * Group by Especialidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends especialidadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: especialidadesGroupByArgs['orderBy'] }
        : { orderBy?: especialidadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, especialidadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecialidadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the especialidades model
   */
  readonly fields: especialidadesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for especialidades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__especialidadesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends especialidades$medicosArgs<ExtArgs> = {}>(args?: Subset<T, especialidades$medicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the especialidades model
   */ 
  interface especialidadesFieldRefs {
    readonly id: FieldRef<"especialidades", 'Int'>
    readonly nome: FieldRef<"especialidades", 'String'>
    readonly descricao: FieldRef<"especialidades", 'String'>
  }
    

  // Custom InputTypes
  /**
   * especialidades findUnique
   */
  export type especialidadesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades findUniqueOrThrow
   */
  export type especialidadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades findFirst
   */
  export type especialidadesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidades.
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidades.
     */
    distinct?: EspecialidadesScalarFieldEnum | EspecialidadesScalarFieldEnum[]
  }

  /**
   * especialidades findFirstOrThrow
   */
  export type especialidadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidades.
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidades.
     */
    distinct?: EspecialidadesScalarFieldEnum | EspecialidadesScalarFieldEnum[]
  }

  /**
   * especialidades findMany
   */
  export type especialidadesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter, which especialidades to fetch.
     */
    where?: especialidadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidades to fetch.
     */
    orderBy?: especialidadesOrderByWithRelationInput | especialidadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing especialidades.
     */
    cursor?: especialidadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidades.
     */
    skip?: number
    distinct?: EspecialidadesScalarFieldEnum | EspecialidadesScalarFieldEnum[]
  }

  /**
   * especialidades create
   */
  export type especialidadesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * The data needed to create a especialidades.
     */
    data: XOR<especialidadesCreateInput, especialidadesUncheckedCreateInput>
  }

  /**
   * especialidades createMany
   */
  export type especialidadesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many especialidades.
     */
    data: especialidadesCreateManyInput | especialidadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidades createManyAndReturn
   */
  export type especialidadesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many especialidades.
     */
    data: especialidadesCreateManyInput | especialidadesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especialidades update
   */
  export type especialidadesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * The data needed to update a especialidades.
     */
    data: XOR<especialidadesUpdateInput, especialidadesUncheckedUpdateInput>
    /**
     * Choose, which especialidades to update.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades updateMany
   */
  export type especialidadesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update especialidades.
     */
    data: XOR<especialidadesUpdateManyMutationInput, especialidadesUncheckedUpdateManyInput>
    /**
     * Filter which especialidades to update
     */
    where?: especialidadesWhereInput
  }

  /**
   * especialidades upsert
   */
  export type especialidadesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * The filter to search for the especialidades to update in case it exists.
     */
    where: especialidadesWhereUniqueInput
    /**
     * In case the especialidades found by the `where` argument doesn't exist, create a new especialidades with this data.
     */
    create: XOR<especialidadesCreateInput, especialidadesUncheckedCreateInput>
    /**
     * In case the especialidades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<especialidadesUpdateInput, especialidadesUncheckedUpdateInput>
  }

  /**
   * especialidades delete
   */
  export type especialidadesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    /**
     * Filter which especialidades to delete.
     */
    where: especialidadesWhereUniqueInput
  }

  /**
   * especialidades deleteMany
   */
  export type especialidadesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidades to delete
     */
    where?: especialidadesWhereInput
  }

  /**
   * especialidades.medicos
   */
  export type especialidades$medicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    where?: medicosWhereInput
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    cursor?: medicosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * especialidades without action
   */
  export type especialidadesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
  }


  /**
   * Model medico_procedimentos
   */

  export type AggregateMedico_procedimentos = {
    _count: Medico_procedimentosCountAggregateOutputType | null
    _avg: Medico_procedimentosAvgAggregateOutputType | null
    _sum: Medico_procedimentosSumAggregateOutputType | null
    _min: Medico_procedimentosMinAggregateOutputType | null
    _max: Medico_procedimentosMaxAggregateOutputType | null
  }

  export type Medico_procedimentosAvgAggregateOutputType = {
    id: number | null
    medico_id: number | null
    procedimento_id: number | null
  }

  export type Medico_procedimentosSumAggregateOutputType = {
    id: number | null
    medico_id: number | null
    procedimento_id: number | null
  }

  export type Medico_procedimentosMinAggregateOutputType = {
    id: number | null
    medico_id: number | null
    procedimento_id: number | null
  }

  export type Medico_procedimentosMaxAggregateOutputType = {
    id: number | null
    medico_id: number | null
    procedimento_id: number | null
  }

  export type Medico_procedimentosCountAggregateOutputType = {
    id: number
    medico_id: number
    procedimento_id: number
    _all: number
  }


  export type Medico_procedimentosAvgAggregateInputType = {
    id?: true
    medico_id?: true
    procedimento_id?: true
  }

  export type Medico_procedimentosSumAggregateInputType = {
    id?: true
    medico_id?: true
    procedimento_id?: true
  }

  export type Medico_procedimentosMinAggregateInputType = {
    id?: true
    medico_id?: true
    procedimento_id?: true
  }

  export type Medico_procedimentosMaxAggregateInputType = {
    id?: true
    medico_id?: true
    procedimento_id?: true
  }

  export type Medico_procedimentosCountAggregateInputType = {
    id?: true
    medico_id?: true
    procedimento_id?: true
    _all?: true
  }

  export type Medico_procedimentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medico_procedimentos to aggregate.
     */
    where?: medico_procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_procedimentos to fetch.
     */
    orderBy?: medico_procedimentosOrderByWithRelationInput | medico_procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medico_procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_procedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medico_procedimentos
    **/
    _count?: true | Medico_procedimentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Medico_procedimentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Medico_procedimentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medico_procedimentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medico_procedimentosMaxAggregateInputType
  }

  export type GetMedico_procedimentosAggregateType<T extends Medico_procedimentosAggregateArgs> = {
        [P in keyof T & keyof AggregateMedico_procedimentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedico_procedimentos[P]>
      : GetScalarType<T[P], AggregateMedico_procedimentos[P]>
  }




  export type medico_procedimentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medico_procedimentosWhereInput
    orderBy?: medico_procedimentosOrderByWithAggregationInput | medico_procedimentosOrderByWithAggregationInput[]
    by: Medico_procedimentosScalarFieldEnum[] | Medico_procedimentosScalarFieldEnum
    having?: medico_procedimentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medico_procedimentosCountAggregateInputType | true
    _avg?: Medico_procedimentosAvgAggregateInputType
    _sum?: Medico_procedimentosSumAggregateInputType
    _min?: Medico_procedimentosMinAggregateInputType
    _max?: Medico_procedimentosMaxAggregateInputType
  }

  export type Medico_procedimentosGroupByOutputType = {
    id: number
    medico_id: number
    procedimento_id: number
    _count: Medico_procedimentosCountAggregateOutputType | null
    _avg: Medico_procedimentosAvgAggregateOutputType | null
    _sum: Medico_procedimentosSumAggregateOutputType | null
    _min: Medico_procedimentosMinAggregateOutputType | null
    _max: Medico_procedimentosMaxAggregateOutputType | null
  }

  type GetMedico_procedimentosGroupByPayload<T extends medico_procedimentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Medico_procedimentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Medico_procedimentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Medico_procedimentosGroupByOutputType[P]>
            : GetScalarType<T[P], Medico_procedimentosGroupByOutputType[P]>
        }
      >
    >


  export type medico_procedimentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medico_id?: boolean
    procedimento_id?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    procedimentos?: boolean | procedimentosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medico_procedimentos"]>

  export type medico_procedimentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medico_id?: boolean
    procedimento_id?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    procedimentos?: boolean | procedimentosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medico_procedimentos"]>

  export type medico_procedimentosSelectScalar = {
    id?: boolean
    medico_id?: boolean
    procedimento_id?: boolean
  }

  export type medico_procedimentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    procedimentos?: boolean | procedimentosDefaultArgs<ExtArgs>
  }
  export type medico_procedimentosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    procedimentos?: boolean | procedimentosDefaultArgs<ExtArgs>
  }

  export type $medico_procedimentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medico_procedimentos"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs>
      procedimentos: Prisma.$procedimentosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medico_id: number
      procedimento_id: number
    }, ExtArgs["result"]["medico_procedimentos"]>
    composites: {}
  }

  type medico_procedimentosGetPayload<S extends boolean | null | undefined | medico_procedimentosDefaultArgs> = $Result.GetResult<Prisma.$medico_procedimentosPayload, S>

  type medico_procedimentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medico_procedimentosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Medico_procedimentosCountAggregateInputType | true
    }

  export interface medico_procedimentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medico_procedimentos'], meta: { name: 'medico_procedimentos' } }
    /**
     * Find zero or one Medico_procedimentos that matches the filter.
     * @param {medico_procedimentosFindUniqueArgs} args - Arguments to find a Medico_procedimentos
     * @example
     * // Get one Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medico_procedimentosFindUniqueArgs>(args: SelectSubset<T, medico_procedimentosFindUniqueArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medico_procedimentos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medico_procedimentosFindUniqueOrThrowArgs} args - Arguments to find a Medico_procedimentos
     * @example
     * // Get one Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medico_procedimentosFindUniqueOrThrowArgs>(args: SelectSubset<T, medico_procedimentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medico_procedimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_procedimentosFindFirstArgs} args - Arguments to find a Medico_procedimentos
     * @example
     * // Get one Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medico_procedimentosFindFirstArgs>(args?: SelectSubset<T, medico_procedimentosFindFirstArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medico_procedimentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_procedimentosFindFirstOrThrowArgs} args - Arguments to find a Medico_procedimentos
     * @example
     * // Get one Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medico_procedimentosFindFirstOrThrowArgs>(args?: SelectSubset<T, medico_procedimentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medico_procedimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_procedimentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.findMany()
     * 
     * // Get first 10 Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medico_procedimentosWithIdOnly = await prisma.medico_procedimentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medico_procedimentosFindManyArgs>(args?: SelectSubset<T, medico_procedimentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medico_procedimentos.
     * @param {medico_procedimentosCreateArgs} args - Arguments to create a Medico_procedimentos.
     * @example
     * // Create one Medico_procedimentos
     * const Medico_procedimentos = await prisma.medico_procedimentos.create({
     *   data: {
     *     // ... data to create a Medico_procedimentos
     *   }
     * })
     * 
     */
    create<T extends medico_procedimentosCreateArgs>(args: SelectSubset<T, medico_procedimentosCreateArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medico_procedimentos.
     * @param {medico_procedimentosCreateManyArgs} args - Arguments to create many Medico_procedimentos.
     * @example
     * // Create many Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medico_procedimentosCreateManyArgs>(args?: SelectSubset<T, medico_procedimentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medico_procedimentos and returns the data saved in the database.
     * @param {medico_procedimentosCreateManyAndReturnArgs} args - Arguments to create many Medico_procedimentos.
     * @example
     * // Create many Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medico_procedimentos and only return the `id`
     * const medico_procedimentosWithIdOnly = await prisma.medico_procedimentos.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medico_procedimentosCreateManyAndReturnArgs>(args?: SelectSubset<T, medico_procedimentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medico_procedimentos.
     * @param {medico_procedimentosDeleteArgs} args - Arguments to delete one Medico_procedimentos.
     * @example
     * // Delete one Medico_procedimentos
     * const Medico_procedimentos = await prisma.medico_procedimentos.delete({
     *   where: {
     *     // ... filter to delete one Medico_procedimentos
     *   }
     * })
     * 
     */
    delete<T extends medico_procedimentosDeleteArgs>(args: SelectSubset<T, medico_procedimentosDeleteArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medico_procedimentos.
     * @param {medico_procedimentosUpdateArgs} args - Arguments to update one Medico_procedimentos.
     * @example
     * // Update one Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medico_procedimentosUpdateArgs>(args: SelectSubset<T, medico_procedimentosUpdateArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medico_procedimentos.
     * @param {medico_procedimentosDeleteManyArgs} args - Arguments to filter Medico_procedimentos to delete.
     * @example
     * // Delete a few Medico_procedimentos
     * const { count } = await prisma.medico_procedimentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medico_procedimentosDeleteManyArgs>(args?: SelectSubset<T, medico_procedimentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medico_procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_procedimentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medico_procedimentosUpdateManyArgs>(args: SelectSubset<T, medico_procedimentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medico_procedimentos.
     * @param {medico_procedimentosUpsertArgs} args - Arguments to update or create a Medico_procedimentos.
     * @example
     * // Update or create a Medico_procedimentos
     * const medico_procedimentos = await prisma.medico_procedimentos.upsert({
     *   create: {
     *     // ... data to create a Medico_procedimentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medico_procedimentos we want to update
     *   }
     * })
     */
    upsert<T extends medico_procedimentosUpsertArgs>(args: SelectSubset<T, medico_procedimentosUpsertArgs<ExtArgs>>): Prisma__medico_procedimentosClient<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medico_procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_procedimentosCountArgs} args - Arguments to filter Medico_procedimentos to count.
     * @example
     * // Count the number of Medico_procedimentos
     * const count = await prisma.medico_procedimentos.count({
     *   where: {
     *     // ... the filter for the Medico_procedimentos we want to count
     *   }
     * })
    **/
    count<T extends medico_procedimentosCountArgs>(
      args?: Subset<T, medico_procedimentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medico_procedimentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medico_procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medico_procedimentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medico_procedimentosAggregateArgs>(args: Subset<T, Medico_procedimentosAggregateArgs>): Prisma.PrismaPromise<GetMedico_procedimentosAggregateType<T>>

    /**
     * Group by Medico_procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_procedimentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medico_procedimentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medico_procedimentosGroupByArgs['orderBy'] }
        : { orderBy?: medico_procedimentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medico_procedimentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedico_procedimentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medico_procedimentos model
   */
  readonly fields: medico_procedimentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medico_procedimentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medico_procedimentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends medicosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, medicosDefaultArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    procedimentos<T extends procedimentosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, procedimentosDefaultArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medico_procedimentos model
   */ 
  interface medico_procedimentosFieldRefs {
    readonly id: FieldRef<"medico_procedimentos", 'Int'>
    readonly medico_id: FieldRef<"medico_procedimentos", 'Int'>
    readonly procedimento_id: FieldRef<"medico_procedimentos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * medico_procedimentos findUnique
   */
  export type medico_procedimentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which medico_procedimentos to fetch.
     */
    where: medico_procedimentosWhereUniqueInput
  }

  /**
   * medico_procedimentos findUniqueOrThrow
   */
  export type medico_procedimentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which medico_procedimentos to fetch.
     */
    where: medico_procedimentosWhereUniqueInput
  }

  /**
   * medico_procedimentos findFirst
   */
  export type medico_procedimentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which medico_procedimentos to fetch.
     */
    where?: medico_procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_procedimentos to fetch.
     */
    orderBy?: medico_procedimentosOrderByWithRelationInput | medico_procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medico_procedimentos.
     */
    cursor?: medico_procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_procedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medico_procedimentos.
     */
    distinct?: Medico_procedimentosScalarFieldEnum | Medico_procedimentosScalarFieldEnum[]
  }

  /**
   * medico_procedimentos findFirstOrThrow
   */
  export type medico_procedimentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which medico_procedimentos to fetch.
     */
    where?: medico_procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_procedimentos to fetch.
     */
    orderBy?: medico_procedimentosOrderByWithRelationInput | medico_procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medico_procedimentos.
     */
    cursor?: medico_procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_procedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medico_procedimentos.
     */
    distinct?: Medico_procedimentosScalarFieldEnum | Medico_procedimentosScalarFieldEnum[]
  }

  /**
   * medico_procedimentos findMany
   */
  export type medico_procedimentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which medico_procedimentos to fetch.
     */
    where?: medico_procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_procedimentos to fetch.
     */
    orderBy?: medico_procedimentosOrderByWithRelationInput | medico_procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medico_procedimentos.
     */
    cursor?: medico_procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_procedimentos.
     */
    skip?: number
    distinct?: Medico_procedimentosScalarFieldEnum | Medico_procedimentosScalarFieldEnum[]
  }

  /**
   * medico_procedimentos create
   */
  export type medico_procedimentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * The data needed to create a medico_procedimentos.
     */
    data: XOR<medico_procedimentosCreateInput, medico_procedimentosUncheckedCreateInput>
  }

  /**
   * medico_procedimentos createMany
   */
  export type medico_procedimentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medico_procedimentos.
     */
    data: medico_procedimentosCreateManyInput | medico_procedimentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medico_procedimentos createManyAndReturn
   */
  export type medico_procedimentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many medico_procedimentos.
     */
    data: medico_procedimentosCreateManyInput | medico_procedimentosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medico_procedimentos update
   */
  export type medico_procedimentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * The data needed to update a medico_procedimentos.
     */
    data: XOR<medico_procedimentosUpdateInput, medico_procedimentosUncheckedUpdateInput>
    /**
     * Choose, which medico_procedimentos to update.
     */
    where: medico_procedimentosWhereUniqueInput
  }

  /**
   * medico_procedimentos updateMany
   */
  export type medico_procedimentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medico_procedimentos.
     */
    data: XOR<medico_procedimentosUpdateManyMutationInput, medico_procedimentosUncheckedUpdateManyInput>
    /**
     * Filter which medico_procedimentos to update
     */
    where?: medico_procedimentosWhereInput
  }

  /**
   * medico_procedimentos upsert
   */
  export type medico_procedimentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * The filter to search for the medico_procedimentos to update in case it exists.
     */
    where: medico_procedimentosWhereUniqueInput
    /**
     * In case the medico_procedimentos found by the `where` argument doesn't exist, create a new medico_procedimentos with this data.
     */
    create: XOR<medico_procedimentosCreateInput, medico_procedimentosUncheckedCreateInput>
    /**
     * In case the medico_procedimentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medico_procedimentosUpdateInput, medico_procedimentosUncheckedUpdateInput>
  }

  /**
   * medico_procedimentos delete
   */
  export type medico_procedimentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    /**
     * Filter which medico_procedimentos to delete.
     */
    where: medico_procedimentosWhereUniqueInput
  }

  /**
   * medico_procedimentos deleteMany
   */
  export type medico_procedimentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medico_procedimentos to delete
     */
    where?: medico_procedimentosWhereInput
  }

  /**
   * medico_procedimentos without action
   */
  export type medico_procedimentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
  }


  /**
   * Model medico_sintomas
   */

  export type AggregateMedico_sintomas = {
    _count: Medico_sintomasCountAggregateOutputType | null
    _avg: Medico_sintomasAvgAggregateOutputType | null
    _sum: Medico_sintomasSumAggregateOutputType | null
    _min: Medico_sintomasMinAggregateOutputType | null
    _max: Medico_sintomasMaxAggregateOutputType | null
  }

  export type Medico_sintomasAvgAggregateOutputType = {
    id: number | null
    medico_id: number | null
    sintoma_id: number | null
  }

  export type Medico_sintomasSumAggregateOutputType = {
    id: number | null
    medico_id: number | null
    sintoma_id: number | null
  }

  export type Medico_sintomasMinAggregateOutputType = {
    id: number | null
    medico_id: number | null
    sintoma_id: number | null
  }

  export type Medico_sintomasMaxAggregateOutputType = {
    id: number | null
    medico_id: number | null
    sintoma_id: number | null
  }

  export type Medico_sintomasCountAggregateOutputType = {
    id: number
    medico_id: number
    sintoma_id: number
    _all: number
  }


  export type Medico_sintomasAvgAggregateInputType = {
    id?: true
    medico_id?: true
    sintoma_id?: true
  }

  export type Medico_sintomasSumAggregateInputType = {
    id?: true
    medico_id?: true
    sintoma_id?: true
  }

  export type Medico_sintomasMinAggregateInputType = {
    id?: true
    medico_id?: true
    sintoma_id?: true
  }

  export type Medico_sintomasMaxAggregateInputType = {
    id?: true
    medico_id?: true
    sintoma_id?: true
  }

  export type Medico_sintomasCountAggregateInputType = {
    id?: true
    medico_id?: true
    sintoma_id?: true
    _all?: true
  }

  export type Medico_sintomasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medico_sintomas to aggregate.
     */
    where?: medico_sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_sintomas to fetch.
     */
    orderBy?: medico_sintomasOrderByWithRelationInput | medico_sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medico_sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_sintomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medico_sintomas
    **/
    _count?: true | Medico_sintomasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Medico_sintomasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Medico_sintomasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medico_sintomasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medico_sintomasMaxAggregateInputType
  }

  export type GetMedico_sintomasAggregateType<T extends Medico_sintomasAggregateArgs> = {
        [P in keyof T & keyof AggregateMedico_sintomas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedico_sintomas[P]>
      : GetScalarType<T[P], AggregateMedico_sintomas[P]>
  }




  export type medico_sintomasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medico_sintomasWhereInput
    orderBy?: medico_sintomasOrderByWithAggregationInput | medico_sintomasOrderByWithAggregationInput[]
    by: Medico_sintomasScalarFieldEnum[] | Medico_sintomasScalarFieldEnum
    having?: medico_sintomasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medico_sintomasCountAggregateInputType | true
    _avg?: Medico_sintomasAvgAggregateInputType
    _sum?: Medico_sintomasSumAggregateInputType
    _min?: Medico_sintomasMinAggregateInputType
    _max?: Medico_sintomasMaxAggregateInputType
  }

  export type Medico_sintomasGroupByOutputType = {
    id: number
    medico_id: number
    sintoma_id: number
    _count: Medico_sintomasCountAggregateOutputType | null
    _avg: Medico_sintomasAvgAggregateOutputType | null
    _sum: Medico_sintomasSumAggregateOutputType | null
    _min: Medico_sintomasMinAggregateOutputType | null
    _max: Medico_sintomasMaxAggregateOutputType | null
  }

  type GetMedico_sintomasGroupByPayload<T extends medico_sintomasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Medico_sintomasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Medico_sintomasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Medico_sintomasGroupByOutputType[P]>
            : GetScalarType<T[P], Medico_sintomasGroupByOutputType[P]>
        }
      >
    >


  export type medico_sintomasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medico_id?: boolean
    sintoma_id?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    sintomas?: boolean | sintomasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medico_sintomas"]>

  export type medico_sintomasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medico_id?: boolean
    sintoma_id?: boolean
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    sintomas?: boolean | sintomasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medico_sintomas"]>

  export type medico_sintomasSelectScalar = {
    id?: boolean
    medico_id?: boolean
    sintoma_id?: boolean
  }

  export type medico_sintomasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    sintomas?: boolean | sintomasDefaultArgs<ExtArgs>
  }
  export type medico_sintomasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicos?: boolean | medicosDefaultArgs<ExtArgs>
    sintomas?: boolean | sintomasDefaultArgs<ExtArgs>
  }

  export type $medico_sintomasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medico_sintomas"
    objects: {
      medicos: Prisma.$medicosPayload<ExtArgs>
      sintomas: Prisma.$sintomasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      medico_id: number
      sintoma_id: number
    }, ExtArgs["result"]["medico_sintomas"]>
    composites: {}
  }

  type medico_sintomasGetPayload<S extends boolean | null | undefined | medico_sintomasDefaultArgs> = $Result.GetResult<Prisma.$medico_sintomasPayload, S>

  type medico_sintomasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medico_sintomasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Medico_sintomasCountAggregateInputType | true
    }

  export interface medico_sintomasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medico_sintomas'], meta: { name: 'medico_sintomas' } }
    /**
     * Find zero or one Medico_sintomas that matches the filter.
     * @param {medico_sintomasFindUniqueArgs} args - Arguments to find a Medico_sintomas
     * @example
     * // Get one Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medico_sintomasFindUniqueArgs>(args: SelectSubset<T, medico_sintomasFindUniqueArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medico_sintomas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medico_sintomasFindUniqueOrThrowArgs} args - Arguments to find a Medico_sintomas
     * @example
     * // Get one Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medico_sintomasFindUniqueOrThrowArgs>(args: SelectSubset<T, medico_sintomasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medico_sintomas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_sintomasFindFirstArgs} args - Arguments to find a Medico_sintomas
     * @example
     * // Get one Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medico_sintomasFindFirstArgs>(args?: SelectSubset<T, medico_sintomasFindFirstArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medico_sintomas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_sintomasFindFirstOrThrowArgs} args - Arguments to find a Medico_sintomas
     * @example
     * // Get one Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medico_sintomasFindFirstOrThrowArgs>(args?: SelectSubset<T, medico_sintomasFindFirstOrThrowArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medico_sintomas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_sintomasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.findMany()
     * 
     * // Get first 10 Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medico_sintomasWithIdOnly = await prisma.medico_sintomas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medico_sintomasFindManyArgs>(args?: SelectSubset<T, medico_sintomasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medico_sintomas.
     * @param {medico_sintomasCreateArgs} args - Arguments to create a Medico_sintomas.
     * @example
     * // Create one Medico_sintomas
     * const Medico_sintomas = await prisma.medico_sintomas.create({
     *   data: {
     *     // ... data to create a Medico_sintomas
     *   }
     * })
     * 
     */
    create<T extends medico_sintomasCreateArgs>(args: SelectSubset<T, medico_sintomasCreateArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medico_sintomas.
     * @param {medico_sintomasCreateManyArgs} args - Arguments to create many Medico_sintomas.
     * @example
     * // Create many Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medico_sintomasCreateManyArgs>(args?: SelectSubset<T, medico_sintomasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medico_sintomas and returns the data saved in the database.
     * @param {medico_sintomasCreateManyAndReturnArgs} args - Arguments to create many Medico_sintomas.
     * @example
     * // Create many Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medico_sintomas and only return the `id`
     * const medico_sintomasWithIdOnly = await prisma.medico_sintomas.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medico_sintomasCreateManyAndReturnArgs>(args?: SelectSubset<T, medico_sintomasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medico_sintomas.
     * @param {medico_sintomasDeleteArgs} args - Arguments to delete one Medico_sintomas.
     * @example
     * // Delete one Medico_sintomas
     * const Medico_sintomas = await prisma.medico_sintomas.delete({
     *   where: {
     *     // ... filter to delete one Medico_sintomas
     *   }
     * })
     * 
     */
    delete<T extends medico_sintomasDeleteArgs>(args: SelectSubset<T, medico_sintomasDeleteArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medico_sintomas.
     * @param {medico_sintomasUpdateArgs} args - Arguments to update one Medico_sintomas.
     * @example
     * // Update one Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medico_sintomasUpdateArgs>(args: SelectSubset<T, medico_sintomasUpdateArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medico_sintomas.
     * @param {medico_sintomasDeleteManyArgs} args - Arguments to filter Medico_sintomas to delete.
     * @example
     * // Delete a few Medico_sintomas
     * const { count } = await prisma.medico_sintomas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medico_sintomasDeleteManyArgs>(args?: SelectSubset<T, medico_sintomasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medico_sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_sintomasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medico_sintomasUpdateManyArgs>(args: SelectSubset<T, medico_sintomasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medico_sintomas.
     * @param {medico_sintomasUpsertArgs} args - Arguments to update or create a Medico_sintomas.
     * @example
     * // Update or create a Medico_sintomas
     * const medico_sintomas = await prisma.medico_sintomas.upsert({
     *   create: {
     *     // ... data to create a Medico_sintomas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medico_sintomas we want to update
     *   }
     * })
     */
    upsert<T extends medico_sintomasUpsertArgs>(args: SelectSubset<T, medico_sintomasUpsertArgs<ExtArgs>>): Prisma__medico_sintomasClient<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medico_sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_sintomasCountArgs} args - Arguments to filter Medico_sintomas to count.
     * @example
     * // Count the number of Medico_sintomas
     * const count = await prisma.medico_sintomas.count({
     *   where: {
     *     // ... the filter for the Medico_sintomas we want to count
     *   }
     * })
    **/
    count<T extends medico_sintomasCountArgs>(
      args?: Subset<T, medico_sintomasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medico_sintomasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medico_sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medico_sintomasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medico_sintomasAggregateArgs>(args: Subset<T, Medico_sintomasAggregateArgs>): Prisma.PrismaPromise<GetMedico_sintomasAggregateType<T>>

    /**
     * Group by Medico_sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medico_sintomasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medico_sintomasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medico_sintomasGroupByArgs['orderBy'] }
        : { orderBy?: medico_sintomasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medico_sintomasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedico_sintomasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medico_sintomas model
   */
  readonly fields: medico_sintomasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medico_sintomas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medico_sintomasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicos<T extends medicosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, medicosDefaultArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sintomas<T extends sintomasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sintomasDefaultArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medico_sintomas model
   */ 
  interface medico_sintomasFieldRefs {
    readonly id: FieldRef<"medico_sintomas", 'Int'>
    readonly medico_id: FieldRef<"medico_sintomas", 'Int'>
    readonly sintoma_id: FieldRef<"medico_sintomas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * medico_sintomas findUnique
   */
  export type medico_sintomasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * Filter, which medico_sintomas to fetch.
     */
    where: medico_sintomasWhereUniqueInput
  }

  /**
   * medico_sintomas findUniqueOrThrow
   */
  export type medico_sintomasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * Filter, which medico_sintomas to fetch.
     */
    where: medico_sintomasWhereUniqueInput
  }

  /**
   * medico_sintomas findFirst
   */
  export type medico_sintomasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * Filter, which medico_sintomas to fetch.
     */
    where?: medico_sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_sintomas to fetch.
     */
    orderBy?: medico_sintomasOrderByWithRelationInput | medico_sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medico_sintomas.
     */
    cursor?: medico_sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_sintomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medico_sintomas.
     */
    distinct?: Medico_sintomasScalarFieldEnum | Medico_sintomasScalarFieldEnum[]
  }

  /**
   * medico_sintomas findFirstOrThrow
   */
  export type medico_sintomasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * Filter, which medico_sintomas to fetch.
     */
    where?: medico_sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_sintomas to fetch.
     */
    orderBy?: medico_sintomasOrderByWithRelationInput | medico_sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medico_sintomas.
     */
    cursor?: medico_sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_sintomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medico_sintomas.
     */
    distinct?: Medico_sintomasScalarFieldEnum | Medico_sintomasScalarFieldEnum[]
  }

  /**
   * medico_sintomas findMany
   */
  export type medico_sintomasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * Filter, which medico_sintomas to fetch.
     */
    where?: medico_sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medico_sintomas to fetch.
     */
    orderBy?: medico_sintomasOrderByWithRelationInput | medico_sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medico_sintomas.
     */
    cursor?: medico_sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medico_sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medico_sintomas.
     */
    skip?: number
    distinct?: Medico_sintomasScalarFieldEnum | Medico_sintomasScalarFieldEnum[]
  }

  /**
   * medico_sintomas create
   */
  export type medico_sintomasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * The data needed to create a medico_sintomas.
     */
    data: XOR<medico_sintomasCreateInput, medico_sintomasUncheckedCreateInput>
  }

  /**
   * medico_sintomas createMany
   */
  export type medico_sintomasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medico_sintomas.
     */
    data: medico_sintomasCreateManyInput | medico_sintomasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medico_sintomas createManyAndReturn
   */
  export type medico_sintomasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many medico_sintomas.
     */
    data: medico_sintomasCreateManyInput | medico_sintomasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medico_sintomas update
   */
  export type medico_sintomasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * The data needed to update a medico_sintomas.
     */
    data: XOR<medico_sintomasUpdateInput, medico_sintomasUncheckedUpdateInput>
    /**
     * Choose, which medico_sintomas to update.
     */
    where: medico_sintomasWhereUniqueInput
  }

  /**
   * medico_sintomas updateMany
   */
  export type medico_sintomasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medico_sintomas.
     */
    data: XOR<medico_sintomasUpdateManyMutationInput, medico_sintomasUncheckedUpdateManyInput>
    /**
     * Filter which medico_sintomas to update
     */
    where?: medico_sintomasWhereInput
  }

  /**
   * medico_sintomas upsert
   */
  export type medico_sintomasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * The filter to search for the medico_sintomas to update in case it exists.
     */
    where: medico_sintomasWhereUniqueInput
    /**
     * In case the medico_sintomas found by the `where` argument doesn't exist, create a new medico_sintomas with this data.
     */
    create: XOR<medico_sintomasCreateInput, medico_sintomasUncheckedCreateInput>
    /**
     * In case the medico_sintomas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medico_sintomasUpdateInput, medico_sintomasUncheckedUpdateInput>
  }

  /**
   * medico_sintomas delete
   */
  export type medico_sintomasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    /**
     * Filter which medico_sintomas to delete.
     */
    where: medico_sintomasWhereUniqueInput
  }

  /**
   * medico_sintomas deleteMany
   */
  export type medico_sintomasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medico_sintomas to delete
     */
    where?: medico_sintomasWhereInput
  }

  /**
   * medico_sintomas without action
   */
  export type medico_sintomasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
  }


  /**
   * Model medicos
   */

  export type AggregateMedicos = {
    _count: MedicosCountAggregateOutputType | null
    _avg: MedicosAvgAggregateOutputType | null
    _sum: MedicosSumAggregateOutputType | null
    _min: MedicosMinAggregateOutputType | null
    _max: MedicosMaxAggregateOutputType | null
  }

  export type MedicosAvgAggregateOutputType = {
    id: number | null
    especialidade_id: number | null
  }

  export type MedicosSumAggregateOutputType = {
    id: number | null
    especialidade_id: number | null
  }

  export type MedicosMinAggregateOutputType = {
    id: number | null
    nome: string | null
    especialidade_id: number | null
    id_calendario: string | null
    dia_atendimento: string | null
    metodo_pagamento: string | null
  }

  export type MedicosMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    especialidade_id: number | null
    id_calendario: string | null
    dia_atendimento: string | null
    metodo_pagamento: string | null
  }

  export type MedicosCountAggregateOutputType = {
    id: number
    nome: number
    especialidade_id: number
    id_calendario: number
    dia_atendimento: number
    metodo_pagamento: number
    _all: number
  }


  export type MedicosAvgAggregateInputType = {
    id?: true
    especialidade_id?: true
  }

  export type MedicosSumAggregateInputType = {
    id?: true
    especialidade_id?: true
  }

  export type MedicosMinAggregateInputType = {
    id?: true
    nome?: true
    especialidade_id?: true
    id_calendario?: true
    dia_atendimento?: true
    metodo_pagamento?: true
  }

  export type MedicosMaxAggregateInputType = {
    id?: true
    nome?: true
    especialidade_id?: true
    id_calendario?: true
    dia_atendimento?: true
    metodo_pagamento?: true
  }

  export type MedicosCountAggregateInputType = {
    id?: true
    nome?: true
    especialidade_id?: true
    id_calendario?: true
    dia_atendimento?: true
    metodo_pagamento?: true
    _all?: true
  }

  export type MedicosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicos to aggregate.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicos
    **/
    _count?: true | MedicosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicosMaxAggregateInputType
  }

  export type GetMedicosAggregateType<T extends MedicosAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicos[P]>
      : GetScalarType<T[P], AggregateMedicos[P]>
  }




  export type medicosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicosWhereInput
    orderBy?: medicosOrderByWithAggregationInput | medicosOrderByWithAggregationInput[]
    by: MedicosScalarFieldEnum[] | MedicosScalarFieldEnum
    having?: medicosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicosCountAggregateInputType | true
    _avg?: MedicosAvgAggregateInputType
    _sum?: MedicosSumAggregateInputType
    _min?: MedicosMinAggregateInputType
    _max?: MedicosMaxAggregateInputType
  }

  export type MedicosGroupByOutputType = {
    id: number
    nome: string
    especialidade_id: number | null
    id_calendario: string | null
    dia_atendimento: string | null
    metodo_pagamento: string | null
    _count: MedicosCountAggregateOutputType | null
    _avg: MedicosAvgAggregateOutputType | null
    _sum: MedicosSumAggregateOutputType | null
    _min: MedicosMinAggregateOutputType | null
    _max: MedicosMaxAggregateOutputType | null
  }

  type GetMedicosGroupByPayload<T extends medicosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicosGroupByOutputType[P]>
            : GetScalarType<T[P], MedicosGroupByOutputType[P]>
        }
      >
    >


  export type medicosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    especialidade_id?: boolean
    id_calendario?: boolean
    dia_atendimento?: boolean
    metodo_pagamento?: boolean
    consultas?: boolean | medicos$consultasArgs<ExtArgs>
    medico_procedimentos?: boolean | medicos$medico_procedimentosArgs<ExtArgs>
    medico_sintomas?: boolean | medicos$medico_sintomasArgs<ExtArgs>
    especialidades?: boolean | medicos$especialidadesArgs<ExtArgs>
    _count?: boolean | MedicosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicos"]>

  export type medicosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    especialidade_id?: boolean
    id_calendario?: boolean
    dia_atendimento?: boolean
    metodo_pagamento?: boolean
    especialidades?: boolean | medicos$especialidadesArgs<ExtArgs>
  }, ExtArgs["result"]["medicos"]>

  export type medicosSelectScalar = {
    id?: boolean
    nome?: boolean
    especialidade_id?: boolean
    id_calendario?: boolean
    dia_atendimento?: boolean
    metodo_pagamento?: boolean
  }

  export type medicosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultas?: boolean | medicos$consultasArgs<ExtArgs>
    medico_procedimentos?: boolean | medicos$medico_procedimentosArgs<ExtArgs>
    medico_sintomas?: boolean | medicos$medico_sintomasArgs<ExtArgs>
    especialidades?: boolean | medicos$especialidadesArgs<ExtArgs>
    _count?: boolean | MedicosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type medicosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especialidades?: boolean | medicos$especialidadesArgs<ExtArgs>
  }

  export type $medicosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicos"
    objects: {
      consultas: Prisma.$consultasPayload<ExtArgs>[]
      medico_procedimentos: Prisma.$medico_procedimentosPayload<ExtArgs>[]
      medico_sintomas: Prisma.$medico_sintomasPayload<ExtArgs>[]
      especialidades: Prisma.$especialidadesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      especialidade_id: number | null
      id_calendario: string | null
      dia_atendimento: string | null
      metodo_pagamento: string | null
    }, ExtArgs["result"]["medicos"]>
    composites: {}
  }

  type medicosGetPayload<S extends boolean | null | undefined | medicosDefaultArgs> = $Result.GetResult<Prisma.$medicosPayload, S>

  type medicosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medicosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicosCountAggregateInputType | true
    }

  export interface medicosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicos'], meta: { name: 'medicos' } }
    /**
     * Find zero or one Medicos that matches the filter.
     * @param {medicosFindUniqueArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicosFindUniqueArgs>(args: SelectSubset<T, medicosFindUniqueArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medicos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medicosFindUniqueOrThrowArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicosFindUniqueOrThrowArgs>(args: SelectSubset<T, medicosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosFindFirstArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicosFindFirstArgs>(args?: SelectSubset<T, medicosFindFirstArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medicos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosFindFirstOrThrowArgs} args - Arguments to find a Medicos
     * @example
     * // Get one Medicos
     * const medicos = await prisma.medicos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicosFindFirstOrThrowArgs>(args?: SelectSubset<T, medicosFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicos
     * const medicos = await prisma.medicos.findMany()
     * 
     * // Get first 10 Medicos
     * const medicos = await prisma.medicos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicosWithIdOnly = await prisma.medicos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medicosFindManyArgs>(args?: SelectSubset<T, medicosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medicos.
     * @param {medicosCreateArgs} args - Arguments to create a Medicos.
     * @example
     * // Create one Medicos
     * const Medicos = await prisma.medicos.create({
     *   data: {
     *     // ... data to create a Medicos
     *   }
     * })
     * 
     */
    create<T extends medicosCreateArgs>(args: SelectSubset<T, medicosCreateArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medicos.
     * @param {medicosCreateManyArgs} args - Arguments to create many Medicos.
     * @example
     * // Create many Medicos
     * const medicos = await prisma.medicos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicosCreateManyArgs>(args?: SelectSubset<T, medicosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicos and returns the data saved in the database.
     * @param {medicosCreateManyAndReturnArgs} args - Arguments to create many Medicos.
     * @example
     * // Create many Medicos
     * const medicos = await prisma.medicos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicos and only return the `id`
     * const medicosWithIdOnly = await prisma.medicos.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medicosCreateManyAndReturnArgs>(args?: SelectSubset<T, medicosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medicos.
     * @param {medicosDeleteArgs} args - Arguments to delete one Medicos.
     * @example
     * // Delete one Medicos
     * const Medicos = await prisma.medicos.delete({
     *   where: {
     *     // ... filter to delete one Medicos
     *   }
     * })
     * 
     */
    delete<T extends medicosDeleteArgs>(args: SelectSubset<T, medicosDeleteArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medicos.
     * @param {medicosUpdateArgs} args - Arguments to update one Medicos.
     * @example
     * // Update one Medicos
     * const medicos = await prisma.medicos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicosUpdateArgs>(args: SelectSubset<T, medicosUpdateArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medicos.
     * @param {medicosDeleteManyArgs} args - Arguments to filter Medicos to delete.
     * @example
     * // Delete a few Medicos
     * const { count } = await prisma.medicos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicosDeleteManyArgs>(args?: SelectSubset<T, medicosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicos
     * const medicos = await prisma.medicos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicosUpdateManyArgs>(args: SelectSubset<T, medicosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicos.
     * @param {medicosUpsertArgs} args - Arguments to update or create a Medicos.
     * @example
     * // Update or create a Medicos
     * const medicos = await prisma.medicos.upsert({
     *   create: {
     *     // ... data to create a Medicos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicos we want to update
     *   }
     * })
     */
    upsert<T extends medicosUpsertArgs>(args: SelectSubset<T, medicosUpsertArgs<ExtArgs>>): Prisma__medicosClient<$Result.GetResult<Prisma.$medicosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosCountArgs} args - Arguments to filter Medicos to count.
     * @example
     * // Count the number of Medicos
     * const count = await prisma.medicos.count({
     *   where: {
     *     // ... the filter for the Medicos we want to count
     *   }
     * })
    **/
    count<T extends medicosCountArgs>(
      args?: Subset<T, medicosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicosAggregateArgs>(args: Subset<T, MedicosAggregateArgs>): Prisma.PrismaPromise<GetMedicosAggregateType<T>>

    /**
     * Group by Medicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicosGroupByArgs['orderBy'] }
        : { orderBy?: medicosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicos model
   */
  readonly fields: medicosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultas<T extends medicos$consultasArgs<ExtArgs> = {}>(args?: Subset<T, medicos$consultasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findMany"> | Null>
    medico_procedimentos<T extends medicos$medico_procedimentosArgs<ExtArgs> = {}>(args?: Subset<T, medicos$medico_procedimentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findMany"> | Null>
    medico_sintomas<T extends medicos$medico_sintomasArgs<ExtArgs> = {}>(args?: Subset<T, medicos$medico_sintomasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findMany"> | Null>
    especialidades<T extends medicos$especialidadesArgs<ExtArgs> = {}>(args?: Subset<T, medicos$especialidadesArgs<ExtArgs>>): Prisma__especialidadesClient<$Result.GetResult<Prisma.$especialidadesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicos model
   */ 
  interface medicosFieldRefs {
    readonly id: FieldRef<"medicos", 'Int'>
    readonly nome: FieldRef<"medicos", 'String'>
    readonly especialidade_id: FieldRef<"medicos", 'Int'>
    readonly id_calendario: FieldRef<"medicos", 'String'>
    readonly dia_atendimento: FieldRef<"medicos", 'String'>
    readonly metodo_pagamento: FieldRef<"medicos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * medicos findUnique
   */
  export type medicosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos findUniqueOrThrow
   */
  export type medicosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos findFirst
   */
  export type medicosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicos.
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicos.
     */
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * medicos findFirstOrThrow
   */
  export type medicosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicos.
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicos.
     */
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * medicos findMany
   */
  export type medicosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter, which medicos to fetch.
     */
    where?: medicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicos to fetch.
     */
    orderBy?: medicosOrderByWithRelationInput | medicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicos.
     */
    cursor?: medicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicos.
     */
    skip?: number
    distinct?: MedicosScalarFieldEnum | MedicosScalarFieldEnum[]
  }

  /**
   * medicos create
   */
  export type medicosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * The data needed to create a medicos.
     */
    data: XOR<medicosCreateInput, medicosUncheckedCreateInput>
  }

  /**
   * medicos createMany
   */
  export type medicosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicos.
     */
    data: medicosCreateManyInput | medicosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicos createManyAndReturn
   */
  export type medicosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many medicos.
     */
    data: medicosCreateManyInput | medicosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medicos update
   */
  export type medicosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * The data needed to update a medicos.
     */
    data: XOR<medicosUpdateInput, medicosUncheckedUpdateInput>
    /**
     * Choose, which medicos to update.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos updateMany
   */
  export type medicosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicos.
     */
    data: XOR<medicosUpdateManyMutationInput, medicosUncheckedUpdateManyInput>
    /**
     * Filter which medicos to update
     */
    where?: medicosWhereInput
  }

  /**
   * medicos upsert
   */
  export type medicosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * The filter to search for the medicos to update in case it exists.
     */
    where: medicosWhereUniqueInput
    /**
     * In case the medicos found by the `where` argument doesn't exist, create a new medicos with this data.
     */
    create: XOR<medicosCreateInput, medicosUncheckedCreateInput>
    /**
     * In case the medicos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicosUpdateInput, medicosUncheckedUpdateInput>
  }

  /**
   * medicos delete
   */
  export type medicosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
    /**
     * Filter which medicos to delete.
     */
    where: medicosWhereUniqueInput
  }

  /**
   * medicos deleteMany
   */
  export type medicosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicos to delete
     */
    where?: medicosWhereInput
  }

  /**
   * medicos.consultas
   */
  export type medicos$consultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    where?: consultasWhereInput
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    cursor?: consultasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * medicos.medico_procedimentos
   */
  export type medicos$medico_procedimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    where?: medico_procedimentosWhereInput
    orderBy?: medico_procedimentosOrderByWithRelationInput | medico_procedimentosOrderByWithRelationInput[]
    cursor?: medico_procedimentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medico_procedimentosScalarFieldEnum | Medico_procedimentosScalarFieldEnum[]
  }

  /**
   * medicos.medico_sintomas
   */
  export type medicos$medico_sintomasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    where?: medico_sintomasWhereInput
    orderBy?: medico_sintomasOrderByWithRelationInput | medico_sintomasOrderByWithRelationInput[]
    cursor?: medico_sintomasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medico_sintomasScalarFieldEnum | Medico_sintomasScalarFieldEnum[]
  }

  /**
   * medicos.especialidades
   */
  export type medicos$especialidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidades
     */
    select?: especialidadesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: especialidadesInclude<ExtArgs> | null
    where?: especialidadesWhereInput
  }

  /**
   * medicos without action
   */
  export type medicosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicos
     */
    select?: medicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicosInclude<ExtArgs> | null
  }


  /**
   * Model n8n_chat_histories
   */

  export type AggregateN8n_chat_histories = {
    _count: N8n_chat_historiesCountAggregateOutputType | null
    _avg: N8n_chat_historiesAvgAggregateOutputType | null
    _sum: N8n_chat_historiesSumAggregateOutputType | null
    _min: N8n_chat_historiesMinAggregateOutputType | null
    _max: N8n_chat_historiesMaxAggregateOutputType | null
  }

  export type N8n_chat_historiesAvgAggregateOutputType = {
    id: number | null
  }

  export type N8n_chat_historiesSumAggregateOutputType = {
    id: number | null
  }

  export type N8n_chat_historiesMinAggregateOutputType = {
    id: number | null
    session_id: string | null
  }

  export type N8n_chat_historiesMaxAggregateOutputType = {
    id: number | null
    session_id: string | null
  }

  export type N8n_chat_historiesCountAggregateOutputType = {
    id: number
    session_id: number
    message: number
    _all: number
  }


  export type N8n_chat_historiesAvgAggregateInputType = {
    id?: true
  }

  export type N8n_chat_historiesSumAggregateInputType = {
    id?: true
  }

  export type N8n_chat_historiesMinAggregateInputType = {
    id?: true
    session_id?: true
  }

  export type N8n_chat_historiesMaxAggregateInputType = {
    id?: true
    session_id?: true
  }

  export type N8n_chat_historiesCountAggregateInputType = {
    id?: true
    session_id?: true
    message?: true
    _all?: true
  }

  export type N8n_chat_historiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which n8n_chat_histories to aggregate.
     */
    where?: n8n_chat_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of n8n_chat_histories to fetch.
     */
    orderBy?: n8n_chat_historiesOrderByWithRelationInput | n8n_chat_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: n8n_chat_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` n8n_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` n8n_chat_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned n8n_chat_histories
    **/
    _count?: true | N8n_chat_historiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: N8n_chat_historiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: N8n_chat_historiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: N8n_chat_historiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: N8n_chat_historiesMaxAggregateInputType
  }

  export type GetN8n_chat_historiesAggregateType<T extends N8n_chat_historiesAggregateArgs> = {
        [P in keyof T & keyof AggregateN8n_chat_histories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateN8n_chat_histories[P]>
      : GetScalarType<T[P], AggregateN8n_chat_histories[P]>
  }




  export type n8n_chat_historiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: n8n_chat_historiesWhereInput
    orderBy?: n8n_chat_historiesOrderByWithAggregationInput | n8n_chat_historiesOrderByWithAggregationInput[]
    by: N8n_chat_historiesScalarFieldEnum[] | N8n_chat_historiesScalarFieldEnum
    having?: n8n_chat_historiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: N8n_chat_historiesCountAggregateInputType | true
    _avg?: N8n_chat_historiesAvgAggregateInputType
    _sum?: N8n_chat_historiesSumAggregateInputType
    _min?: N8n_chat_historiesMinAggregateInputType
    _max?: N8n_chat_historiesMaxAggregateInputType
  }

  export type N8n_chat_historiesGroupByOutputType = {
    id: number
    session_id: string
    message: JsonValue
    _count: N8n_chat_historiesCountAggregateOutputType | null
    _avg: N8n_chat_historiesAvgAggregateOutputType | null
    _sum: N8n_chat_historiesSumAggregateOutputType | null
    _min: N8n_chat_historiesMinAggregateOutputType | null
    _max: N8n_chat_historiesMaxAggregateOutputType | null
  }

  type GetN8n_chat_historiesGroupByPayload<T extends n8n_chat_historiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<N8n_chat_historiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof N8n_chat_historiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], N8n_chat_historiesGroupByOutputType[P]>
            : GetScalarType<T[P], N8n_chat_historiesGroupByOutputType[P]>
        }
      >
    >


  export type n8n_chat_historiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    message?: boolean
  }, ExtArgs["result"]["n8n_chat_histories"]>

  export type n8n_chat_historiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    message?: boolean
  }, ExtArgs["result"]["n8n_chat_histories"]>

  export type n8n_chat_historiesSelectScalar = {
    id?: boolean
    session_id?: boolean
    message?: boolean
  }


  export type $n8n_chat_historiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "n8n_chat_histories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_id: string
      message: Prisma.JsonValue
    }, ExtArgs["result"]["n8n_chat_histories"]>
    composites: {}
  }

  type n8n_chat_historiesGetPayload<S extends boolean | null | undefined | n8n_chat_historiesDefaultArgs> = $Result.GetResult<Prisma.$n8n_chat_historiesPayload, S>

  type n8n_chat_historiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<n8n_chat_historiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: N8n_chat_historiesCountAggregateInputType | true
    }

  export interface n8n_chat_historiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['n8n_chat_histories'], meta: { name: 'n8n_chat_histories' } }
    /**
     * Find zero or one N8n_chat_histories that matches the filter.
     * @param {n8n_chat_historiesFindUniqueArgs} args - Arguments to find a N8n_chat_histories
     * @example
     * // Get one N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends n8n_chat_historiesFindUniqueArgs>(args: SelectSubset<T, n8n_chat_historiesFindUniqueArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one N8n_chat_histories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {n8n_chat_historiesFindUniqueOrThrowArgs} args - Arguments to find a N8n_chat_histories
     * @example
     * // Get one N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends n8n_chat_historiesFindUniqueOrThrowArgs>(args: SelectSubset<T, n8n_chat_historiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first N8n_chat_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {n8n_chat_historiesFindFirstArgs} args - Arguments to find a N8n_chat_histories
     * @example
     * // Get one N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends n8n_chat_historiesFindFirstArgs>(args?: SelectSubset<T, n8n_chat_historiesFindFirstArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first N8n_chat_histories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {n8n_chat_historiesFindFirstOrThrowArgs} args - Arguments to find a N8n_chat_histories
     * @example
     * // Get one N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends n8n_chat_historiesFindFirstOrThrowArgs>(args?: SelectSubset<T, n8n_chat_historiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more N8n_chat_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {n8n_chat_historiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.findMany()
     * 
     * // Get first 10 N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const n8n_chat_historiesWithIdOnly = await prisma.n8n_chat_histories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends n8n_chat_historiesFindManyArgs>(args?: SelectSubset<T, n8n_chat_historiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a N8n_chat_histories.
     * @param {n8n_chat_historiesCreateArgs} args - Arguments to create a N8n_chat_histories.
     * @example
     * // Create one N8n_chat_histories
     * const N8n_chat_histories = await prisma.n8n_chat_histories.create({
     *   data: {
     *     // ... data to create a N8n_chat_histories
     *   }
     * })
     * 
     */
    create<T extends n8n_chat_historiesCreateArgs>(args: SelectSubset<T, n8n_chat_historiesCreateArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many N8n_chat_histories.
     * @param {n8n_chat_historiesCreateManyArgs} args - Arguments to create many N8n_chat_histories.
     * @example
     * // Create many N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends n8n_chat_historiesCreateManyArgs>(args?: SelectSubset<T, n8n_chat_historiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many N8n_chat_histories and returns the data saved in the database.
     * @param {n8n_chat_historiesCreateManyAndReturnArgs} args - Arguments to create many N8n_chat_histories.
     * @example
     * // Create many N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many N8n_chat_histories and only return the `id`
     * const n8n_chat_historiesWithIdOnly = await prisma.n8n_chat_histories.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends n8n_chat_historiesCreateManyAndReturnArgs>(args?: SelectSubset<T, n8n_chat_historiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a N8n_chat_histories.
     * @param {n8n_chat_historiesDeleteArgs} args - Arguments to delete one N8n_chat_histories.
     * @example
     * // Delete one N8n_chat_histories
     * const N8n_chat_histories = await prisma.n8n_chat_histories.delete({
     *   where: {
     *     // ... filter to delete one N8n_chat_histories
     *   }
     * })
     * 
     */
    delete<T extends n8n_chat_historiesDeleteArgs>(args: SelectSubset<T, n8n_chat_historiesDeleteArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one N8n_chat_histories.
     * @param {n8n_chat_historiesUpdateArgs} args - Arguments to update one N8n_chat_histories.
     * @example
     * // Update one N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends n8n_chat_historiesUpdateArgs>(args: SelectSubset<T, n8n_chat_historiesUpdateArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more N8n_chat_histories.
     * @param {n8n_chat_historiesDeleteManyArgs} args - Arguments to filter N8n_chat_histories to delete.
     * @example
     * // Delete a few N8n_chat_histories
     * const { count } = await prisma.n8n_chat_histories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends n8n_chat_historiesDeleteManyArgs>(args?: SelectSubset<T, n8n_chat_historiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more N8n_chat_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {n8n_chat_historiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends n8n_chat_historiesUpdateManyArgs>(args: SelectSubset<T, n8n_chat_historiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one N8n_chat_histories.
     * @param {n8n_chat_historiesUpsertArgs} args - Arguments to update or create a N8n_chat_histories.
     * @example
     * // Update or create a N8n_chat_histories
     * const n8n_chat_histories = await prisma.n8n_chat_histories.upsert({
     *   create: {
     *     // ... data to create a N8n_chat_histories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the N8n_chat_histories we want to update
     *   }
     * })
     */
    upsert<T extends n8n_chat_historiesUpsertArgs>(args: SelectSubset<T, n8n_chat_historiesUpsertArgs<ExtArgs>>): Prisma__n8n_chat_historiesClient<$Result.GetResult<Prisma.$n8n_chat_historiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of N8n_chat_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {n8n_chat_historiesCountArgs} args - Arguments to filter N8n_chat_histories to count.
     * @example
     * // Count the number of N8n_chat_histories
     * const count = await prisma.n8n_chat_histories.count({
     *   where: {
     *     // ... the filter for the N8n_chat_histories we want to count
     *   }
     * })
    **/
    count<T extends n8n_chat_historiesCountArgs>(
      args?: Subset<T, n8n_chat_historiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], N8n_chat_historiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a N8n_chat_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {N8n_chat_historiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends N8n_chat_historiesAggregateArgs>(args: Subset<T, N8n_chat_historiesAggregateArgs>): Prisma.PrismaPromise<GetN8n_chat_historiesAggregateType<T>>

    /**
     * Group by N8n_chat_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {n8n_chat_historiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends n8n_chat_historiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: n8n_chat_historiesGroupByArgs['orderBy'] }
        : { orderBy?: n8n_chat_historiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, n8n_chat_historiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetN8n_chat_historiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the n8n_chat_histories model
   */
  readonly fields: n8n_chat_historiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for n8n_chat_histories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__n8n_chat_historiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the n8n_chat_histories model
   */ 
  interface n8n_chat_historiesFieldRefs {
    readonly id: FieldRef<"n8n_chat_histories", 'Int'>
    readonly session_id: FieldRef<"n8n_chat_histories", 'String'>
    readonly message: FieldRef<"n8n_chat_histories", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * n8n_chat_histories findUnique
   */
  export type n8n_chat_historiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * Filter, which n8n_chat_histories to fetch.
     */
    where: n8n_chat_historiesWhereUniqueInput
  }

  /**
   * n8n_chat_histories findUniqueOrThrow
   */
  export type n8n_chat_historiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * Filter, which n8n_chat_histories to fetch.
     */
    where: n8n_chat_historiesWhereUniqueInput
  }

  /**
   * n8n_chat_histories findFirst
   */
  export type n8n_chat_historiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * Filter, which n8n_chat_histories to fetch.
     */
    where?: n8n_chat_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of n8n_chat_histories to fetch.
     */
    orderBy?: n8n_chat_historiesOrderByWithRelationInput | n8n_chat_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for n8n_chat_histories.
     */
    cursor?: n8n_chat_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` n8n_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` n8n_chat_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of n8n_chat_histories.
     */
    distinct?: N8n_chat_historiesScalarFieldEnum | N8n_chat_historiesScalarFieldEnum[]
  }

  /**
   * n8n_chat_histories findFirstOrThrow
   */
  export type n8n_chat_historiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * Filter, which n8n_chat_histories to fetch.
     */
    where?: n8n_chat_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of n8n_chat_histories to fetch.
     */
    orderBy?: n8n_chat_historiesOrderByWithRelationInput | n8n_chat_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for n8n_chat_histories.
     */
    cursor?: n8n_chat_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` n8n_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` n8n_chat_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of n8n_chat_histories.
     */
    distinct?: N8n_chat_historiesScalarFieldEnum | N8n_chat_historiesScalarFieldEnum[]
  }

  /**
   * n8n_chat_histories findMany
   */
  export type n8n_chat_historiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * Filter, which n8n_chat_histories to fetch.
     */
    where?: n8n_chat_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of n8n_chat_histories to fetch.
     */
    orderBy?: n8n_chat_historiesOrderByWithRelationInput | n8n_chat_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing n8n_chat_histories.
     */
    cursor?: n8n_chat_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` n8n_chat_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` n8n_chat_histories.
     */
    skip?: number
    distinct?: N8n_chat_historiesScalarFieldEnum | N8n_chat_historiesScalarFieldEnum[]
  }

  /**
   * n8n_chat_histories create
   */
  export type n8n_chat_historiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * The data needed to create a n8n_chat_histories.
     */
    data: XOR<n8n_chat_historiesCreateInput, n8n_chat_historiesUncheckedCreateInput>
  }

  /**
   * n8n_chat_histories createMany
   */
  export type n8n_chat_historiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many n8n_chat_histories.
     */
    data: n8n_chat_historiesCreateManyInput | n8n_chat_historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * n8n_chat_histories createManyAndReturn
   */
  export type n8n_chat_historiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many n8n_chat_histories.
     */
    data: n8n_chat_historiesCreateManyInput | n8n_chat_historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * n8n_chat_histories update
   */
  export type n8n_chat_historiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * The data needed to update a n8n_chat_histories.
     */
    data: XOR<n8n_chat_historiesUpdateInput, n8n_chat_historiesUncheckedUpdateInput>
    /**
     * Choose, which n8n_chat_histories to update.
     */
    where: n8n_chat_historiesWhereUniqueInput
  }

  /**
   * n8n_chat_histories updateMany
   */
  export type n8n_chat_historiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update n8n_chat_histories.
     */
    data: XOR<n8n_chat_historiesUpdateManyMutationInput, n8n_chat_historiesUncheckedUpdateManyInput>
    /**
     * Filter which n8n_chat_histories to update
     */
    where?: n8n_chat_historiesWhereInput
  }

  /**
   * n8n_chat_histories upsert
   */
  export type n8n_chat_historiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * The filter to search for the n8n_chat_histories to update in case it exists.
     */
    where: n8n_chat_historiesWhereUniqueInput
    /**
     * In case the n8n_chat_histories found by the `where` argument doesn't exist, create a new n8n_chat_histories with this data.
     */
    create: XOR<n8n_chat_historiesCreateInput, n8n_chat_historiesUncheckedCreateInput>
    /**
     * In case the n8n_chat_histories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<n8n_chat_historiesUpdateInput, n8n_chat_historiesUncheckedUpdateInput>
  }

  /**
   * n8n_chat_histories delete
   */
  export type n8n_chat_historiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
    /**
     * Filter which n8n_chat_histories to delete.
     */
    where: n8n_chat_historiesWhereUniqueInput
  }

  /**
   * n8n_chat_histories deleteMany
   */
  export type n8n_chat_historiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which n8n_chat_histories to delete
     */
    where?: n8n_chat_historiesWhereInput
  }

  /**
   * n8n_chat_histories without action
   */
  export type n8n_chat_historiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the n8n_chat_histories
     */
    select?: n8n_chat_historiesSelect<ExtArgs> | null
  }


  /**
   * Model pacientes
   */

  export type AggregatePacientes = {
    _count: PacientesCountAggregateOutputType | null
    _avg: PacientesAvgAggregateOutputType | null
    _sum: PacientesSumAggregateOutputType | null
    _min: PacientesMinAggregateOutputType | null
    _max: PacientesMaxAggregateOutputType | null
  }

  export type PacientesAvgAggregateOutputType = {
    id: number | null
  }

  export type PacientesSumAggregateOutputType = {
    id: number | null
  }

  export type PacientesMinAggregateOutputType = {
    id: number | null
    nome: string | null
    telefone: string | null
  }

  export type PacientesMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    telefone: string | null
  }

  export type PacientesCountAggregateOutputType = {
    id: number
    nome: number
    telefone: number
    _all: number
  }


  export type PacientesAvgAggregateInputType = {
    id?: true
  }

  export type PacientesSumAggregateInputType = {
    id?: true
  }

  export type PacientesMinAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
  }

  export type PacientesMaxAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
  }

  export type PacientesCountAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    _all?: true
  }

  export type PacientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacientes to aggregate.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pacientes
    **/
    _count?: true | PacientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacientesMaxAggregateInputType
  }

  export type GetPacientesAggregateType<T extends PacientesAggregateArgs> = {
        [P in keyof T & keyof AggregatePacientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePacientes[P]>
      : GetScalarType<T[P], AggregatePacientes[P]>
  }




  export type pacientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pacientesWhereInput
    orderBy?: pacientesOrderByWithAggregationInput | pacientesOrderByWithAggregationInput[]
    by: PacientesScalarFieldEnum[] | PacientesScalarFieldEnum
    having?: pacientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacientesCountAggregateInputType | true
    _avg?: PacientesAvgAggregateInputType
    _sum?: PacientesSumAggregateInputType
    _min?: PacientesMinAggregateInputType
    _max?: PacientesMaxAggregateInputType
  }

  export type PacientesGroupByOutputType = {
    id: number
    nome: string
    telefone: string
    _count: PacientesCountAggregateOutputType | null
    _avg: PacientesAvgAggregateOutputType | null
    _sum: PacientesSumAggregateOutputType | null
    _min: PacientesMinAggregateOutputType | null
    _max: PacientesMaxAggregateOutputType | null
  }

  type GetPacientesGroupByPayload<T extends pacientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacientesGroupByOutputType[P]>
            : GetScalarType<T[P], PacientesGroupByOutputType[P]>
        }
      >
    >


  export type pacientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    consultas?: boolean | pacientes$consultasArgs<ExtArgs>
    _count?: boolean | PacientesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pacientes"]>

  export type pacientesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
  }, ExtArgs["result"]["pacientes"]>

  export type pacientesSelectScalar = {
    id?: boolean
    nome?: boolean
    telefone?: boolean
  }

  export type pacientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultas?: boolean | pacientes$consultasArgs<ExtArgs>
    _count?: boolean | PacientesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pacientesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $pacientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pacientes"
    objects: {
      consultas: Prisma.$consultasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      telefone: string
    }, ExtArgs["result"]["pacientes"]>
    composites: {}
  }

  type pacientesGetPayload<S extends boolean | null | undefined | pacientesDefaultArgs> = $Result.GetResult<Prisma.$pacientesPayload, S>

  type pacientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pacientesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PacientesCountAggregateInputType | true
    }

  export interface pacientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pacientes'], meta: { name: 'pacientes' } }
    /**
     * Find zero or one Pacientes that matches the filter.
     * @param {pacientesFindUniqueArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pacientesFindUniqueArgs>(args: SelectSubset<T, pacientesFindUniqueArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pacientes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pacientesFindUniqueOrThrowArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pacientesFindUniqueOrThrowArgs>(args: SelectSubset<T, pacientesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesFindFirstArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pacientesFindFirstArgs>(args?: SelectSubset<T, pacientesFindFirstArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pacientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesFindFirstOrThrowArgs} args - Arguments to find a Pacientes
     * @example
     * // Get one Pacientes
     * const pacientes = await prisma.pacientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pacientesFindFirstOrThrowArgs>(args?: SelectSubset<T, pacientesFindFirstOrThrowArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pacientes
     * const pacientes = await prisma.pacientes.findMany()
     * 
     * // Get first 10 Pacientes
     * const pacientes = await prisma.pacientes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pacientesWithIdOnly = await prisma.pacientes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pacientesFindManyArgs>(args?: SelectSubset<T, pacientesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pacientes.
     * @param {pacientesCreateArgs} args - Arguments to create a Pacientes.
     * @example
     * // Create one Pacientes
     * const Pacientes = await prisma.pacientes.create({
     *   data: {
     *     // ... data to create a Pacientes
     *   }
     * })
     * 
     */
    create<T extends pacientesCreateArgs>(args: SelectSubset<T, pacientesCreateArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pacientes.
     * @param {pacientesCreateManyArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const pacientes = await prisma.pacientes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pacientesCreateManyArgs>(args?: SelectSubset<T, pacientesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pacientes and returns the data saved in the database.
     * @param {pacientesCreateManyAndReturnArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const pacientes = await prisma.pacientes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pacientes and only return the `id`
     * const pacientesWithIdOnly = await prisma.pacientes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pacientesCreateManyAndReturnArgs>(args?: SelectSubset<T, pacientesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pacientes.
     * @param {pacientesDeleteArgs} args - Arguments to delete one Pacientes.
     * @example
     * // Delete one Pacientes
     * const Pacientes = await prisma.pacientes.delete({
     *   where: {
     *     // ... filter to delete one Pacientes
     *   }
     * })
     * 
     */
    delete<T extends pacientesDeleteArgs>(args: SelectSubset<T, pacientesDeleteArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pacientes.
     * @param {pacientesUpdateArgs} args - Arguments to update one Pacientes.
     * @example
     * // Update one Pacientes
     * const pacientes = await prisma.pacientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pacientesUpdateArgs>(args: SelectSubset<T, pacientesUpdateArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pacientes.
     * @param {pacientesDeleteManyArgs} args - Arguments to filter Pacientes to delete.
     * @example
     * // Delete a few Pacientes
     * const { count } = await prisma.pacientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pacientesDeleteManyArgs>(args?: SelectSubset<T, pacientesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pacientes
     * const pacientes = await prisma.pacientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pacientesUpdateManyArgs>(args: SelectSubset<T, pacientesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pacientes.
     * @param {pacientesUpsertArgs} args - Arguments to update or create a Pacientes.
     * @example
     * // Update or create a Pacientes
     * const pacientes = await prisma.pacientes.upsert({
     *   create: {
     *     // ... data to create a Pacientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pacientes we want to update
     *   }
     * })
     */
    upsert<T extends pacientesUpsertArgs>(args: SelectSubset<T, pacientesUpsertArgs<ExtArgs>>): Prisma__pacientesClient<$Result.GetResult<Prisma.$pacientesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesCountArgs} args - Arguments to filter Pacientes to count.
     * @example
     * // Count the number of Pacientes
     * const count = await prisma.pacientes.count({
     *   where: {
     *     // ... the filter for the Pacientes we want to count
     *   }
     * })
    **/
    count<T extends pacientesCountArgs>(
      args?: Subset<T, pacientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacientesAggregateArgs>(args: Subset<T, PacientesAggregateArgs>): Prisma.PrismaPromise<GetPacientesAggregateType<T>>

    /**
     * Group by Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pacientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pacientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pacientesGroupByArgs['orderBy'] }
        : { orderBy?: pacientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pacientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pacientes model
   */
  readonly fields: pacientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pacientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pacientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultas<T extends pacientes$consultasArgs<ExtArgs> = {}>(args?: Subset<T, pacientes$consultasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pacientes model
   */ 
  interface pacientesFieldRefs {
    readonly id: FieldRef<"pacientes", 'Int'>
    readonly nome: FieldRef<"pacientes", 'String'>
    readonly telefone: FieldRef<"pacientes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pacientes findUnique
   */
  export type pacientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes findUniqueOrThrow
   */
  export type pacientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes findFirst
   */
  export type pacientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacientes.
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacientes.
     */
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * pacientes findFirstOrThrow
   */
  export type pacientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pacientes.
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pacientes.
     */
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * pacientes findMany
   */
  export type pacientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter, which pacientes to fetch.
     */
    where?: pacientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pacientes to fetch.
     */
    orderBy?: pacientesOrderByWithRelationInput | pacientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pacientes.
     */
    cursor?: pacientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pacientes.
     */
    skip?: number
    distinct?: PacientesScalarFieldEnum | PacientesScalarFieldEnum[]
  }

  /**
   * pacientes create
   */
  export type pacientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * The data needed to create a pacientes.
     */
    data: XOR<pacientesCreateInput, pacientesUncheckedCreateInput>
  }

  /**
   * pacientes createMany
   */
  export type pacientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pacientes.
     */
    data: pacientesCreateManyInput | pacientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pacientes createManyAndReturn
   */
  export type pacientesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pacientes.
     */
    data: pacientesCreateManyInput | pacientesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pacientes update
   */
  export type pacientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * The data needed to update a pacientes.
     */
    data: XOR<pacientesUpdateInput, pacientesUncheckedUpdateInput>
    /**
     * Choose, which pacientes to update.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes updateMany
   */
  export type pacientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pacientes.
     */
    data: XOR<pacientesUpdateManyMutationInput, pacientesUncheckedUpdateManyInput>
    /**
     * Filter which pacientes to update
     */
    where?: pacientesWhereInput
  }

  /**
   * pacientes upsert
   */
  export type pacientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * The filter to search for the pacientes to update in case it exists.
     */
    where: pacientesWhereUniqueInput
    /**
     * In case the pacientes found by the `where` argument doesn't exist, create a new pacientes with this data.
     */
    create: XOR<pacientesCreateInput, pacientesUncheckedCreateInput>
    /**
     * In case the pacientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pacientesUpdateInput, pacientesUncheckedUpdateInput>
  }

  /**
   * pacientes delete
   */
  export type pacientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
    /**
     * Filter which pacientes to delete.
     */
    where: pacientesWhereUniqueInput
  }

  /**
   * pacientes deleteMany
   */
  export type pacientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pacientes to delete
     */
    where?: pacientesWhereInput
  }

  /**
   * pacientes.consultas
   */
  export type pacientes$consultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consultasInclude<ExtArgs> | null
    where?: consultasWhereInput
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    cursor?: consultasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * pacientes without action
   */
  export type pacientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pacientes
     */
    select?: pacientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pacientesInclude<ExtArgs> | null
  }


  /**
   * Model procedimentos
   */

  export type AggregateProcedimentos = {
    _count: ProcedimentosCountAggregateOutputType | null
    _avg: ProcedimentosAvgAggregateOutputType | null
    _sum: ProcedimentosSumAggregateOutputType | null
    _min: ProcedimentosMinAggregateOutputType | null
    _max: ProcedimentosMaxAggregateOutputType | null
  }

  export type ProcedimentosAvgAggregateOutputType = {
    id: number | null
    preco: Decimal | null
  }

  export type ProcedimentosSumAggregateOutputType = {
    id: number | null
    preco: Decimal | null
  }

  export type ProcedimentosMinAggregateOutputType = {
    id: number | null
    nome: string | null
    preco: Decimal | null
    tempo_estimado: string | null
    descricao: string | null
  }

  export type ProcedimentosMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    preco: Decimal | null
    tempo_estimado: string | null
    descricao: string | null
  }

  export type ProcedimentosCountAggregateOutputType = {
    id: number
    nome: number
    preco: number
    tempo_estimado: number
    descricao: number
    _all: number
  }


  export type ProcedimentosAvgAggregateInputType = {
    id?: true
    preco?: true
  }

  export type ProcedimentosSumAggregateInputType = {
    id?: true
    preco?: true
  }

  export type ProcedimentosMinAggregateInputType = {
    id?: true
    nome?: true
    preco?: true
    tempo_estimado?: true
    descricao?: true
  }

  export type ProcedimentosMaxAggregateInputType = {
    id?: true
    nome?: true
    preco?: true
    tempo_estimado?: true
    descricao?: true
  }

  export type ProcedimentosCountAggregateInputType = {
    id?: true
    nome?: true
    preco?: true
    tempo_estimado?: true
    descricao?: true
    _all?: true
  }

  export type ProcedimentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which procedimentos to aggregate.
     */
    where?: procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procedimentos to fetch.
     */
    orderBy?: procedimentosOrderByWithRelationInput | procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned procedimentos
    **/
    _count?: true | ProcedimentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedimentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedimentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedimentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedimentosMaxAggregateInputType
  }

  export type GetProcedimentosAggregateType<T extends ProcedimentosAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedimentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedimentos[P]>
      : GetScalarType<T[P], AggregateProcedimentos[P]>
  }




  export type procedimentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: procedimentosWhereInput
    orderBy?: procedimentosOrderByWithAggregationInput | procedimentosOrderByWithAggregationInput[]
    by: ProcedimentosScalarFieldEnum[] | ProcedimentosScalarFieldEnum
    having?: procedimentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedimentosCountAggregateInputType | true
    _avg?: ProcedimentosAvgAggregateInputType
    _sum?: ProcedimentosSumAggregateInputType
    _min?: ProcedimentosMinAggregateInputType
    _max?: ProcedimentosMaxAggregateInputType
  }

  export type ProcedimentosGroupByOutputType = {
    id: number
    nome: string
    preco: Decimal | null
    tempo_estimado: string | null
    descricao: string | null
    _count: ProcedimentosCountAggregateOutputType | null
    _avg: ProcedimentosAvgAggregateOutputType | null
    _sum: ProcedimentosSumAggregateOutputType | null
    _min: ProcedimentosMinAggregateOutputType | null
    _max: ProcedimentosMaxAggregateOutputType | null
  }

  type GetProcedimentosGroupByPayload<T extends procedimentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedimentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedimentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedimentosGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedimentosGroupByOutputType[P]>
        }
      >
    >


  export type procedimentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    preco?: boolean
    tempo_estimado?: boolean
    descricao?: boolean
    medico_procedimentos?: boolean | procedimentos$medico_procedimentosArgs<ExtArgs>
    _count?: boolean | ProcedimentosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedimentos"]>

  export type procedimentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    preco?: boolean
    tempo_estimado?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["procedimentos"]>

  export type procedimentosSelectScalar = {
    id?: boolean
    nome?: boolean
    preco?: boolean
    tempo_estimado?: boolean
    descricao?: boolean
  }

  export type procedimentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medico_procedimentos?: boolean | procedimentos$medico_procedimentosArgs<ExtArgs>
    _count?: boolean | ProcedimentosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type procedimentosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $procedimentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "procedimentos"
    objects: {
      medico_procedimentos: Prisma.$medico_procedimentosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      preco: Prisma.Decimal | null
      tempo_estimado: string | null
      descricao: string | null
    }, ExtArgs["result"]["procedimentos"]>
    composites: {}
  }

  type procedimentosGetPayload<S extends boolean | null | undefined | procedimentosDefaultArgs> = $Result.GetResult<Prisma.$procedimentosPayload, S>

  type procedimentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<procedimentosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedimentosCountAggregateInputType | true
    }

  export interface procedimentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['procedimentos'], meta: { name: 'procedimentos' } }
    /**
     * Find zero or one Procedimentos that matches the filter.
     * @param {procedimentosFindUniqueArgs} args - Arguments to find a Procedimentos
     * @example
     * // Get one Procedimentos
     * const procedimentos = await prisma.procedimentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends procedimentosFindUniqueArgs>(args: SelectSubset<T, procedimentosFindUniqueArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Procedimentos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {procedimentosFindUniqueOrThrowArgs} args - Arguments to find a Procedimentos
     * @example
     * // Get one Procedimentos
     * const procedimentos = await prisma.procedimentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends procedimentosFindUniqueOrThrowArgs>(args: SelectSubset<T, procedimentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Procedimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procedimentosFindFirstArgs} args - Arguments to find a Procedimentos
     * @example
     * // Get one Procedimentos
     * const procedimentos = await prisma.procedimentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends procedimentosFindFirstArgs>(args?: SelectSubset<T, procedimentosFindFirstArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Procedimentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procedimentosFindFirstOrThrowArgs} args - Arguments to find a Procedimentos
     * @example
     * // Get one Procedimentos
     * const procedimentos = await prisma.procedimentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends procedimentosFindFirstOrThrowArgs>(args?: SelectSubset<T, procedimentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procedimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procedimentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedimentos
     * const procedimentos = await prisma.procedimentos.findMany()
     * 
     * // Get first 10 Procedimentos
     * const procedimentos = await prisma.procedimentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procedimentosWithIdOnly = await prisma.procedimentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends procedimentosFindManyArgs>(args?: SelectSubset<T, procedimentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Procedimentos.
     * @param {procedimentosCreateArgs} args - Arguments to create a Procedimentos.
     * @example
     * // Create one Procedimentos
     * const Procedimentos = await prisma.procedimentos.create({
     *   data: {
     *     // ... data to create a Procedimentos
     *   }
     * })
     * 
     */
    create<T extends procedimentosCreateArgs>(args: SelectSubset<T, procedimentosCreateArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procedimentos.
     * @param {procedimentosCreateManyArgs} args - Arguments to create many Procedimentos.
     * @example
     * // Create many Procedimentos
     * const procedimentos = await prisma.procedimentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends procedimentosCreateManyArgs>(args?: SelectSubset<T, procedimentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procedimentos and returns the data saved in the database.
     * @param {procedimentosCreateManyAndReturnArgs} args - Arguments to create many Procedimentos.
     * @example
     * // Create many Procedimentos
     * const procedimentos = await prisma.procedimentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procedimentos and only return the `id`
     * const procedimentosWithIdOnly = await prisma.procedimentos.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends procedimentosCreateManyAndReturnArgs>(args?: SelectSubset<T, procedimentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Procedimentos.
     * @param {procedimentosDeleteArgs} args - Arguments to delete one Procedimentos.
     * @example
     * // Delete one Procedimentos
     * const Procedimentos = await prisma.procedimentos.delete({
     *   where: {
     *     // ... filter to delete one Procedimentos
     *   }
     * })
     * 
     */
    delete<T extends procedimentosDeleteArgs>(args: SelectSubset<T, procedimentosDeleteArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Procedimentos.
     * @param {procedimentosUpdateArgs} args - Arguments to update one Procedimentos.
     * @example
     * // Update one Procedimentos
     * const procedimentos = await prisma.procedimentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends procedimentosUpdateArgs>(args: SelectSubset<T, procedimentosUpdateArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procedimentos.
     * @param {procedimentosDeleteManyArgs} args - Arguments to filter Procedimentos to delete.
     * @example
     * // Delete a few Procedimentos
     * const { count } = await prisma.procedimentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends procedimentosDeleteManyArgs>(args?: SelectSubset<T, procedimentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procedimentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedimentos
     * const procedimentos = await prisma.procedimentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends procedimentosUpdateManyArgs>(args: SelectSubset<T, procedimentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procedimentos.
     * @param {procedimentosUpsertArgs} args - Arguments to update or create a Procedimentos.
     * @example
     * // Update or create a Procedimentos
     * const procedimentos = await prisma.procedimentos.upsert({
     *   create: {
     *     // ... data to create a Procedimentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedimentos we want to update
     *   }
     * })
     */
    upsert<T extends procedimentosUpsertArgs>(args: SelectSubset<T, procedimentosUpsertArgs<ExtArgs>>): Prisma__procedimentosClient<$Result.GetResult<Prisma.$procedimentosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procedimentosCountArgs} args - Arguments to filter Procedimentos to count.
     * @example
     * // Count the number of Procedimentos
     * const count = await prisma.procedimentos.count({
     *   where: {
     *     // ... the filter for the Procedimentos we want to count
     *   }
     * })
    **/
    count<T extends procedimentosCountArgs>(
      args?: Subset<T, procedimentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedimentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedimentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedimentosAggregateArgs>(args: Subset<T, ProcedimentosAggregateArgs>): Prisma.PrismaPromise<GetProcedimentosAggregateType<T>>

    /**
     * Group by Procedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {procedimentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends procedimentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: procedimentosGroupByArgs['orderBy'] }
        : { orderBy?: procedimentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, procedimentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedimentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the procedimentos model
   */
  readonly fields: procedimentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for procedimentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__procedimentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medico_procedimentos<T extends procedimentos$medico_procedimentosArgs<ExtArgs> = {}>(args?: Subset<T, procedimentos$medico_procedimentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_procedimentosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the procedimentos model
   */ 
  interface procedimentosFieldRefs {
    readonly id: FieldRef<"procedimentos", 'Int'>
    readonly nome: FieldRef<"procedimentos", 'String'>
    readonly preco: FieldRef<"procedimentos", 'Decimal'>
    readonly tempo_estimado: FieldRef<"procedimentos", 'String'>
    readonly descricao: FieldRef<"procedimentos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * procedimentos findUnique
   */
  export type procedimentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which procedimentos to fetch.
     */
    where: procedimentosWhereUniqueInput
  }

  /**
   * procedimentos findUniqueOrThrow
   */
  export type procedimentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which procedimentos to fetch.
     */
    where: procedimentosWhereUniqueInput
  }

  /**
   * procedimentos findFirst
   */
  export type procedimentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which procedimentos to fetch.
     */
    where?: procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procedimentos to fetch.
     */
    orderBy?: procedimentosOrderByWithRelationInput | procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for procedimentos.
     */
    cursor?: procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of procedimentos.
     */
    distinct?: ProcedimentosScalarFieldEnum | ProcedimentosScalarFieldEnum[]
  }

  /**
   * procedimentos findFirstOrThrow
   */
  export type procedimentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which procedimentos to fetch.
     */
    where?: procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procedimentos to fetch.
     */
    orderBy?: procedimentosOrderByWithRelationInput | procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for procedimentos.
     */
    cursor?: procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of procedimentos.
     */
    distinct?: ProcedimentosScalarFieldEnum | ProcedimentosScalarFieldEnum[]
  }

  /**
   * procedimentos findMany
   */
  export type procedimentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * Filter, which procedimentos to fetch.
     */
    where?: procedimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of procedimentos to fetch.
     */
    orderBy?: procedimentosOrderByWithRelationInput | procedimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing procedimentos.
     */
    cursor?: procedimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` procedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` procedimentos.
     */
    skip?: number
    distinct?: ProcedimentosScalarFieldEnum | ProcedimentosScalarFieldEnum[]
  }

  /**
   * procedimentos create
   */
  export type procedimentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * The data needed to create a procedimentos.
     */
    data: XOR<procedimentosCreateInput, procedimentosUncheckedCreateInput>
  }

  /**
   * procedimentos createMany
   */
  export type procedimentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many procedimentos.
     */
    data: procedimentosCreateManyInput | procedimentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * procedimentos createManyAndReturn
   */
  export type procedimentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many procedimentos.
     */
    data: procedimentosCreateManyInput | procedimentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * procedimentos update
   */
  export type procedimentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * The data needed to update a procedimentos.
     */
    data: XOR<procedimentosUpdateInput, procedimentosUncheckedUpdateInput>
    /**
     * Choose, which procedimentos to update.
     */
    where: procedimentosWhereUniqueInput
  }

  /**
   * procedimentos updateMany
   */
  export type procedimentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update procedimentos.
     */
    data: XOR<procedimentosUpdateManyMutationInput, procedimentosUncheckedUpdateManyInput>
    /**
     * Filter which procedimentos to update
     */
    where?: procedimentosWhereInput
  }

  /**
   * procedimentos upsert
   */
  export type procedimentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * The filter to search for the procedimentos to update in case it exists.
     */
    where: procedimentosWhereUniqueInput
    /**
     * In case the procedimentos found by the `where` argument doesn't exist, create a new procedimentos with this data.
     */
    create: XOR<procedimentosCreateInput, procedimentosUncheckedCreateInput>
    /**
     * In case the procedimentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<procedimentosUpdateInput, procedimentosUncheckedUpdateInput>
  }

  /**
   * procedimentos delete
   */
  export type procedimentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
    /**
     * Filter which procedimentos to delete.
     */
    where: procedimentosWhereUniqueInput
  }

  /**
   * procedimentos deleteMany
   */
  export type procedimentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which procedimentos to delete
     */
    where?: procedimentosWhereInput
  }

  /**
   * procedimentos.medico_procedimentos
   */
  export type procedimentos$medico_procedimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_procedimentos
     */
    select?: medico_procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_procedimentosInclude<ExtArgs> | null
    where?: medico_procedimentosWhereInput
    orderBy?: medico_procedimentosOrderByWithRelationInput | medico_procedimentosOrderByWithRelationInput[]
    cursor?: medico_procedimentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medico_procedimentosScalarFieldEnum | Medico_procedimentosScalarFieldEnum[]
  }

  /**
   * procedimentos without action
   */
  export type procedimentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the procedimentos
     */
    select?: procedimentosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: procedimentosInclude<ExtArgs> | null
  }


  /**
   * Model schema_migrations
   */

  export type AggregateSchema_migrations = {
    _count: Schema_migrationsCountAggregateOutputType | null
    _min: Schema_migrationsMinAggregateOutputType | null
    _max: Schema_migrationsMaxAggregateOutputType | null
  }

  export type Schema_migrationsMinAggregateOutputType = {
    version: string | null
  }

  export type Schema_migrationsMaxAggregateOutputType = {
    version: string | null
  }

  export type Schema_migrationsCountAggregateOutputType = {
    version: number
    _all: number
  }


  export type Schema_migrationsMinAggregateInputType = {
    version?: true
  }

  export type Schema_migrationsMaxAggregateInputType = {
    version?: true
  }

  export type Schema_migrationsCountAggregateInputType = {
    version?: true
    _all?: true
  }

  export type Schema_migrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_migrations to aggregate.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schema_migrations
    **/
    _count?: true | Schema_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Schema_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Schema_migrationsMaxAggregateInputType
  }

  export type GetSchema_migrationsAggregateType<T extends Schema_migrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSchema_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchema_migrations[P]>
      : GetScalarType<T[P], AggregateSchema_migrations[P]>
  }




  export type schema_migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schema_migrationsWhereInput
    orderBy?: schema_migrationsOrderByWithAggregationInput | schema_migrationsOrderByWithAggregationInput[]
    by: Schema_migrationsScalarFieldEnum[] | Schema_migrationsScalarFieldEnum
    having?: schema_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Schema_migrationsCountAggregateInputType | true
    _min?: Schema_migrationsMinAggregateInputType
    _max?: Schema_migrationsMaxAggregateInputType
  }

  export type Schema_migrationsGroupByOutputType = {
    version: string
    _count: Schema_migrationsCountAggregateOutputType | null
    _min: Schema_migrationsMinAggregateOutputType | null
    _max: Schema_migrationsMaxAggregateOutputType | null
  }

  type GetSchema_migrationsGroupByPayload<T extends schema_migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Schema_migrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Schema_migrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Schema_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Schema_migrationsGroupByOutputType[P]>
        }
      >
    >


  export type schema_migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectScalar = {
    version?: boolean
  }


  export type $schema_migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schema_migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: string
    }, ExtArgs["result"]["schema_migrations"]>
    composites: {}
  }

  type schema_migrationsGetPayload<S extends boolean | null | undefined | schema_migrationsDefaultArgs> = $Result.GetResult<Prisma.$schema_migrationsPayload, S>

  type schema_migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<schema_migrationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Schema_migrationsCountAggregateInputType | true
    }

  export interface schema_migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schema_migrations'], meta: { name: 'schema_migrations' } }
    /**
     * Find zero or one Schema_migrations that matches the filter.
     * @param {schema_migrationsFindUniqueArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends schema_migrationsFindUniqueArgs>(args: SelectSubset<T, schema_migrationsFindUniqueArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schema_migrations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {schema_migrationsFindUniqueOrThrowArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends schema_migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, schema_migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schema_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindFirstArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends schema_migrationsFindFirstArgs>(args?: SelectSubset<T, schema_migrationsFindFirstArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schema_migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindFirstOrThrowArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends schema_migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, schema_migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schema_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findMany()
     * 
     * // Get first 10 Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.findMany({ select: { version: true } })
     * 
     */
    findMany<T extends schema_migrationsFindManyArgs>(args?: SelectSubset<T, schema_migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schema_migrations.
     * @param {schema_migrationsCreateArgs} args - Arguments to create a Schema_migrations.
     * @example
     * // Create one Schema_migrations
     * const Schema_migrations = await prisma.schema_migrations.create({
     *   data: {
     *     // ... data to create a Schema_migrations
     *   }
     * })
     * 
     */
    create<T extends schema_migrationsCreateArgs>(args: SelectSubset<T, schema_migrationsCreateArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schema_migrations.
     * @param {schema_migrationsCreateManyArgs} args - Arguments to create many Schema_migrations.
     * @example
     * // Create many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends schema_migrationsCreateManyArgs>(args?: SelectSubset<T, schema_migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schema_migrations and returns the data saved in the database.
     * @param {schema_migrationsCreateManyAndReturnArgs} args - Arguments to create many Schema_migrations.
     * @example
     * // Create many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schema_migrations and only return the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.createManyAndReturn({ 
     *   select: { version: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends schema_migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, schema_migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Schema_migrations.
     * @param {schema_migrationsDeleteArgs} args - Arguments to delete one Schema_migrations.
     * @example
     * // Delete one Schema_migrations
     * const Schema_migrations = await prisma.schema_migrations.delete({
     *   where: {
     *     // ... filter to delete one Schema_migrations
     *   }
     * })
     * 
     */
    delete<T extends schema_migrationsDeleteArgs>(args: SelectSubset<T, schema_migrationsDeleteArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schema_migrations.
     * @param {schema_migrationsUpdateArgs} args - Arguments to update one Schema_migrations.
     * @example
     * // Update one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends schema_migrationsUpdateArgs>(args: SelectSubset<T, schema_migrationsUpdateArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schema_migrations.
     * @param {schema_migrationsDeleteManyArgs} args - Arguments to filter Schema_migrations to delete.
     * @example
     * // Delete a few Schema_migrations
     * const { count } = await prisma.schema_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends schema_migrationsDeleteManyArgs>(args?: SelectSubset<T, schema_migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends schema_migrationsUpdateManyArgs>(args: SelectSubset<T, schema_migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schema_migrations.
     * @param {schema_migrationsUpsertArgs} args - Arguments to update or create a Schema_migrations.
     * @example
     * // Update or create a Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.upsert({
     *   create: {
     *     // ... data to create a Schema_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schema_migrations we want to update
     *   }
     * })
     */
    upsert<T extends schema_migrationsUpsertArgs>(args: SelectSubset<T, schema_migrationsUpsertArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsCountArgs} args - Arguments to filter Schema_migrations to count.
     * @example
     * // Count the number of Schema_migrations
     * const count = await prisma.schema_migrations.count({
     *   where: {
     *     // ... the filter for the Schema_migrations we want to count
     *   }
     * })
    **/
    count<T extends schema_migrationsCountArgs>(
      args?: Subset<T, schema_migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Schema_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Schema_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Schema_migrationsAggregateArgs>(args: Subset<T, Schema_migrationsAggregateArgs>): Prisma.PrismaPromise<GetSchema_migrationsAggregateType<T>>

    /**
     * Group by Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schema_migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schema_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: schema_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schema_migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchema_migrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schema_migrations model
   */
  readonly fields: schema_migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schema_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schema_migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schema_migrations model
   */ 
  interface schema_migrationsFieldRefs {
    readonly version: FieldRef<"schema_migrations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * schema_migrations findUnique
   */
  export type schema_migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations findUniqueOrThrow
   */
  export type schema_migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations findFirst
   */
  export type schema_migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_migrations.
     */
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations findFirstOrThrow
   */
  export type schema_migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_migrations.
     */
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations findMany
   */
  export type schema_migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations create
   */
  export type schema_migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * The data needed to create a schema_migrations.
     */
    data: XOR<schema_migrationsCreateInput, schema_migrationsUncheckedCreateInput>
  }

  /**
   * schema_migrations createMany
   */
  export type schema_migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schema_migrations.
     */
    data: schema_migrationsCreateManyInput | schema_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_migrations createManyAndReturn
   */
  export type schema_migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many schema_migrations.
     */
    data: schema_migrationsCreateManyInput | schema_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_migrations update
   */
  export type schema_migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * The data needed to update a schema_migrations.
     */
    data: XOR<schema_migrationsUpdateInput, schema_migrationsUncheckedUpdateInput>
    /**
     * Choose, which schema_migrations to update.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations updateMany
   */
  export type schema_migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schema_migrations.
     */
    data: XOR<schema_migrationsUpdateManyMutationInput, schema_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which schema_migrations to update
     */
    where?: schema_migrationsWhereInput
  }

  /**
   * schema_migrations upsert
   */
  export type schema_migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * The filter to search for the schema_migrations to update in case it exists.
     */
    where: schema_migrationsWhereUniqueInput
    /**
     * In case the schema_migrations found by the `where` argument doesn't exist, create a new schema_migrations with this data.
     */
    create: XOR<schema_migrationsCreateInput, schema_migrationsUncheckedCreateInput>
    /**
     * In case the schema_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schema_migrationsUpdateInput, schema_migrationsUncheckedUpdateInput>
  }

  /**
   * schema_migrations delete
   */
  export type schema_migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Filter which schema_migrations to delete.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations deleteMany
   */
  export type schema_migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_migrations to delete
     */
    where?: schema_migrationsWhereInput
  }

  /**
   * schema_migrations without action
   */
  export type schema_migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
  }


  /**
   * Model sintomas
   */

  export type AggregateSintomas = {
    _count: SintomasCountAggregateOutputType | null
    _avg: SintomasAvgAggregateOutputType | null
    _sum: SintomasSumAggregateOutputType | null
    _min: SintomasMinAggregateOutputType | null
    _max: SintomasMaxAggregateOutputType | null
  }

  export type SintomasAvgAggregateOutputType = {
    id: number | null
  }

  export type SintomasSumAggregateOutputType = {
    id: number | null
  }

  export type SintomasMinAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
  }

  export type SintomasMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
  }

  export type SintomasCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    _all: number
  }


  export type SintomasAvgAggregateInputType = {
    id?: true
  }

  export type SintomasSumAggregateInputType = {
    id?: true
  }

  export type SintomasMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type SintomasMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type SintomasCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    _all?: true
  }

  export type SintomasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sintomas to aggregate.
     */
    where?: sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sintomas to fetch.
     */
    orderBy?: sintomasOrderByWithRelationInput | sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sintomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sintomas
    **/
    _count?: true | SintomasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SintomasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SintomasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SintomasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SintomasMaxAggregateInputType
  }

  export type GetSintomasAggregateType<T extends SintomasAggregateArgs> = {
        [P in keyof T & keyof AggregateSintomas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSintomas[P]>
      : GetScalarType<T[P], AggregateSintomas[P]>
  }




  export type sintomasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sintomasWhereInput
    orderBy?: sintomasOrderByWithAggregationInput | sintomasOrderByWithAggregationInput[]
    by: SintomasScalarFieldEnum[] | SintomasScalarFieldEnum
    having?: sintomasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SintomasCountAggregateInputType | true
    _avg?: SintomasAvgAggregateInputType
    _sum?: SintomasSumAggregateInputType
    _min?: SintomasMinAggregateInputType
    _max?: SintomasMaxAggregateInputType
  }

  export type SintomasGroupByOutputType = {
    id: number
    nome: string
    descricao: string | null
    _count: SintomasCountAggregateOutputType | null
    _avg: SintomasAvgAggregateOutputType | null
    _sum: SintomasSumAggregateOutputType | null
    _min: SintomasMinAggregateOutputType | null
    _max: SintomasMaxAggregateOutputType | null
  }

  type GetSintomasGroupByPayload<T extends sintomasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SintomasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SintomasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SintomasGroupByOutputType[P]>
            : GetScalarType<T[P], SintomasGroupByOutputType[P]>
        }
      >
    >


  export type sintomasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    medico_sintomas?: boolean | sintomas$medico_sintomasArgs<ExtArgs>
    _count?: boolean | SintomasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sintomas"]>

  export type sintomasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["sintomas"]>

  export type sintomasSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }

  export type sintomasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medico_sintomas?: boolean | sintomas$medico_sintomasArgs<ExtArgs>
    _count?: boolean | SintomasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sintomasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $sintomasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sintomas"
    objects: {
      medico_sintomas: Prisma.$medico_sintomasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      descricao: string | null
    }, ExtArgs["result"]["sintomas"]>
    composites: {}
  }

  type sintomasGetPayload<S extends boolean | null | undefined | sintomasDefaultArgs> = $Result.GetResult<Prisma.$sintomasPayload, S>

  type sintomasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sintomasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SintomasCountAggregateInputType | true
    }

  export interface sintomasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sintomas'], meta: { name: 'sintomas' } }
    /**
     * Find zero or one Sintomas that matches the filter.
     * @param {sintomasFindUniqueArgs} args - Arguments to find a Sintomas
     * @example
     * // Get one Sintomas
     * const sintomas = await prisma.sintomas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sintomasFindUniqueArgs>(args: SelectSubset<T, sintomasFindUniqueArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sintomas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sintomasFindUniqueOrThrowArgs} args - Arguments to find a Sintomas
     * @example
     * // Get one Sintomas
     * const sintomas = await prisma.sintomas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sintomasFindUniqueOrThrowArgs>(args: SelectSubset<T, sintomasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sintomas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sintomasFindFirstArgs} args - Arguments to find a Sintomas
     * @example
     * // Get one Sintomas
     * const sintomas = await prisma.sintomas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sintomasFindFirstArgs>(args?: SelectSubset<T, sintomasFindFirstArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sintomas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sintomasFindFirstOrThrowArgs} args - Arguments to find a Sintomas
     * @example
     * // Get one Sintomas
     * const sintomas = await prisma.sintomas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sintomasFindFirstOrThrowArgs>(args?: SelectSubset<T, sintomasFindFirstOrThrowArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sintomas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sintomasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sintomas
     * const sintomas = await prisma.sintomas.findMany()
     * 
     * // Get first 10 Sintomas
     * const sintomas = await prisma.sintomas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sintomasWithIdOnly = await prisma.sintomas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sintomasFindManyArgs>(args?: SelectSubset<T, sintomasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sintomas.
     * @param {sintomasCreateArgs} args - Arguments to create a Sintomas.
     * @example
     * // Create one Sintomas
     * const Sintomas = await prisma.sintomas.create({
     *   data: {
     *     // ... data to create a Sintomas
     *   }
     * })
     * 
     */
    create<T extends sintomasCreateArgs>(args: SelectSubset<T, sintomasCreateArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sintomas.
     * @param {sintomasCreateManyArgs} args - Arguments to create many Sintomas.
     * @example
     * // Create many Sintomas
     * const sintomas = await prisma.sintomas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sintomasCreateManyArgs>(args?: SelectSubset<T, sintomasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sintomas and returns the data saved in the database.
     * @param {sintomasCreateManyAndReturnArgs} args - Arguments to create many Sintomas.
     * @example
     * // Create many Sintomas
     * const sintomas = await prisma.sintomas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sintomas and only return the `id`
     * const sintomasWithIdOnly = await prisma.sintomas.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sintomasCreateManyAndReturnArgs>(args?: SelectSubset<T, sintomasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sintomas.
     * @param {sintomasDeleteArgs} args - Arguments to delete one Sintomas.
     * @example
     * // Delete one Sintomas
     * const Sintomas = await prisma.sintomas.delete({
     *   where: {
     *     // ... filter to delete one Sintomas
     *   }
     * })
     * 
     */
    delete<T extends sintomasDeleteArgs>(args: SelectSubset<T, sintomasDeleteArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sintomas.
     * @param {sintomasUpdateArgs} args - Arguments to update one Sintomas.
     * @example
     * // Update one Sintomas
     * const sintomas = await prisma.sintomas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sintomasUpdateArgs>(args: SelectSubset<T, sintomasUpdateArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sintomas.
     * @param {sintomasDeleteManyArgs} args - Arguments to filter Sintomas to delete.
     * @example
     * // Delete a few Sintomas
     * const { count } = await prisma.sintomas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sintomasDeleteManyArgs>(args?: SelectSubset<T, sintomasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sintomasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sintomas
     * const sintomas = await prisma.sintomas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sintomasUpdateManyArgs>(args: SelectSubset<T, sintomasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sintomas.
     * @param {sintomasUpsertArgs} args - Arguments to update or create a Sintomas.
     * @example
     * // Update or create a Sintomas
     * const sintomas = await prisma.sintomas.upsert({
     *   create: {
     *     // ... data to create a Sintomas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sintomas we want to update
     *   }
     * })
     */
    upsert<T extends sintomasUpsertArgs>(args: SelectSubset<T, sintomasUpsertArgs<ExtArgs>>): Prisma__sintomasClient<$Result.GetResult<Prisma.$sintomasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sintomasCountArgs} args - Arguments to filter Sintomas to count.
     * @example
     * // Count the number of Sintomas
     * const count = await prisma.sintomas.count({
     *   where: {
     *     // ... the filter for the Sintomas we want to count
     *   }
     * })
    **/
    count<T extends sintomasCountArgs>(
      args?: Subset<T, sintomasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SintomasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SintomasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SintomasAggregateArgs>(args: Subset<T, SintomasAggregateArgs>): Prisma.PrismaPromise<GetSintomasAggregateType<T>>

    /**
     * Group by Sintomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sintomasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sintomasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sintomasGroupByArgs['orderBy'] }
        : { orderBy?: sintomasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sintomasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSintomasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sintomas model
   */
  readonly fields: sintomasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sintomas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sintomasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medico_sintomas<T extends sintomas$medico_sintomasArgs<ExtArgs> = {}>(args?: Subset<T, sintomas$medico_sintomasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medico_sintomasPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sintomas model
   */ 
  interface sintomasFieldRefs {
    readonly id: FieldRef<"sintomas", 'Int'>
    readonly nome: FieldRef<"sintomas", 'String'>
    readonly descricao: FieldRef<"sintomas", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sintomas findUnique
   */
  export type sintomasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * Filter, which sintomas to fetch.
     */
    where: sintomasWhereUniqueInput
  }

  /**
   * sintomas findUniqueOrThrow
   */
  export type sintomasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * Filter, which sintomas to fetch.
     */
    where: sintomasWhereUniqueInput
  }

  /**
   * sintomas findFirst
   */
  export type sintomasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * Filter, which sintomas to fetch.
     */
    where?: sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sintomas to fetch.
     */
    orderBy?: sintomasOrderByWithRelationInput | sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sintomas.
     */
    cursor?: sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sintomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sintomas.
     */
    distinct?: SintomasScalarFieldEnum | SintomasScalarFieldEnum[]
  }

  /**
   * sintomas findFirstOrThrow
   */
  export type sintomasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * Filter, which sintomas to fetch.
     */
    where?: sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sintomas to fetch.
     */
    orderBy?: sintomasOrderByWithRelationInput | sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sintomas.
     */
    cursor?: sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sintomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sintomas.
     */
    distinct?: SintomasScalarFieldEnum | SintomasScalarFieldEnum[]
  }

  /**
   * sintomas findMany
   */
  export type sintomasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * Filter, which sintomas to fetch.
     */
    where?: sintomasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sintomas to fetch.
     */
    orderBy?: sintomasOrderByWithRelationInput | sintomasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sintomas.
     */
    cursor?: sintomasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sintomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sintomas.
     */
    skip?: number
    distinct?: SintomasScalarFieldEnum | SintomasScalarFieldEnum[]
  }

  /**
   * sintomas create
   */
  export type sintomasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * The data needed to create a sintomas.
     */
    data: XOR<sintomasCreateInput, sintomasUncheckedCreateInput>
  }

  /**
   * sintomas createMany
   */
  export type sintomasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sintomas.
     */
    data: sintomasCreateManyInput | sintomasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sintomas createManyAndReturn
   */
  export type sintomasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many sintomas.
     */
    data: sintomasCreateManyInput | sintomasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sintomas update
   */
  export type sintomasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * The data needed to update a sintomas.
     */
    data: XOR<sintomasUpdateInput, sintomasUncheckedUpdateInput>
    /**
     * Choose, which sintomas to update.
     */
    where: sintomasWhereUniqueInput
  }

  /**
   * sintomas updateMany
   */
  export type sintomasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sintomas.
     */
    data: XOR<sintomasUpdateManyMutationInput, sintomasUncheckedUpdateManyInput>
    /**
     * Filter which sintomas to update
     */
    where?: sintomasWhereInput
  }

  /**
   * sintomas upsert
   */
  export type sintomasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * The filter to search for the sintomas to update in case it exists.
     */
    where: sintomasWhereUniqueInput
    /**
     * In case the sintomas found by the `where` argument doesn't exist, create a new sintomas with this data.
     */
    create: XOR<sintomasCreateInput, sintomasUncheckedCreateInput>
    /**
     * In case the sintomas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sintomasUpdateInput, sintomasUncheckedUpdateInput>
  }

  /**
   * sintomas delete
   */
  export type sintomasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
    /**
     * Filter which sintomas to delete.
     */
    where: sintomasWhereUniqueInput
  }

  /**
   * sintomas deleteMany
   */
  export type sintomasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sintomas to delete
     */
    where?: sintomasWhereInput
  }

  /**
   * sintomas.medico_sintomas
   */
  export type sintomas$medico_sintomasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medico_sintomas
     */
    select?: medico_sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medico_sintomasInclude<ExtArgs> | null
    where?: medico_sintomasWhereInput
    orderBy?: medico_sintomasOrderByWithRelationInput | medico_sintomasOrderByWithRelationInput[]
    cursor?: medico_sintomasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medico_sintomasScalarFieldEnum | Medico_sintomasScalarFieldEnum[]
  }

  /**
   * sintomas without action
   */
  export type sintomasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sintomas
     */
    select?: sintomasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sintomasInclude<ExtArgs> | null
  }


  /**
   * Model agent_control
   */

  export type AggregateAgent_control = {
    _count: Agent_controlCountAggregateOutputType | null
    _min: Agent_controlMinAggregateOutputType | null
    _max: Agent_controlMaxAggregateOutputType | null
  }

  export type Agent_controlMinAggregateOutputType = {
    numero: string | null
    agente_ativo: boolean | null
    datehora: Date | null
    ignorar_automacao: boolean | null
  }

  export type Agent_controlMaxAggregateOutputType = {
    numero: string | null
    agente_ativo: boolean | null
    datehora: Date | null
    ignorar_automacao: boolean | null
  }

  export type Agent_controlCountAggregateOutputType = {
    numero: number
    agente_ativo: number
    datehora: number
    ignorar_automacao: number
    _all: number
  }


  export type Agent_controlMinAggregateInputType = {
    numero?: true
    agente_ativo?: true
    datehora?: true
    ignorar_automacao?: true
  }

  export type Agent_controlMaxAggregateInputType = {
    numero?: true
    agente_ativo?: true
    datehora?: true
    ignorar_automacao?: true
  }

  export type Agent_controlCountAggregateInputType = {
    numero?: true
    agente_ativo?: true
    datehora?: true
    ignorar_automacao?: true
    _all?: true
  }

  export type Agent_controlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agent_control to aggregate.
     */
    where?: agent_controlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_controls to fetch.
     */
    orderBy?: agent_controlOrderByWithRelationInput | agent_controlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agent_controlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_controls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_controls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agent_controls
    **/
    _count?: true | Agent_controlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Agent_controlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Agent_controlMaxAggregateInputType
  }

  export type GetAgent_controlAggregateType<T extends Agent_controlAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent_control]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent_control[P]>
      : GetScalarType<T[P], AggregateAgent_control[P]>
  }




  export type agent_controlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agent_controlWhereInput
    orderBy?: agent_controlOrderByWithAggregationInput | agent_controlOrderByWithAggregationInput[]
    by: Agent_controlScalarFieldEnum[] | Agent_controlScalarFieldEnum
    having?: agent_controlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Agent_controlCountAggregateInputType | true
    _min?: Agent_controlMinAggregateInputType
    _max?: Agent_controlMaxAggregateInputType
  }

  export type Agent_controlGroupByOutputType = {
    numero: string
    agente_ativo: boolean
    datehora: Date
    ignorar_automacao: boolean | null
    _count: Agent_controlCountAggregateOutputType | null
    _min: Agent_controlMinAggregateOutputType | null
    _max: Agent_controlMaxAggregateOutputType | null
  }

  type GetAgent_controlGroupByPayload<T extends agent_controlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Agent_controlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Agent_controlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Agent_controlGroupByOutputType[P]>
            : GetScalarType<T[P], Agent_controlGroupByOutputType[P]>
        }
      >
    >


  export type agent_controlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    numero?: boolean
    agente_ativo?: boolean
    datehora?: boolean
    ignorar_automacao?: boolean
  }, ExtArgs["result"]["agent_control"]>

  export type agent_controlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    numero?: boolean
    agente_ativo?: boolean
    datehora?: boolean
    ignorar_automacao?: boolean
  }, ExtArgs["result"]["agent_control"]>

  export type agent_controlSelectScalar = {
    numero?: boolean
    agente_ativo?: boolean
    datehora?: boolean
    ignorar_automacao?: boolean
  }


  export type $agent_controlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agent_control"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      numero: string
      agente_ativo: boolean
      datehora: Date
      ignorar_automacao: boolean | null
    }, ExtArgs["result"]["agent_control"]>
    composites: {}
  }

  type agent_controlGetPayload<S extends boolean | null | undefined | agent_controlDefaultArgs> = $Result.GetResult<Prisma.$agent_controlPayload, S>

  type agent_controlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<agent_controlFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Agent_controlCountAggregateInputType | true
    }

  export interface agent_controlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agent_control'], meta: { name: 'agent_control' } }
    /**
     * Find zero or one Agent_control that matches the filter.
     * @param {agent_controlFindUniqueArgs} args - Arguments to find a Agent_control
     * @example
     * // Get one Agent_control
     * const agent_control = await prisma.agent_control.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agent_controlFindUniqueArgs>(args: SelectSubset<T, agent_controlFindUniqueArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Agent_control that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {agent_controlFindUniqueOrThrowArgs} args - Arguments to find a Agent_control
     * @example
     * // Get one Agent_control
     * const agent_control = await prisma.agent_control.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agent_controlFindUniqueOrThrowArgs>(args: SelectSubset<T, agent_controlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Agent_control that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_controlFindFirstArgs} args - Arguments to find a Agent_control
     * @example
     * // Get one Agent_control
     * const agent_control = await prisma.agent_control.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agent_controlFindFirstArgs>(args?: SelectSubset<T, agent_controlFindFirstArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Agent_control that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_controlFindFirstOrThrowArgs} args - Arguments to find a Agent_control
     * @example
     * // Get one Agent_control
     * const agent_control = await prisma.agent_control.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agent_controlFindFirstOrThrowArgs>(args?: SelectSubset<T, agent_controlFindFirstOrThrowArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Agent_controls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_controlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agent_controls
     * const agent_controls = await prisma.agent_control.findMany()
     * 
     * // Get first 10 Agent_controls
     * const agent_controls = await prisma.agent_control.findMany({ take: 10 })
     * 
     * // Only select the `numero`
     * const agent_controlWithNumeroOnly = await prisma.agent_control.findMany({ select: { numero: true } })
     * 
     */
    findMany<T extends agent_controlFindManyArgs>(args?: SelectSubset<T, agent_controlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Agent_control.
     * @param {agent_controlCreateArgs} args - Arguments to create a Agent_control.
     * @example
     * // Create one Agent_control
     * const Agent_control = await prisma.agent_control.create({
     *   data: {
     *     // ... data to create a Agent_control
     *   }
     * })
     * 
     */
    create<T extends agent_controlCreateArgs>(args: SelectSubset<T, agent_controlCreateArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Agent_controls.
     * @param {agent_controlCreateManyArgs} args - Arguments to create many Agent_controls.
     * @example
     * // Create many Agent_controls
     * const agent_control = await prisma.agent_control.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agent_controlCreateManyArgs>(args?: SelectSubset<T, agent_controlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agent_controls and returns the data saved in the database.
     * @param {agent_controlCreateManyAndReturnArgs} args - Arguments to create many Agent_controls.
     * @example
     * // Create many Agent_controls
     * const agent_control = await prisma.agent_control.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agent_controls and only return the `numero`
     * const agent_controlWithNumeroOnly = await prisma.agent_control.createManyAndReturn({ 
     *   select: { numero: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends agent_controlCreateManyAndReturnArgs>(args?: SelectSubset<T, agent_controlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Agent_control.
     * @param {agent_controlDeleteArgs} args - Arguments to delete one Agent_control.
     * @example
     * // Delete one Agent_control
     * const Agent_control = await prisma.agent_control.delete({
     *   where: {
     *     // ... filter to delete one Agent_control
     *   }
     * })
     * 
     */
    delete<T extends agent_controlDeleteArgs>(args: SelectSubset<T, agent_controlDeleteArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Agent_control.
     * @param {agent_controlUpdateArgs} args - Arguments to update one Agent_control.
     * @example
     * // Update one Agent_control
     * const agent_control = await prisma.agent_control.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agent_controlUpdateArgs>(args: SelectSubset<T, agent_controlUpdateArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Agent_controls.
     * @param {agent_controlDeleteManyArgs} args - Arguments to filter Agent_controls to delete.
     * @example
     * // Delete a few Agent_controls
     * const { count } = await prisma.agent_control.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agent_controlDeleteManyArgs>(args?: SelectSubset<T, agent_controlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agent_controls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_controlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agent_controls
     * const agent_control = await prisma.agent_control.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agent_controlUpdateManyArgs>(args: SelectSubset<T, agent_controlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent_control.
     * @param {agent_controlUpsertArgs} args - Arguments to update or create a Agent_control.
     * @example
     * // Update or create a Agent_control
     * const agent_control = await prisma.agent_control.upsert({
     *   create: {
     *     // ... data to create a Agent_control
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent_control we want to update
     *   }
     * })
     */
    upsert<T extends agent_controlUpsertArgs>(args: SelectSubset<T, agent_controlUpsertArgs<ExtArgs>>): Prisma__agent_controlClient<$Result.GetResult<Prisma.$agent_controlPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Agent_controls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_controlCountArgs} args - Arguments to filter Agent_controls to count.
     * @example
     * // Count the number of Agent_controls
     * const count = await prisma.agent_control.count({
     *   where: {
     *     // ... the filter for the Agent_controls we want to count
     *   }
     * })
    **/
    count<T extends agent_controlCountArgs>(
      args?: Subset<T, agent_controlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Agent_controlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent_control.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Agent_controlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Agent_controlAggregateArgs>(args: Subset<T, Agent_controlAggregateArgs>): Prisma.PrismaPromise<GetAgent_controlAggregateType<T>>

    /**
     * Group by Agent_control.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agent_controlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agent_controlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agent_controlGroupByArgs['orderBy'] }
        : { orderBy?: agent_controlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agent_controlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgent_controlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agent_control model
   */
  readonly fields: agent_controlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agent_control.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agent_controlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agent_control model
   */ 
  interface agent_controlFieldRefs {
    readonly numero: FieldRef<"agent_control", 'String'>
    readonly agente_ativo: FieldRef<"agent_control", 'Boolean'>
    readonly datehora: FieldRef<"agent_control", 'DateTime'>
    readonly ignorar_automacao: FieldRef<"agent_control", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * agent_control findUnique
   */
  export type agent_controlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * Filter, which agent_control to fetch.
     */
    where: agent_controlWhereUniqueInput
  }

  /**
   * agent_control findUniqueOrThrow
   */
  export type agent_controlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * Filter, which agent_control to fetch.
     */
    where: agent_controlWhereUniqueInput
  }

  /**
   * agent_control findFirst
   */
  export type agent_controlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * Filter, which agent_control to fetch.
     */
    where?: agent_controlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_controls to fetch.
     */
    orderBy?: agent_controlOrderByWithRelationInput | agent_controlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agent_controls.
     */
    cursor?: agent_controlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_controls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_controls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agent_controls.
     */
    distinct?: Agent_controlScalarFieldEnum | Agent_controlScalarFieldEnum[]
  }

  /**
   * agent_control findFirstOrThrow
   */
  export type agent_controlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * Filter, which agent_control to fetch.
     */
    where?: agent_controlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_controls to fetch.
     */
    orderBy?: agent_controlOrderByWithRelationInput | agent_controlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agent_controls.
     */
    cursor?: agent_controlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_controls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_controls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agent_controls.
     */
    distinct?: Agent_controlScalarFieldEnum | Agent_controlScalarFieldEnum[]
  }

  /**
   * agent_control findMany
   */
  export type agent_controlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * Filter, which agent_controls to fetch.
     */
    where?: agent_controlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agent_controls to fetch.
     */
    orderBy?: agent_controlOrderByWithRelationInput | agent_controlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agent_controls.
     */
    cursor?: agent_controlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agent_controls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agent_controls.
     */
    skip?: number
    distinct?: Agent_controlScalarFieldEnum | Agent_controlScalarFieldEnum[]
  }

  /**
   * agent_control create
   */
  export type agent_controlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * The data needed to create a agent_control.
     */
    data: XOR<agent_controlCreateInput, agent_controlUncheckedCreateInput>
  }

  /**
   * agent_control createMany
   */
  export type agent_controlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agent_controls.
     */
    data: agent_controlCreateManyInput | agent_controlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agent_control createManyAndReturn
   */
  export type agent_controlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many agent_controls.
     */
    data: agent_controlCreateManyInput | agent_controlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agent_control update
   */
  export type agent_controlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * The data needed to update a agent_control.
     */
    data: XOR<agent_controlUpdateInput, agent_controlUncheckedUpdateInput>
    /**
     * Choose, which agent_control to update.
     */
    where: agent_controlWhereUniqueInput
  }

  /**
   * agent_control updateMany
   */
  export type agent_controlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agent_controls.
     */
    data: XOR<agent_controlUpdateManyMutationInput, agent_controlUncheckedUpdateManyInput>
    /**
     * Filter which agent_controls to update
     */
    where?: agent_controlWhereInput
  }

  /**
   * agent_control upsert
   */
  export type agent_controlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * The filter to search for the agent_control to update in case it exists.
     */
    where: agent_controlWhereUniqueInput
    /**
     * In case the agent_control found by the `where` argument doesn't exist, create a new agent_control with this data.
     */
    create: XOR<agent_controlCreateInput, agent_controlUncheckedCreateInput>
    /**
     * In case the agent_control was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agent_controlUpdateInput, agent_controlUncheckedUpdateInput>
  }

  /**
   * agent_control delete
   */
  export type agent_controlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
    /**
     * Filter which agent_control to delete.
     */
    where: agent_controlWhereUniqueInput
  }

  /**
   * agent_control deleteMany
   */
  export type agent_controlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agent_controls to delete
     */
    where?: agent_controlWhereInput
  }

  /**
   * agent_control without action
   */
  export type agent_controlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent_control
     */
    select?: agent_controlSelect<ExtArgs> | null
  }


  /**
   * Model app_grupo
   */

  export type AggregateApp_grupo = {
    _count: App_grupoCountAggregateOutputType | null
    _avg: App_grupoAvgAggregateOutputType | null
    _sum: App_grupoSumAggregateOutputType | null
    _min: App_grupoMinAggregateOutputType | null
    _max: App_grupoMaxAggregateOutputType | null
  }

  export type App_grupoAvgAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_grupoSumAggregateOutputType = {
    id: number | null
    clinica_id: number | null
  }

  export type App_grupoMinAggregateOutputType = {
    id: number | null
    jid: string | null
    nome: string | null
    clinica_id: number | null
    criado_em: Date | null
  }

  export type App_grupoMaxAggregateOutputType = {
    id: number | null
    jid: string | null
    nome: string | null
    clinica_id: number | null
    criado_em: Date | null
  }

  export type App_grupoCountAggregateOutputType = {
    id: number
    jid: number
    nome: number
    clinica_id: number
    criado_em: number
    _all: number
  }


  export type App_grupoAvgAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_grupoSumAggregateInputType = {
    id?: true
    clinica_id?: true
  }

  export type App_grupoMinAggregateInputType = {
    id?: true
    jid?: true
    nome?: true
    clinica_id?: true
    criado_em?: true
  }

  export type App_grupoMaxAggregateInputType = {
    id?: true
    jid?: true
    nome?: true
    clinica_id?: true
    criado_em?: true
  }

  export type App_grupoCountAggregateInputType = {
    id?: true
    jid?: true
    nome?: true
    clinica_id?: true
    criado_em?: true
    _all?: true
  }

  export type App_grupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_grupo to aggregate.
     */
    where?: app_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_grupos to fetch.
     */
    orderBy?: app_grupoOrderByWithRelationInput | app_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_grupos
    **/
    _count?: true | App_grupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_grupoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_grupoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_grupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_grupoMaxAggregateInputType
  }

  export type GetApp_grupoAggregateType<T extends App_grupoAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_grupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_grupo[P]>
      : GetScalarType<T[P], AggregateApp_grupo[P]>
  }




  export type app_grupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_grupoWhereInput
    orderBy?: app_grupoOrderByWithAggregationInput | app_grupoOrderByWithAggregationInput[]
    by: App_grupoScalarFieldEnum[] | App_grupoScalarFieldEnum
    having?: app_grupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_grupoCountAggregateInputType | true
    _avg?: App_grupoAvgAggregateInputType
    _sum?: App_grupoSumAggregateInputType
    _min?: App_grupoMinAggregateInputType
    _max?: App_grupoMaxAggregateInputType
  }

  export type App_grupoGroupByOutputType = {
    id: number
    jid: string
    nome: string | null
    clinica_id: number
    criado_em: Date | null
    _count: App_grupoCountAggregateOutputType | null
    _avg: App_grupoAvgAggregateOutputType | null
    _sum: App_grupoSumAggregateOutputType | null
    _min: App_grupoMinAggregateOutputType | null
    _max: App_grupoMaxAggregateOutputType | null
  }

  type GetApp_grupoGroupByPayload<T extends app_grupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_grupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_grupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_grupoGroupByOutputType[P]>
            : GetScalarType<T[P], App_grupoGroupByOutputType[P]>
        }
      >
    >


  export type app_grupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    nome?: boolean
    clinica_id?: boolean
    criado_em?: boolean
    app_conversa?: boolean | app_grupo$app_conversaArgs<ExtArgs>
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
    _count?: boolean | App_grupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_grupo"]>

  export type app_grupoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    nome?: boolean
    clinica_id?: boolean
    criado_em?: boolean
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_grupo"]>

  export type app_grupoSelectScalar = {
    id?: boolean
    jid?: boolean
    nome?: boolean
    clinica_id?: boolean
    criado_em?: boolean
  }

  export type app_grupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_conversa?: boolean | app_grupo$app_conversaArgs<ExtArgs>
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
    _count?: boolean | App_grupoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type app_grupoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_clinica?: boolean | app_clinicaDefaultArgs<ExtArgs>
  }

  export type $app_grupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_grupo"
    objects: {
      app_conversa: Prisma.$app_conversaPayload<ExtArgs>[]
      app_clinica: Prisma.$app_clinicaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jid: string
      nome: string | null
      clinica_id: number
      criado_em: Date | null
    }, ExtArgs["result"]["app_grupo"]>
    composites: {}
  }

  type app_grupoGetPayload<S extends boolean | null | undefined | app_grupoDefaultArgs> = $Result.GetResult<Prisma.$app_grupoPayload, S>

  type app_grupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_grupoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_grupoCountAggregateInputType | true
    }

  export interface app_grupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_grupo'], meta: { name: 'app_grupo' } }
    /**
     * Find zero or one App_grupo that matches the filter.
     * @param {app_grupoFindUniqueArgs} args - Arguments to find a App_grupo
     * @example
     * // Get one App_grupo
     * const app_grupo = await prisma.app_grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_grupoFindUniqueArgs>(args: SelectSubset<T, app_grupoFindUniqueArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_grupo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_grupoFindUniqueOrThrowArgs} args - Arguments to find a App_grupo
     * @example
     * // Get one App_grupo
     * const app_grupo = await prisma.app_grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_grupoFindUniqueOrThrowArgs>(args: SelectSubset<T, app_grupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_grupoFindFirstArgs} args - Arguments to find a App_grupo
     * @example
     * // Get one App_grupo
     * const app_grupo = await prisma.app_grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_grupoFindFirstArgs>(args?: SelectSubset<T, app_grupoFindFirstArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_grupoFindFirstOrThrowArgs} args - Arguments to find a App_grupo
     * @example
     * // Get one App_grupo
     * const app_grupo = await prisma.app_grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_grupoFindFirstOrThrowArgs>(args?: SelectSubset<T, app_grupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_grupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_grupos
     * const app_grupos = await prisma.app_grupo.findMany()
     * 
     * // Get first 10 App_grupos
     * const app_grupos = await prisma.app_grupo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_grupoWithIdOnly = await prisma.app_grupo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_grupoFindManyArgs>(args?: SelectSubset<T, app_grupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_grupo.
     * @param {app_grupoCreateArgs} args - Arguments to create a App_grupo.
     * @example
     * // Create one App_grupo
     * const App_grupo = await prisma.app_grupo.create({
     *   data: {
     *     // ... data to create a App_grupo
     *   }
     * })
     * 
     */
    create<T extends app_grupoCreateArgs>(args: SelectSubset<T, app_grupoCreateArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_grupos.
     * @param {app_grupoCreateManyArgs} args - Arguments to create many App_grupos.
     * @example
     * // Create many App_grupos
     * const app_grupo = await prisma.app_grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_grupoCreateManyArgs>(args?: SelectSubset<T, app_grupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_grupos and returns the data saved in the database.
     * @param {app_grupoCreateManyAndReturnArgs} args - Arguments to create many App_grupos.
     * @example
     * // Create many App_grupos
     * const app_grupo = await prisma.app_grupo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_grupos and only return the `id`
     * const app_grupoWithIdOnly = await prisma.app_grupo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_grupoCreateManyAndReturnArgs>(args?: SelectSubset<T, app_grupoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_grupo.
     * @param {app_grupoDeleteArgs} args - Arguments to delete one App_grupo.
     * @example
     * // Delete one App_grupo
     * const App_grupo = await prisma.app_grupo.delete({
     *   where: {
     *     // ... filter to delete one App_grupo
     *   }
     * })
     * 
     */
    delete<T extends app_grupoDeleteArgs>(args: SelectSubset<T, app_grupoDeleteArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_grupo.
     * @param {app_grupoUpdateArgs} args - Arguments to update one App_grupo.
     * @example
     * // Update one App_grupo
     * const app_grupo = await prisma.app_grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_grupoUpdateArgs>(args: SelectSubset<T, app_grupoUpdateArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_grupos.
     * @param {app_grupoDeleteManyArgs} args - Arguments to filter App_grupos to delete.
     * @example
     * // Delete a few App_grupos
     * const { count } = await prisma.app_grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_grupoDeleteManyArgs>(args?: SelectSubset<T, app_grupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_grupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_grupos
     * const app_grupo = await prisma.app_grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_grupoUpdateManyArgs>(args: SelectSubset<T, app_grupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_grupo.
     * @param {app_grupoUpsertArgs} args - Arguments to update or create a App_grupo.
     * @example
     * // Update or create a App_grupo
     * const app_grupo = await prisma.app_grupo.upsert({
     *   create: {
     *     // ... data to create a App_grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_grupo we want to update
     *   }
     * })
     */
    upsert<T extends app_grupoUpsertArgs>(args: SelectSubset<T, app_grupoUpsertArgs<ExtArgs>>): Prisma__app_grupoClient<$Result.GetResult<Prisma.$app_grupoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_grupoCountArgs} args - Arguments to filter App_grupos to count.
     * @example
     * // Count the number of App_grupos
     * const count = await prisma.app_grupo.count({
     *   where: {
     *     // ... the filter for the App_grupos we want to count
     *   }
     * })
    **/
    count<T extends app_grupoCountArgs>(
      args?: Subset<T, app_grupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_grupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_grupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_grupoAggregateArgs>(args: Subset<T, App_grupoAggregateArgs>): Prisma.PrismaPromise<GetApp_grupoAggregateType<T>>

    /**
     * Group by App_grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_grupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_grupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_grupoGroupByArgs['orderBy'] }
        : { orderBy?: app_grupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_grupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_grupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_grupo model
   */
  readonly fields: app_grupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_grupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_conversa<T extends app_grupo$app_conversaArgs<ExtArgs> = {}>(args?: Subset<T, app_grupo$app_conversaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_conversaPayload<ExtArgs>, T, "findMany"> | Null>
    app_clinica<T extends app_clinicaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_clinicaDefaultArgs<ExtArgs>>): Prisma__app_clinicaClient<$Result.GetResult<Prisma.$app_clinicaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_grupo model
   */ 
  interface app_grupoFieldRefs {
    readonly id: FieldRef<"app_grupo", 'Int'>
    readonly jid: FieldRef<"app_grupo", 'String'>
    readonly nome: FieldRef<"app_grupo", 'String'>
    readonly clinica_id: FieldRef<"app_grupo", 'Int'>
    readonly criado_em: FieldRef<"app_grupo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_grupo findUnique
   */
  export type app_grupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * Filter, which app_grupo to fetch.
     */
    where: app_grupoWhereUniqueInput
  }

  /**
   * app_grupo findUniqueOrThrow
   */
  export type app_grupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * Filter, which app_grupo to fetch.
     */
    where: app_grupoWhereUniqueInput
  }

  /**
   * app_grupo findFirst
   */
  export type app_grupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * Filter, which app_grupo to fetch.
     */
    where?: app_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_grupos to fetch.
     */
    orderBy?: app_grupoOrderByWithRelationInput | app_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_grupos.
     */
    cursor?: app_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_grupos.
     */
    distinct?: App_grupoScalarFieldEnum | App_grupoScalarFieldEnum[]
  }

  /**
   * app_grupo findFirstOrThrow
   */
  export type app_grupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * Filter, which app_grupo to fetch.
     */
    where?: app_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_grupos to fetch.
     */
    orderBy?: app_grupoOrderByWithRelationInput | app_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_grupos.
     */
    cursor?: app_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_grupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_grupos.
     */
    distinct?: App_grupoScalarFieldEnum | App_grupoScalarFieldEnum[]
  }

  /**
   * app_grupo findMany
   */
  export type app_grupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * Filter, which app_grupos to fetch.
     */
    where?: app_grupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_grupos to fetch.
     */
    orderBy?: app_grupoOrderByWithRelationInput | app_grupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_grupos.
     */
    cursor?: app_grupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_grupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_grupos.
     */
    skip?: number
    distinct?: App_grupoScalarFieldEnum | App_grupoScalarFieldEnum[]
  }

  /**
   * app_grupo create
   */
  export type app_grupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * The data needed to create a app_grupo.
     */
    data: XOR<app_grupoCreateInput, app_grupoUncheckedCreateInput>
  }

  /**
   * app_grupo createMany
   */
  export type app_grupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_grupos.
     */
    data: app_grupoCreateManyInput | app_grupoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_grupo createManyAndReturn
   */
  export type app_grupoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_grupos.
     */
    data: app_grupoCreateManyInput | app_grupoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_grupo update
   */
  export type app_grupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * The data needed to update a app_grupo.
     */
    data: XOR<app_grupoUpdateInput, app_grupoUncheckedUpdateInput>
    /**
     * Choose, which app_grupo to update.
     */
    where: app_grupoWhereUniqueInput
  }

  /**
   * app_grupo updateMany
   */
  export type app_grupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_grupos.
     */
    data: XOR<app_grupoUpdateManyMutationInput, app_grupoUncheckedUpdateManyInput>
    /**
     * Filter which app_grupos to update
     */
    where?: app_grupoWhereInput
  }

  /**
   * app_grupo upsert
   */
  export type app_grupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * The filter to search for the app_grupo to update in case it exists.
     */
    where: app_grupoWhereUniqueInput
    /**
     * In case the app_grupo found by the `where` argument doesn't exist, create a new app_grupo with this data.
     */
    create: XOR<app_grupoCreateInput, app_grupoUncheckedCreateInput>
    /**
     * In case the app_grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_grupoUpdateInput, app_grupoUncheckedUpdateInput>
  }

  /**
   * app_grupo delete
   */
  export type app_grupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
    /**
     * Filter which app_grupo to delete.
     */
    where: app_grupoWhereUniqueInput
  }

  /**
   * app_grupo deleteMany
   */
  export type app_grupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_grupos to delete
     */
    where?: app_grupoWhereInput
  }

  /**
   * app_grupo.app_conversa
   */
  export type app_grupo$app_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_conversa
     */
    select?: app_conversaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_conversaInclude<ExtArgs> | null
    where?: app_conversaWhereInput
    orderBy?: app_conversaOrderByWithRelationInput | app_conversaOrderByWithRelationInput[]
    cursor?: app_conversaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: App_conversaScalarFieldEnum | App_conversaScalarFieldEnum[]
  }

  /**
   * app_grupo without action
   */
  export type app_grupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_grupo
     */
    select?: app_grupoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_grupoInclude<ExtArgs> | null
  }


  /**
   * Model app_receipt
   */

  export type AggregateApp_receipt = {
    _count: App_receiptCountAggregateOutputType | null
    _avg: App_receiptAvgAggregateOutputType | null
    _sum: App_receiptSumAggregateOutputType | null
    _min: App_receiptMinAggregateOutputType | null
    _max: App_receiptMaxAggregateOutputType | null
  }

  export type App_receiptAvgAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
  }

  export type App_receiptSumAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
  }

  export type App_receiptMinAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
    event_type: string | null
    receipt_time: Date | null
    created_at: Date | null
  }

  export type App_receiptMaxAggregateOutputType = {
    id: number | null
    mensagem_id: number | null
    event_type: string | null
    receipt_time: Date | null
    created_at: Date | null
  }

  export type App_receiptCountAggregateOutputType = {
    id: number
    mensagem_id: number
    event_type: number
    receipt_time: number
    created_at: number
    _all: number
  }


  export type App_receiptAvgAggregateInputType = {
    id?: true
    mensagem_id?: true
  }

  export type App_receiptSumAggregateInputType = {
    id?: true
    mensagem_id?: true
  }

  export type App_receiptMinAggregateInputType = {
    id?: true
    mensagem_id?: true
    event_type?: true
    receipt_time?: true
    created_at?: true
  }

  export type App_receiptMaxAggregateInputType = {
    id?: true
    mensagem_id?: true
    event_type?: true
    receipt_time?: true
    created_at?: true
  }

  export type App_receiptCountAggregateInputType = {
    id?: true
    mensagem_id?: true
    event_type?: true
    receipt_time?: true
    created_at?: true
    _all?: true
  }

  export type App_receiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_receipt to aggregate.
     */
    where?: app_receiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_receipts to fetch.
     */
    orderBy?: app_receiptOrderByWithRelationInput | app_receiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_receiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_receipts
    **/
    _count?: true | App_receiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_receiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_receiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_receiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_receiptMaxAggregateInputType
  }

  export type GetApp_receiptAggregateType<T extends App_receiptAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_receipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_receipt[P]>
      : GetScalarType<T[P], AggregateApp_receipt[P]>
  }




  export type app_receiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_receiptWhereInput
    orderBy?: app_receiptOrderByWithAggregationInput | app_receiptOrderByWithAggregationInput[]
    by: App_receiptScalarFieldEnum[] | App_receiptScalarFieldEnum
    having?: app_receiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_receiptCountAggregateInputType | true
    _avg?: App_receiptAvgAggregateInputType
    _sum?: App_receiptSumAggregateInputType
    _min?: App_receiptMinAggregateInputType
    _max?: App_receiptMaxAggregateInputType
  }

  export type App_receiptGroupByOutputType = {
    id: number
    mensagem_id: number
    event_type: string
    receipt_time: Date
    created_at: Date | null
    _count: App_receiptCountAggregateOutputType | null
    _avg: App_receiptAvgAggregateOutputType | null
    _sum: App_receiptSumAggregateOutputType | null
    _min: App_receiptMinAggregateOutputType | null
    _max: App_receiptMaxAggregateOutputType | null
  }

  type GetApp_receiptGroupByPayload<T extends app_receiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_receiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_receiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_receiptGroupByOutputType[P]>
            : GetScalarType<T[P], App_receiptGroupByOutputType[P]>
        }
      >
    >


  export type app_receiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem_id?: boolean
    event_type?: boolean
    receipt_time?: boolean
    created_at?: boolean
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_receipt"]>

  export type app_receiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensagem_id?: boolean
    event_type?: boolean
    receipt_time?: boolean
    created_at?: boolean
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_receipt"]>

  export type app_receiptSelectScalar = {
    id?: boolean
    mensagem_id?: boolean
    event_type?: boolean
    receipt_time?: boolean
    created_at?: boolean
  }

  export type app_receiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }
  export type app_receiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_mensagem?: boolean | app_mensagemDefaultArgs<ExtArgs>
  }

  export type $app_receiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_receipt"
    objects: {
      app_mensagem: Prisma.$app_mensagemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mensagem_id: number
      event_type: string
      receipt_time: Date
      created_at: Date | null
    }, ExtArgs["result"]["app_receipt"]>
    composites: {}
  }

  type app_receiptGetPayload<S extends boolean | null | undefined | app_receiptDefaultArgs> = $Result.GetResult<Prisma.$app_receiptPayload, S>

  type app_receiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_receiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_receiptCountAggregateInputType | true
    }

  export interface app_receiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_receipt'], meta: { name: 'app_receipt' } }
    /**
     * Find zero or one App_receipt that matches the filter.
     * @param {app_receiptFindUniqueArgs} args - Arguments to find a App_receipt
     * @example
     * // Get one App_receipt
     * const app_receipt = await prisma.app_receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_receiptFindUniqueArgs>(args: SelectSubset<T, app_receiptFindUniqueArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_receipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_receiptFindUniqueOrThrowArgs} args - Arguments to find a App_receipt
     * @example
     * // Get one App_receipt
     * const app_receipt = await prisma.app_receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_receiptFindUniqueOrThrowArgs>(args: SelectSubset<T, app_receiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_receiptFindFirstArgs} args - Arguments to find a App_receipt
     * @example
     * // Get one App_receipt
     * const app_receipt = await prisma.app_receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_receiptFindFirstArgs>(args?: SelectSubset<T, app_receiptFindFirstArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_receiptFindFirstOrThrowArgs} args - Arguments to find a App_receipt
     * @example
     * // Get one App_receipt
     * const app_receipt = await prisma.app_receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_receiptFindFirstOrThrowArgs>(args?: SelectSubset<T, app_receiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_receiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_receipts
     * const app_receipts = await prisma.app_receipt.findMany()
     * 
     * // Get first 10 App_receipts
     * const app_receipts = await prisma.app_receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_receiptWithIdOnly = await prisma.app_receipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_receiptFindManyArgs>(args?: SelectSubset<T, app_receiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_receipt.
     * @param {app_receiptCreateArgs} args - Arguments to create a App_receipt.
     * @example
     * // Create one App_receipt
     * const App_receipt = await prisma.app_receipt.create({
     *   data: {
     *     // ... data to create a App_receipt
     *   }
     * })
     * 
     */
    create<T extends app_receiptCreateArgs>(args: SelectSubset<T, app_receiptCreateArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_receipts.
     * @param {app_receiptCreateManyArgs} args - Arguments to create many App_receipts.
     * @example
     * // Create many App_receipts
     * const app_receipt = await prisma.app_receipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_receiptCreateManyArgs>(args?: SelectSubset<T, app_receiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_receipts and returns the data saved in the database.
     * @param {app_receiptCreateManyAndReturnArgs} args - Arguments to create many App_receipts.
     * @example
     * // Create many App_receipts
     * const app_receipt = await prisma.app_receipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_receipts and only return the `id`
     * const app_receiptWithIdOnly = await prisma.app_receipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_receiptCreateManyAndReturnArgs>(args?: SelectSubset<T, app_receiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a App_receipt.
     * @param {app_receiptDeleteArgs} args - Arguments to delete one App_receipt.
     * @example
     * // Delete one App_receipt
     * const App_receipt = await prisma.app_receipt.delete({
     *   where: {
     *     // ... filter to delete one App_receipt
     *   }
     * })
     * 
     */
    delete<T extends app_receiptDeleteArgs>(args: SelectSubset<T, app_receiptDeleteArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_receipt.
     * @param {app_receiptUpdateArgs} args - Arguments to update one App_receipt.
     * @example
     * // Update one App_receipt
     * const app_receipt = await prisma.app_receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_receiptUpdateArgs>(args: SelectSubset<T, app_receiptUpdateArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_receipts.
     * @param {app_receiptDeleteManyArgs} args - Arguments to filter App_receipts to delete.
     * @example
     * // Delete a few App_receipts
     * const { count } = await prisma.app_receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_receiptDeleteManyArgs>(args?: SelectSubset<T, app_receiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_receiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_receipts
     * const app_receipt = await prisma.app_receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_receiptUpdateManyArgs>(args: SelectSubset<T, app_receiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_receipt.
     * @param {app_receiptUpsertArgs} args - Arguments to update or create a App_receipt.
     * @example
     * // Update or create a App_receipt
     * const app_receipt = await prisma.app_receipt.upsert({
     *   create: {
     *     // ... data to create a App_receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_receipt we want to update
     *   }
     * })
     */
    upsert<T extends app_receiptUpsertArgs>(args: SelectSubset<T, app_receiptUpsertArgs<ExtArgs>>): Prisma__app_receiptClient<$Result.GetResult<Prisma.$app_receiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of App_receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_receiptCountArgs} args - Arguments to filter App_receipts to count.
     * @example
     * // Count the number of App_receipts
     * const count = await prisma.app_receipt.count({
     *   where: {
     *     // ... the filter for the App_receipts we want to count
     *   }
     * })
    **/
    count<T extends app_receiptCountArgs>(
      args?: Subset<T, app_receiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_receiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_receiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_receiptAggregateArgs>(args: Subset<T, App_receiptAggregateArgs>): Prisma.PrismaPromise<GetApp_receiptAggregateType<T>>

    /**
     * Group by App_receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_receiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_receiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_receiptGroupByArgs['orderBy'] }
        : { orderBy?: app_receiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_receiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_receiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_receipt model
   */
  readonly fields: app_receiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_receiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app_mensagem<T extends app_mensagemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_mensagemDefaultArgs<ExtArgs>>): Prisma__app_mensagemClient<$Result.GetResult<Prisma.$app_mensagemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_receipt model
   */ 
  interface app_receiptFieldRefs {
    readonly id: FieldRef<"app_receipt", 'Int'>
    readonly mensagem_id: FieldRef<"app_receipt", 'Int'>
    readonly event_type: FieldRef<"app_receipt", 'String'>
    readonly receipt_time: FieldRef<"app_receipt", 'DateTime'>
    readonly created_at: FieldRef<"app_receipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_receipt findUnique
   */
  export type app_receiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * Filter, which app_receipt to fetch.
     */
    where: app_receiptWhereUniqueInput
  }

  /**
   * app_receipt findUniqueOrThrow
   */
  export type app_receiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * Filter, which app_receipt to fetch.
     */
    where: app_receiptWhereUniqueInput
  }

  /**
   * app_receipt findFirst
   */
  export type app_receiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * Filter, which app_receipt to fetch.
     */
    where?: app_receiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_receipts to fetch.
     */
    orderBy?: app_receiptOrderByWithRelationInput | app_receiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_receipts.
     */
    cursor?: app_receiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_receipts.
     */
    distinct?: App_receiptScalarFieldEnum | App_receiptScalarFieldEnum[]
  }

  /**
   * app_receipt findFirstOrThrow
   */
  export type app_receiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * Filter, which app_receipt to fetch.
     */
    where?: app_receiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_receipts to fetch.
     */
    orderBy?: app_receiptOrderByWithRelationInput | app_receiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_receipts.
     */
    cursor?: app_receiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_receipts.
     */
    distinct?: App_receiptScalarFieldEnum | App_receiptScalarFieldEnum[]
  }

  /**
   * app_receipt findMany
   */
  export type app_receiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * Filter, which app_receipts to fetch.
     */
    where?: app_receiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_receipts to fetch.
     */
    orderBy?: app_receiptOrderByWithRelationInput | app_receiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_receipts.
     */
    cursor?: app_receiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_receipts.
     */
    skip?: number
    distinct?: App_receiptScalarFieldEnum | App_receiptScalarFieldEnum[]
  }

  /**
   * app_receipt create
   */
  export type app_receiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * The data needed to create a app_receipt.
     */
    data: XOR<app_receiptCreateInput, app_receiptUncheckedCreateInput>
  }

  /**
   * app_receipt createMany
   */
  export type app_receiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_receipts.
     */
    data: app_receiptCreateManyInput | app_receiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_receipt createManyAndReturn
   */
  export type app_receiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many app_receipts.
     */
    data: app_receiptCreateManyInput | app_receiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * app_receipt update
   */
  export type app_receiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * The data needed to update a app_receipt.
     */
    data: XOR<app_receiptUpdateInput, app_receiptUncheckedUpdateInput>
    /**
     * Choose, which app_receipt to update.
     */
    where: app_receiptWhereUniqueInput
  }

  /**
   * app_receipt updateMany
   */
  export type app_receiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_receipts.
     */
    data: XOR<app_receiptUpdateManyMutationInput, app_receiptUncheckedUpdateManyInput>
    /**
     * Filter which app_receipts to update
     */
    where?: app_receiptWhereInput
  }

  /**
   * app_receipt upsert
   */
  export type app_receiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * The filter to search for the app_receipt to update in case it exists.
     */
    where: app_receiptWhereUniqueInput
    /**
     * In case the app_receipt found by the `where` argument doesn't exist, create a new app_receipt with this data.
     */
    create: XOR<app_receiptCreateInput, app_receiptUncheckedCreateInput>
    /**
     * In case the app_receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_receiptUpdateInput, app_receiptUncheckedUpdateInput>
  }

  /**
   * app_receipt delete
   */
  export type app_receiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
    /**
     * Filter which app_receipt to delete.
     */
    where: app_receiptWhereUniqueInput
  }

  /**
   * app_receipt deleteMany
   */
  export type app_receiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_receipts to delete
     */
    where?: app_receiptWhereInput
  }

  /**
   * app_receipt without action
   */
  export type app_receiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_receipt
     */
    select?: app_receiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: app_receiptInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const App_usuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    clinica_id: 'clinica_id',
    criado_em: 'criado_em',
    atualizado_em: 'atualizado_em',
    clinicaId: 'clinicaId'
  };

  export type App_usuarioScalarFieldEnum = (typeof App_usuarioScalarFieldEnum)[keyof typeof App_usuarioScalarFieldEnum]


  export const App_clinicaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    endereco: 'endereco',
    telefone: 'telefone',
    email: 'email',
    instancia: 'instancia',
    base_url: 'base_url',
    criada_em: 'criada_em',
    atualizada_em: 'atualizada_em',
    tokenEvolution: 'tokenEvolution'
  };

  export type App_clinicaScalarFieldEnum = (typeof App_clinicaScalarFieldEnum)[keyof typeof App_clinicaScalarFieldEnum]


  export const App_log_acaoScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    acao: 'acao',
    criado_em: 'criado_em'
  };

  export type App_log_acaoScalarFieldEnum = (typeof App_log_acaoScalarFieldEnum)[keyof typeof App_log_acaoScalarFieldEnum]


  export const App_conversaScalarFieldEnum: {
    id: 'id',
    paciente_id: 'paciente_id',
    clinica_id: 'clinica_id',
    iniciada_em: 'iniciada_em',
    atualizada_em: 'atualizada_em',
    grupo_id: 'grupo_id'
  };

  export type App_conversaScalarFieldEnum = (typeof App_conversaScalarFieldEnum)[keyof typeof App_conversaScalarFieldEnum]


  export const App_mensagemScalarFieldEnum: {
    id: 'id',
    conversa_id: 'conversa_id',
    remetente: 'remetente',
    conteudo: 'conteudo',
    tipo_mensagem: 'tipo_mensagem',
    evolution_id: 'evolution_id',
    status: 'status',
    criadaEm: 'criadaEm'
  };

  export type App_mensagemScalarFieldEnum = (typeof App_mensagemScalarFieldEnum)[keyof typeof App_mensagemScalarFieldEnum]


  export const App_mensagem_sugestaoScalarFieldEnum: {
    id: 'id',
    clinica_id: 'clinica_id',
    sugestao: 'sugestao',
    criado_em: 'criado_em'
  };

  export type App_mensagem_sugestaoScalarFieldEnum = (typeof App_mensagem_sugestaoScalarFieldEnum)[keyof typeof App_mensagem_sugestaoScalarFieldEnum]


  export const App_midiaScalarFieldEnum: {
    id: 'id',
    mensagem_id: 'mensagem_id',
    tipo: 'tipo',
    file_url: 'file_url',
    criado_em: 'criado_em',
    mime_type: 'mime_type',
    caption: 'caption',
    duration: 'duration',
    file_size: 'file_size'
  };

  export type App_midiaScalarFieldEnum = (typeof App_midiaScalarFieldEnum)[keyof typeof App_midiaScalarFieldEnum]


  export const App_pacienteScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    telefone: 'telefone',
    criado_em: 'criado_em',
    atualizado_em: 'atualizado_em',
    clinica_id: 'clinica_id'
  };

  export type App_pacienteScalarFieldEnum = (typeof App_pacienteScalarFieldEnum)[keyof typeof App_pacienteScalarFieldEnum]


  export const App_paciente_clinicaScalarFieldEnum: {
    paciente_id: 'paciente_id',
    clinica_id: 'clinica_id'
  };

  export type App_paciente_clinicaScalarFieldEnum = (typeof App_paciente_clinicaScalarFieldEnum)[keyof typeof App_paciente_clinicaScalarFieldEnum]


  export const App_resposta_prontaScalarFieldEnum: {
    id: 'id',
    clinica_id: 'clinica_id',
    titulo: 'titulo',
    conteudo: 'conteudo',
    criada_em: 'criada_em'
  };

  export type App_resposta_prontaScalarFieldEnum = (typeof App_resposta_prontaScalarFieldEnum)[keyof typeof App_resposta_prontaScalarFieldEnum]


  export const App_tagScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    clinica_id: 'clinica_id',
    criada_em: 'criada_em'
  };

  export type App_tagScalarFieldEnum = (typeof App_tagScalarFieldEnum)[keyof typeof App_tagScalarFieldEnum]


  export const ConsultasScalarFieldEnum: {
    id: 'id',
    medico_id: 'medico_id',
    data_hora: 'data_hora',
    tipo: 'tipo',
    status: 'status',
    paciente_id: 'paciente_id'
  };

  export type ConsultasScalarFieldEnum = (typeof ConsultasScalarFieldEnum)[keyof typeof ConsultasScalarFieldEnum]


  export const ConversationsScalarFieldEnum: {
    id: 'id',
    telefone_user: 'telefone_user',
    messages: 'messages',
    created_at: 'created_at'
  };

  export type ConversationsScalarFieldEnum = (typeof ConversationsScalarFieldEnum)[keyof typeof ConversationsScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    text: 'text',
    metadata: 'metadata'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const EspecialidadesScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao'
  };

  export type EspecialidadesScalarFieldEnum = (typeof EspecialidadesScalarFieldEnum)[keyof typeof EspecialidadesScalarFieldEnum]


  export const Medico_procedimentosScalarFieldEnum: {
    id: 'id',
    medico_id: 'medico_id',
    procedimento_id: 'procedimento_id'
  };

  export type Medico_procedimentosScalarFieldEnum = (typeof Medico_procedimentosScalarFieldEnum)[keyof typeof Medico_procedimentosScalarFieldEnum]


  export const Medico_sintomasScalarFieldEnum: {
    id: 'id',
    medico_id: 'medico_id',
    sintoma_id: 'sintoma_id'
  };

  export type Medico_sintomasScalarFieldEnum = (typeof Medico_sintomasScalarFieldEnum)[keyof typeof Medico_sintomasScalarFieldEnum]


  export const MedicosScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    especialidade_id: 'especialidade_id',
    id_calendario: 'id_calendario',
    dia_atendimento: 'dia_atendimento',
    metodo_pagamento: 'metodo_pagamento'
  };

  export type MedicosScalarFieldEnum = (typeof MedicosScalarFieldEnum)[keyof typeof MedicosScalarFieldEnum]


  export const N8n_chat_historiesScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    message: 'message'
  };

  export type N8n_chat_historiesScalarFieldEnum = (typeof N8n_chat_historiesScalarFieldEnum)[keyof typeof N8n_chat_historiesScalarFieldEnum]


  export const PacientesScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    telefone: 'telefone'
  };

  export type PacientesScalarFieldEnum = (typeof PacientesScalarFieldEnum)[keyof typeof PacientesScalarFieldEnum]


  export const ProcedimentosScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    preco: 'preco',
    tempo_estimado: 'tempo_estimado',
    descricao: 'descricao'
  };

  export type ProcedimentosScalarFieldEnum = (typeof ProcedimentosScalarFieldEnum)[keyof typeof ProcedimentosScalarFieldEnum]


  export const Schema_migrationsScalarFieldEnum: {
    version: 'version'
  };

  export type Schema_migrationsScalarFieldEnum = (typeof Schema_migrationsScalarFieldEnum)[keyof typeof Schema_migrationsScalarFieldEnum]


  export const SintomasScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao'
  };

  export type SintomasScalarFieldEnum = (typeof SintomasScalarFieldEnum)[keyof typeof SintomasScalarFieldEnum]


  export const Agent_controlScalarFieldEnum: {
    numero: 'numero',
    agente_ativo: 'agente_ativo',
    datehora: 'datehora',
    ignorar_automacao: 'ignorar_automacao'
  };

  export type Agent_controlScalarFieldEnum = (typeof Agent_controlScalarFieldEnum)[keyof typeof Agent_controlScalarFieldEnum]


  export const App_grupoScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    nome: 'nome',
    clinica_id: 'clinica_id',
    criado_em: 'criado_em'
  };

  export type App_grupoScalarFieldEnum = (typeof App_grupoScalarFieldEnum)[keyof typeof App_grupoScalarFieldEnum]


  export const App_receiptScalarFieldEnum: {
    id: 'id',
    mensagem_id: 'mensagem_id',
    event_type: 'event_type',
    receipt_time: 'receipt_time',
    created_at: 'created_at'
  };

  export type App_receiptScalarFieldEnum = (typeof App_receiptScalarFieldEnum)[keyof typeof App_receiptScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type app_usuarioWhereInput = {
    AND?: app_usuarioWhereInput | app_usuarioWhereInput[]
    OR?: app_usuarioWhereInput[]
    NOT?: app_usuarioWhereInput | app_usuarioWhereInput[]
    id?: IntFilter<"app_usuario"> | number
    nome?: StringFilter<"app_usuario"> | string
    email?: StringFilter<"app_usuario"> | string
    senha?: StringFilter<"app_usuario"> | string
    clinica_id?: IntNullableFilter<"app_usuario"> | number | null
    criado_em?: DateTimeNullableFilter<"app_usuario"> | Date | string | null
    atualizado_em?: DateTimeNullableFilter<"app_usuario"> | Date | string | null
    clinicaId?: IntNullableFilter<"app_usuario"> | number | null
    app_log_acao?: App_log_acaoListRelationFilter
    app_clinica_app_usuario_clinicaIdToapp_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }

  export type app_usuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    clinica_id?: SortOrderInput | SortOrder
    criado_em?: SortOrderInput | SortOrder
    atualizado_em?: SortOrderInput | SortOrder
    clinicaId?: SortOrderInput | SortOrder
    app_log_acao?: app_log_acaoOrderByRelationAggregateInput
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaOrderByWithRelationInput
    app_clinica?: app_clinicaOrderByWithRelationInput
  }

  export type app_usuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: app_usuarioWhereInput | app_usuarioWhereInput[]
    OR?: app_usuarioWhereInput[]
    NOT?: app_usuarioWhereInput | app_usuarioWhereInput[]
    nome?: StringFilter<"app_usuario"> | string
    senha?: StringFilter<"app_usuario"> | string
    clinica_id?: IntNullableFilter<"app_usuario"> | number | null
    criado_em?: DateTimeNullableFilter<"app_usuario"> | Date | string | null
    atualizado_em?: DateTimeNullableFilter<"app_usuario"> | Date | string | null
    clinicaId?: IntNullableFilter<"app_usuario"> | number | null
    app_log_acao?: App_log_acaoListRelationFilter
    app_clinica_app_usuario_clinicaIdToapp_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }, "id" | "email">

  export type app_usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    clinica_id?: SortOrderInput | SortOrder
    criado_em?: SortOrderInput | SortOrder
    atualizado_em?: SortOrderInput | SortOrder
    clinicaId?: SortOrderInput | SortOrder
    _count?: app_usuarioCountOrderByAggregateInput
    _avg?: app_usuarioAvgOrderByAggregateInput
    _max?: app_usuarioMaxOrderByAggregateInput
    _min?: app_usuarioMinOrderByAggregateInput
    _sum?: app_usuarioSumOrderByAggregateInput
  }

  export type app_usuarioScalarWhereWithAggregatesInput = {
    AND?: app_usuarioScalarWhereWithAggregatesInput | app_usuarioScalarWhereWithAggregatesInput[]
    OR?: app_usuarioScalarWhereWithAggregatesInput[]
    NOT?: app_usuarioScalarWhereWithAggregatesInput | app_usuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_usuario"> | number
    nome?: StringWithAggregatesFilter<"app_usuario"> | string
    email?: StringWithAggregatesFilter<"app_usuario"> | string
    senha?: StringWithAggregatesFilter<"app_usuario"> | string
    clinica_id?: IntNullableWithAggregatesFilter<"app_usuario"> | number | null
    criado_em?: DateTimeNullableWithAggregatesFilter<"app_usuario"> | Date | string | null
    atualizado_em?: DateTimeNullableWithAggregatesFilter<"app_usuario"> | Date | string | null
    clinicaId?: IntNullableWithAggregatesFilter<"app_usuario"> | number | null
  }

  export type app_clinicaWhereInput = {
    AND?: app_clinicaWhereInput | app_clinicaWhereInput[]
    OR?: app_clinicaWhereInput[]
    NOT?: app_clinicaWhereInput | app_clinicaWhereInput[]
    id?: IntFilter<"app_clinica"> | number
    nome?: StringFilter<"app_clinica"> | string
    endereco?: StringNullableFilter<"app_clinica"> | string | null
    telefone?: StringNullableFilter<"app_clinica"> | string | null
    email?: StringNullableFilter<"app_clinica"> | string | null
    instancia?: StringNullableFilter<"app_clinica"> | string | null
    base_url?: StringNullableFilter<"app_clinica"> | string | null
    criada_em?: DateTimeNullableFilter<"app_clinica"> | Date | string | null
    atualizada_em?: DateTimeNullableFilter<"app_clinica"> | Date | string | null
    tokenEvolution?: StringNullableFilter<"app_clinica"> | string | null
    app_conversa?: App_conversaListRelationFilter
    app_grupo?: App_grupoListRelationFilter
    app_mensagem_sugestao?: App_mensagem_sugestaoListRelationFilter
    app_paciente?: App_pacienteListRelationFilter
    app_paciente_clinica?: App_paciente_clinicaListRelationFilter
    app_resposta_pronta?: App_resposta_prontaListRelationFilter
    app_tag?: App_tagListRelationFilter
    app_usuario_app_usuario_clinicaIdToapp_clinica?: App_usuarioListRelationFilter
    app_usuario?: App_usuarioListRelationFilter
  }

  export type app_clinicaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    instancia?: SortOrderInput | SortOrder
    base_url?: SortOrderInput | SortOrder
    criada_em?: SortOrderInput | SortOrder
    atualizada_em?: SortOrderInput | SortOrder
    tokenEvolution?: SortOrderInput | SortOrder
    app_conversa?: app_conversaOrderByRelationAggregateInput
    app_grupo?: app_grupoOrderByRelationAggregateInput
    app_mensagem_sugestao?: app_mensagem_sugestaoOrderByRelationAggregateInput
    app_paciente?: app_pacienteOrderByRelationAggregateInput
    app_paciente_clinica?: app_paciente_clinicaOrderByRelationAggregateInput
    app_resposta_pronta?: app_resposta_prontaOrderByRelationAggregateInput
    app_tag?: app_tagOrderByRelationAggregateInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioOrderByRelationAggregateInput
    app_usuario?: app_usuarioOrderByRelationAggregateInput
  }

  export type app_clinicaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tokenEvolution?: string
    AND?: app_clinicaWhereInput | app_clinicaWhereInput[]
    OR?: app_clinicaWhereInput[]
    NOT?: app_clinicaWhereInput | app_clinicaWhereInput[]
    nome?: StringFilter<"app_clinica"> | string
    endereco?: StringNullableFilter<"app_clinica"> | string | null
    telefone?: StringNullableFilter<"app_clinica"> | string | null
    email?: StringNullableFilter<"app_clinica"> | string | null
    instancia?: StringNullableFilter<"app_clinica"> | string | null
    base_url?: StringNullableFilter<"app_clinica"> | string | null
    criada_em?: DateTimeNullableFilter<"app_clinica"> | Date | string | null
    atualizada_em?: DateTimeNullableFilter<"app_clinica"> | Date | string | null
    app_conversa?: App_conversaListRelationFilter
    app_grupo?: App_grupoListRelationFilter
    app_mensagem_sugestao?: App_mensagem_sugestaoListRelationFilter
    app_paciente?: App_pacienteListRelationFilter
    app_paciente_clinica?: App_paciente_clinicaListRelationFilter
    app_resposta_pronta?: App_resposta_prontaListRelationFilter
    app_tag?: App_tagListRelationFilter
    app_usuario_app_usuario_clinicaIdToapp_clinica?: App_usuarioListRelationFilter
    app_usuario?: App_usuarioListRelationFilter
  }, "id" | "tokenEvolution">

  export type app_clinicaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    instancia?: SortOrderInput | SortOrder
    base_url?: SortOrderInput | SortOrder
    criada_em?: SortOrderInput | SortOrder
    atualizada_em?: SortOrderInput | SortOrder
    tokenEvolution?: SortOrderInput | SortOrder
    _count?: app_clinicaCountOrderByAggregateInput
    _avg?: app_clinicaAvgOrderByAggregateInput
    _max?: app_clinicaMaxOrderByAggregateInput
    _min?: app_clinicaMinOrderByAggregateInput
    _sum?: app_clinicaSumOrderByAggregateInput
  }

  export type app_clinicaScalarWhereWithAggregatesInput = {
    AND?: app_clinicaScalarWhereWithAggregatesInput | app_clinicaScalarWhereWithAggregatesInput[]
    OR?: app_clinicaScalarWhereWithAggregatesInput[]
    NOT?: app_clinicaScalarWhereWithAggregatesInput | app_clinicaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_clinica"> | number
    nome?: StringWithAggregatesFilter<"app_clinica"> | string
    endereco?: StringNullableWithAggregatesFilter<"app_clinica"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"app_clinica"> | string | null
    email?: StringNullableWithAggregatesFilter<"app_clinica"> | string | null
    instancia?: StringNullableWithAggregatesFilter<"app_clinica"> | string | null
    base_url?: StringNullableWithAggregatesFilter<"app_clinica"> | string | null
    criada_em?: DateTimeNullableWithAggregatesFilter<"app_clinica"> | Date | string | null
    atualizada_em?: DateTimeNullableWithAggregatesFilter<"app_clinica"> | Date | string | null
    tokenEvolution?: StringNullableWithAggregatesFilter<"app_clinica"> | string | null
  }

  export type app_log_acaoWhereInput = {
    AND?: app_log_acaoWhereInput | app_log_acaoWhereInput[]
    OR?: app_log_acaoWhereInput[]
    NOT?: app_log_acaoWhereInput | app_log_acaoWhereInput[]
    id?: IntFilter<"app_log_acao"> | number
    usuario_id?: IntNullableFilter<"app_log_acao"> | number | null
    acao?: StringNullableFilter<"app_log_acao"> | string | null
    criado_em?: DateTimeNullableFilter<"app_log_acao"> | Date | string | null
    app_usuario?: XOR<App_usuarioNullableRelationFilter, app_usuarioWhereInput> | null
  }

  export type app_log_acaoOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrderInput | SortOrder
    acao?: SortOrderInput | SortOrder
    criado_em?: SortOrderInput | SortOrder
    app_usuario?: app_usuarioOrderByWithRelationInput
  }

  export type app_log_acaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_log_acaoWhereInput | app_log_acaoWhereInput[]
    OR?: app_log_acaoWhereInput[]
    NOT?: app_log_acaoWhereInput | app_log_acaoWhereInput[]
    usuario_id?: IntNullableFilter<"app_log_acao"> | number | null
    acao?: StringNullableFilter<"app_log_acao"> | string | null
    criado_em?: DateTimeNullableFilter<"app_log_acao"> | Date | string | null
    app_usuario?: XOR<App_usuarioNullableRelationFilter, app_usuarioWhereInput> | null
  }, "id">

  export type app_log_acaoOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrderInput | SortOrder
    acao?: SortOrderInput | SortOrder
    criado_em?: SortOrderInput | SortOrder
    _count?: app_log_acaoCountOrderByAggregateInput
    _avg?: app_log_acaoAvgOrderByAggregateInput
    _max?: app_log_acaoMaxOrderByAggregateInput
    _min?: app_log_acaoMinOrderByAggregateInput
    _sum?: app_log_acaoSumOrderByAggregateInput
  }

  export type app_log_acaoScalarWhereWithAggregatesInput = {
    AND?: app_log_acaoScalarWhereWithAggregatesInput | app_log_acaoScalarWhereWithAggregatesInput[]
    OR?: app_log_acaoScalarWhereWithAggregatesInput[]
    NOT?: app_log_acaoScalarWhereWithAggregatesInput | app_log_acaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_log_acao"> | number
    usuario_id?: IntNullableWithAggregatesFilter<"app_log_acao"> | number | null
    acao?: StringNullableWithAggregatesFilter<"app_log_acao"> | string | null
    criado_em?: DateTimeNullableWithAggregatesFilter<"app_log_acao"> | Date | string | null
  }

  export type app_conversaWhereInput = {
    AND?: app_conversaWhereInput | app_conversaWhereInput[]
    OR?: app_conversaWhereInput[]
    NOT?: app_conversaWhereInput | app_conversaWhereInput[]
    id?: IntFilter<"app_conversa"> | number
    paciente_id?: IntNullableFilter<"app_conversa"> | number | null
    clinica_id?: IntNullableFilter<"app_conversa"> | number | null
    iniciada_em?: DateTimeNullableFilter<"app_conversa"> | Date | string | null
    atualizada_em?: DateTimeNullableFilter<"app_conversa"> | Date | string | null
    grupo_id?: IntNullableFilter<"app_conversa"> | number | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
    app_paciente?: XOR<App_pacienteNullableRelationFilter, app_pacienteWhereInput> | null
    app_grupo?: XOR<App_grupoNullableRelationFilter, app_grupoWhereInput> | null
    app_mensagem?: App_mensagemListRelationFilter
  }

  export type app_conversaOrderByWithRelationInput = {
    id?: SortOrder
    paciente_id?: SortOrderInput | SortOrder
    clinica_id?: SortOrderInput | SortOrder
    iniciada_em?: SortOrderInput | SortOrder
    atualizada_em?: SortOrderInput | SortOrder
    grupo_id?: SortOrderInput | SortOrder
    app_clinica?: app_clinicaOrderByWithRelationInput
    app_paciente?: app_pacienteOrderByWithRelationInput
    app_grupo?: app_grupoOrderByWithRelationInput
    app_mensagem?: app_mensagemOrderByRelationAggregateInput
  }

  export type app_conversaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_conversaWhereInput | app_conversaWhereInput[]
    OR?: app_conversaWhereInput[]
    NOT?: app_conversaWhereInput | app_conversaWhereInput[]
    paciente_id?: IntNullableFilter<"app_conversa"> | number | null
    clinica_id?: IntNullableFilter<"app_conversa"> | number | null
    iniciada_em?: DateTimeNullableFilter<"app_conversa"> | Date | string | null
    atualizada_em?: DateTimeNullableFilter<"app_conversa"> | Date | string | null
    grupo_id?: IntNullableFilter<"app_conversa"> | number | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
    app_paciente?: XOR<App_pacienteNullableRelationFilter, app_pacienteWhereInput> | null
    app_grupo?: XOR<App_grupoNullableRelationFilter, app_grupoWhereInput> | null
    app_mensagem?: App_mensagemListRelationFilter
  }, "id">

  export type app_conversaOrderByWithAggregationInput = {
    id?: SortOrder
    paciente_id?: SortOrderInput | SortOrder
    clinica_id?: SortOrderInput | SortOrder
    iniciada_em?: SortOrderInput | SortOrder
    atualizada_em?: SortOrderInput | SortOrder
    grupo_id?: SortOrderInput | SortOrder
    _count?: app_conversaCountOrderByAggregateInput
    _avg?: app_conversaAvgOrderByAggregateInput
    _max?: app_conversaMaxOrderByAggregateInput
    _min?: app_conversaMinOrderByAggregateInput
    _sum?: app_conversaSumOrderByAggregateInput
  }

  export type app_conversaScalarWhereWithAggregatesInput = {
    AND?: app_conversaScalarWhereWithAggregatesInput | app_conversaScalarWhereWithAggregatesInput[]
    OR?: app_conversaScalarWhereWithAggregatesInput[]
    NOT?: app_conversaScalarWhereWithAggregatesInput | app_conversaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_conversa"> | number
    paciente_id?: IntNullableWithAggregatesFilter<"app_conversa"> | number | null
    clinica_id?: IntNullableWithAggregatesFilter<"app_conversa"> | number | null
    iniciada_em?: DateTimeNullableWithAggregatesFilter<"app_conversa"> | Date | string | null
    atualizada_em?: DateTimeNullableWithAggregatesFilter<"app_conversa"> | Date | string | null
    grupo_id?: IntNullableWithAggregatesFilter<"app_conversa"> | number | null
  }

  export type app_mensagemWhereInput = {
    AND?: app_mensagemWhereInput | app_mensagemWhereInput[]
    OR?: app_mensagemWhereInput[]
    NOT?: app_mensagemWhereInput | app_mensagemWhereInput[]
    id?: IntFilter<"app_mensagem"> | number
    conversa_id?: IntNullableFilter<"app_mensagem"> | number | null
    remetente?: StringNullableFilter<"app_mensagem"> | string | null
    conteudo?: StringNullableFilter<"app_mensagem"> | string | null
    tipo_mensagem?: StringNullableFilter<"app_mensagem"> | string | null
    evolution_id?: StringNullableFilter<"app_mensagem"> | string | null
    status?: StringNullableFilter<"app_mensagem"> | string | null
    criadaEm?: DateTimeNullableFilter<"app_mensagem"> | Date | string | null
    app_conversa?: XOR<App_conversaNullableRelationFilter, app_conversaWhereInput> | null
    app_midia?: App_midiaListRelationFilter
    app_receipt?: App_receiptListRelationFilter
  }

  export type app_mensagemOrderByWithRelationInput = {
    id?: SortOrder
    conversa_id?: SortOrderInput | SortOrder
    remetente?: SortOrderInput | SortOrder
    conteudo?: SortOrderInput | SortOrder
    tipo_mensagem?: SortOrderInput | SortOrder
    evolution_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    criadaEm?: SortOrderInput | SortOrder
    app_conversa?: app_conversaOrderByWithRelationInput
    app_midia?: app_midiaOrderByRelationAggregateInput
    app_receipt?: app_receiptOrderByRelationAggregateInput
  }

  export type app_mensagemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    evolution_id?: string
    AND?: app_mensagemWhereInput | app_mensagemWhereInput[]
    OR?: app_mensagemWhereInput[]
    NOT?: app_mensagemWhereInput | app_mensagemWhereInput[]
    conversa_id?: IntNullableFilter<"app_mensagem"> | number | null
    remetente?: StringNullableFilter<"app_mensagem"> | string | null
    conteudo?: StringNullableFilter<"app_mensagem"> | string | null
    tipo_mensagem?: StringNullableFilter<"app_mensagem"> | string | null
    status?: StringNullableFilter<"app_mensagem"> | string | null
    criadaEm?: DateTimeNullableFilter<"app_mensagem"> | Date | string | null
    app_conversa?: XOR<App_conversaNullableRelationFilter, app_conversaWhereInput> | null
    app_midia?: App_midiaListRelationFilter
    app_receipt?: App_receiptListRelationFilter
  }, "id" | "evolution_id">

  export type app_mensagemOrderByWithAggregationInput = {
    id?: SortOrder
    conversa_id?: SortOrderInput | SortOrder
    remetente?: SortOrderInput | SortOrder
    conteudo?: SortOrderInput | SortOrder
    tipo_mensagem?: SortOrderInput | SortOrder
    evolution_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    criadaEm?: SortOrderInput | SortOrder
    _count?: app_mensagemCountOrderByAggregateInput
    _avg?: app_mensagemAvgOrderByAggregateInput
    _max?: app_mensagemMaxOrderByAggregateInput
    _min?: app_mensagemMinOrderByAggregateInput
    _sum?: app_mensagemSumOrderByAggregateInput
  }

  export type app_mensagemScalarWhereWithAggregatesInput = {
    AND?: app_mensagemScalarWhereWithAggregatesInput | app_mensagemScalarWhereWithAggregatesInput[]
    OR?: app_mensagemScalarWhereWithAggregatesInput[]
    NOT?: app_mensagemScalarWhereWithAggregatesInput | app_mensagemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_mensagem"> | number
    conversa_id?: IntNullableWithAggregatesFilter<"app_mensagem"> | number | null
    remetente?: StringNullableWithAggregatesFilter<"app_mensagem"> | string | null
    conteudo?: StringNullableWithAggregatesFilter<"app_mensagem"> | string | null
    tipo_mensagem?: StringNullableWithAggregatesFilter<"app_mensagem"> | string | null
    evolution_id?: StringNullableWithAggregatesFilter<"app_mensagem"> | string | null
    status?: StringNullableWithAggregatesFilter<"app_mensagem"> | string | null
    criadaEm?: DateTimeNullableWithAggregatesFilter<"app_mensagem"> | Date | string | null
  }

  export type app_mensagem_sugestaoWhereInput = {
    AND?: app_mensagem_sugestaoWhereInput | app_mensagem_sugestaoWhereInput[]
    OR?: app_mensagem_sugestaoWhereInput[]
    NOT?: app_mensagem_sugestaoWhereInput | app_mensagem_sugestaoWhereInput[]
    id?: IntFilter<"app_mensagem_sugestao"> | number
    clinica_id?: IntNullableFilter<"app_mensagem_sugestao"> | number | null
    sugestao?: StringFilter<"app_mensagem_sugestao"> | string
    criado_em?: DateTimeNullableFilter<"app_mensagem_sugestao"> | Date | string | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }

  export type app_mensagem_sugestaoOrderByWithRelationInput = {
    id?: SortOrder
    clinica_id?: SortOrderInput | SortOrder
    sugestao?: SortOrder
    criado_em?: SortOrderInput | SortOrder
    app_clinica?: app_clinicaOrderByWithRelationInput
  }

  export type app_mensagem_sugestaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_mensagem_sugestaoWhereInput | app_mensagem_sugestaoWhereInput[]
    OR?: app_mensagem_sugestaoWhereInput[]
    NOT?: app_mensagem_sugestaoWhereInput | app_mensagem_sugestaoWhereInput[]
    clinica_id?: IntNullableFilter<"app_mensagem_sugestao"> | number | null
    sugestao?: StringFilter<"app_mensagem_sugestao"> | string
    criado_em?: DateTimeNullableFilter<"app_mensagem_sugestao"> | Date | string | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }, "id">

  export type app_mensagem_sugestaoOrderByWithAggregationInput = {
    id?: SortOrder
    clinica_id?: SortOrderInput | SortOrder
    sugestao?: SortOrder
    criado_em?: SortOrderInput | SortOrder
    _count?: app_mensagem_sugestaoCountOrderByAggregateInput
    _avg?: app_mensagem_sugestaoAvgOrderByAggregateInput
    _max?: app_mensagem_sugestaoMaxOrderByAggregateInput
    _min?: app_mensagem_sugestaoMinOrderByAggregateInput
    _sum?: app_mensagem_sugestaoSumOrderByAggregateInput
  }

  export type app_mensagem_sugestaoScalarWhereWithAggregatesInput = {
    AND?: app_mensagem_sugestaoScalarWhereWithAggregatesInput | app_mensagem_sugestaoScalarWhereWithAggregatesInput[]
    OR?: app_mensagem_sugestaoScalarWhereWithAggregatesInput[]
    NOT?: app_mensagem_sugestaoScalarWhereWithAggregatesInput | app_mensagem_sugestaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_mensagem_sugestao"> | number
    clinica_id?: IntNullableWithAggregatesFilter<"app_mensagem_sugestao"> | number | null
    sugestao?: StringWithAggregatesFilter<"app_mensagem_sugestao"> | string
    criado_em?: DateTimeNullableWithAggregatesFilter<"app_mensagem_sugestao"> | Date | string | null
  }

  export type app_midiaWhereInput = {
    AND?: app_midiaWhereInput | app_midiaWhereInput[]
    OR?: app_midiaWhereInput[]
    NOT?: app_midiaWhereInput | app_midiaWhereInput[]
    id?: IntFilter<"app_midia"> | number
    mensagem_id?: IntFilter<"app_midia"> | number
    tipo?: StringNullableFilter<"app_midia"> | string | null
    file_url?: StringNullableFilter<"app_midia"> | string | null
    criado_em?: DateTimeNullableFilter<"app_midia"> | Date | string | null
    mime_type?: StringNullableFilter<"app_midia"> | string | null
    caption?: StringNullableFilter<"app_midia"> | string | null
    duration?: IntNullableFilter<"app_midia"> | number | null
    file_size?: BigIntNullableFilter<"app_midia"> | bigint | number | null
    app_mensagem?: XOR<App_mensagemRelationFilter, app_mensagemWhereInput>
  }

  export type app_midiaOrderByWithRelationInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    criado_em?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    app_mensagem?: app_mensagemOrderByWithRelationInput
  }

  export type app_midiaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_midiaWhereInput | app_midiaWhereInput[]
    OR?: app_midiaWhereInput[]
    NOT?: app_midiaWhereInput | app_midiaWhereInput[]
    mensagem_id?: IntFilter<"app_midia"> | number
    tipo?: StringNullableFilter<"app_midia"> | string | null
    file_url?: StringNullableFilter<"app_midia"> | string | null
    criado_em?: DateTimeNullableFilter<"app_midia"> | Date | string | null
    mime_type?: StringNullableFilter<"app_midia"> | string | null
    caption?: StringNullableFilter<"app_midia"> | string | null
    duration?: IntNullableFilter<"app_midia"> | number | null
    file_size?: BigIntNullableFilter<"app_midia"> | bigint | number | null
    app_mensagem?: XOR<App_mensagemRelationFilter, app_mensagemWhereInput>
  }, "id">

  export type app_midiaOrderByWithAggregationInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    criado_em?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    _count?: app_midiaCountOrderByAggregateInput
    _avg?: app_midiaAvgOrderByAggregateInput
    _max?: app_midiaMaxOrderByAggregateInput
    _min?: app_midiaMinOrderByAggregateInput
    _sum?: app_midiaSumOrderByAggregateInput
  }

  export type app_midiaScalarWhereWithAggregatesInput = {
    AND?: app_midiaScalarWhereWithAggregatesInput | app_midiaScalarWhereWithAggregatesInput[]
    OR?: app_midiaScalarWhereWithAggregatesInput[]
    NOT?: app_midiaScalarWhereWithAggregatesInput | app_midiaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_midia"> | number
    mensagem_id?: IntWithAggregatesFilter<"app_midia"> | number
    tipo?: StringNullableWithAggregatesFilter<"app_midia"> | string | null
    file_url?: StringNullableWithAggregatesFilter<"app_midia"> | string | null
    criado_em?: DateTimeNullableWithAggregatesFilter<"app_midia"> | Date | string | null
    mime_type?: StringNullableWithAggregatesFilter<"app_midia"> | string | null
    caption?: StringNullableWithAggregatesFilter<"app_midia"> | string | null
    duration?: IntNullableWithAggregatesFilter<"app_midia"> | number | null
    file_size?: BigIntNullableWithAggregatesFilter<"app_midia"> | bigint | number | null
  }

  export type app_pacienteWhereInput = {
    AND?: app_pacienteWhereInput | app_pacienteWhereInput[]
    OR?: app_pacienteWhereInput[]
    NOT?: app_pacienteWhereInput | app_pacienteWhereInput[]
    id?: IntFilter<"app_paciente"> | number
    nome?: StringFilter<"app_paciente"> | string
    email?: StringNullableFilter<"app_paciente"> | string | null
    telefone?: StringFilter<"app_paciente"> | string
    criado_em?: DateTimeNullableFilter<"app_paciente"> | Date | string | null
    atualizado_em?: DateTimeNullableFilter<"app_paciente"> | Date | string | null
    clinica_id?: IntNullableFilter<"app_paciente"> | number | null
    app_conversa?: App_conversaListRelationFilter
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
    app_paciente_clinica?: App_paciente_clinicaListRelationFilter
  }

  export type app_pacienteOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrder
    criado_em?: SortOrderInput | SortOrder
    atualizado_em?: SortOrderInput | SortOrder
    clinica_id?: SortOrderInput | SortOrder
    app_conversa?: app_conversaOrderByRelationAggregateInput
    app_clinica?: app_clinicaOrderByWithRelationInput
    app_paciente_clinica?: app_paciente_clinicaOrderByRelationAggregateInput
  }

  export type app_pacienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telefone_clinica_id?: app_pacienteTelefoneClinica_idCompoundUniqueInput
    AND?: app_pacienteWhereInput | app_pacienteWhereInput[]
    OR?: app_pacienteWhereInput[]
    NOT?: app_pacienteWhereInput | app_pacienteWhereInput[]
    nome?: StringFilter<"app_paciente"> | string
    email?: StringNullableFilter<"app_paciente"> | string | null
    telefone?: StringFilter<"app_paciente"> | string
    criado_em?: DateTimeNullableFilter<"app_paciente"> | Date | string | null
    atualizado_em?: DateTimeNullableFilter<"app_paciente"> | Date | string | null
    clinica_id?: IntNullableFilter<"app_paciente"> | number | null
    app_conversa?: App_conversaListRelationFilter
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
    app_paciente_clinica?: App_paciente_clinicaListRelationFilter
  }, "id" | "telefone_clinica_id">

  export type app_pacienteOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrder
    criado_em?: SortOrderInput | SortOrder
    atualizado_em?: SortOrderInput | SortOrder
    clinica_id?: SortOrderInput | SortOrder
    _count?: app_pacienteCountOrderByAggregateInput
    _avg?: app_pacienteAvgOrderByAggregateInput
    _max?: app_pacienteMaxOrderByAggregateInput
    _min?: app_pacienteMinOrderByAggregateInput
    _sum?: app_pacienteSumOrderByAggregateInput
  }

  export type app_pacienteScalarWhereWithAggregatesInput = {
    AND?: app_pacienteScalarWhereWithAggregatesInput | app_pacienteScalarWhereWithAggregatesInput[]
    OR?: app_pacienteScalarWhereWithAggregatesInput[]
    NOT?: app_pacienteScalarWhereWithAggregatesInput | app_pacienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_paciente"> | number
    nome?: StringWithAggregatesFilter<"app_paciente"> | string
    email?: StringNullableWithAggregatesFilter<"app_paciente"> | string | null
    telefone?: StringWithAggregatesFilter<"app_paciente"> | string
    criado_em?: DateTimeNullableWithAggregatesFilter<"app_paciente"> | Date | string | null
    atualizado_em?: DateTimeNullableWithAggregatesFilter<"app_paciente"> | Date | string | null
    clinica_id?: IntNullableWithAggregatesFilter<"app_paciente"> | number | null
  }

  export type app_paciente_clinicaWhereInput = {
    AND?: app_paciente_clinicaWhereInput | app_paciente_clinicaWhereInput[]
    OR?: app_paciente_clinicaWhereInput[]
    NOT?: app_paciente_clinicaWhereInput | app_paciente_clinicaWhereInput[]
    paciente_id?: IntFilter<"app_paciente_clinica"> | number
    clinica_id?: IntFilter<"app_paciente_clinica"> | number
    app_clinica?: XOR<App_clinicaRelationFilter, app_clinicaWhereInput>
    app_paciente?: XOR<App_pacienteRelationFilter, app_pacienteWhereInput>
  }

  export type app_paciente_clinicaOrderByWithRelationInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    app_clinica?: app_clinicaOrderByWithRelationInput
    app_paciente?: app_pacienteOrderByWithRelationInput
  }

  export type app_paciente_clinicaWhereUniqueInput = Prisma.AtLeast<{
    paciente_id_clinica_id?: app_paciente_clinicaPaciente_idClinica_idCompoundUniqueInput
    AND?: app_paciente_clinicaWhereInput | app_paciente_clinicaWhereInput[]
    OR?: app_paciente_clinicaWhereInput[]
    NOT?: app_paciente_clinicaWhereInput | app_paciente_clinicaWhereInput[]
    paciente_id?: IntFilter<"app_paciente_clinica"> | number
    clinica_id?: IntFilter<"app_paciente_clinica"> | number
    app_clinica?: XOR<App_clinicaRelationFilter, app_clinicaWhereInput>
    app_paciente?: XOR<App_pacienteRelationFilter, app_pacienteWhereInput>
  }, "paciente_id_clinica_id">

  export type app_paciente_clinicaOrderByWithAggregationInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    _count?: app_paciente_clinicaCountOrderByAggregateInput
    _avg?: app_paciente_clinicaAvgOrderByAggregateInput
    _max?: app_paciente_clinicaMaxOrderByAggregateInput
    _min?: app_paciente_clinicaMinOrderByAggregateInput
    _sum?: app_paciente_clinicaSumOrderByAggregateInput
  }

  export type app_paciente_clinicaScalarWhereWithAggregatesInput = {
    AND?: app_paciente_clinicaScalarWhereWithAggregatesInput | app_paciente_clinicaScalarWhereWithAggregatesInput[]
    OR?: app_paciente_clinicaScalarWhereWithAggregatesInput[]
    NOT?: app_paciente_clinicaScalarWhereWithAggregatesInput | app_paciente_clinicaScalarWhereWithAggregatesInput[]
    paciente_id?: IntWithAggregatesFilter<"app_paciente_clinica"> | number
    clinica_id?: IntWithAggregatesFilter<"app_paciente_clinica"> | number
  }

  export type app_resposta_prontaWhereInput = {
    AND?: app_resposta_prontaWhereInput | app_resposta_prontaWhereInput[]
    OR?: app_resposta_prontaWhereInput[]
    NOT?: app_resposta_prontaWhereInput | app_resposta_prontaWhereInput[]
    id?: IntFilter<"app_resposta_pronta"> | number
    clinica_id?: IntNullableFilter<"app_resposta_pronta"> | number | null
    titulo?: StringNullableFilter<"app_resposta_pronta"> | string | null
    conteudo?: StringNullableFilter<"app_resposta_pronta"> | string | null
    criada_em?: DateTimeNullableFilter<"app_resposta_pronta"> | Date | string | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }

  export type app_resposta_prontaOrderByWithRelationInput = {
    id?: SortOrder
    clinica_id?: SortOrderInput | SortOrder
    titulo?: SortOrderInput | SortOrder
    conteudo?: SortOrderInput | SortOrder
    criada_em?: SortOrderInput | SortOrder
    app_clinica?: app_clinicaOrderByWithRelationInput
  }

  export type app_resposta_prontaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_resposta_prontaWhereInput | app_resposta_prontaWhereInput[]
    OR?: app_resposta_prontaWhereInput[]
    NOT?: app_resposta_prontaWhereInput | app_resposta_prontaWhereInput[]
    clinica_id?: IntNullableFilter<"app_resposta_pronta"> | number | null
    titulo?: StringNullableFilter<"app_resposta_pronta"> | string | null
    conteudo?: StringNullableFilter<"app_resposta_pronta"> | string | null
    criada_em?: DateTimeNullableFilter<"app_resposta_pronta"> | Date | string | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }, "id">

  export type app_resposta_prontaOrderByWithAggregationInput = {
    id?: SortOrder
    clinica_id?: SortOrderInput | SortOrder
    titulo?: SortOrderInput | SortOrder
    conteudo?: SortOrderInput | SortOrder
    criada_em?: SortOrderInput | SortOrder
    _count?: app_resposta_prontaCountOrderByAggregateInput
    _avg?: app_resposta_prontaAvgOrderByAggregateInput
    _max?: app_resposta_prontaMaxOrderByAggregateInput
    _min?: app_resposta_prontaMinOrderByAggregateInput
    _sum?: app_resposta_prontaSumOrderByAggregateInput
  }

  export type app_resposta_prontaScalarWhereWithAggregatesInput = {
    AND?: app_resposta_prontaScalarWhereWithAggregatesInput | app_resposta_prontaScalarWhereWithAggregatesInput[]
    OR?: app_resposta_prontaScalarWhereWithAggregatesInput[]
    NOT?: app_resposta_prontaScalarWhereWithAggregatesInput | app_resposta_prontaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_resposta_pronta"> | number
    clinica_id?: IntNullableWithAggregatesFilter<"app_resposta_pronta"> | number | null
    titulo?: StringNullableWithAggregatesFilter<"app_resposta_pronta"> | string | null
    conteudo?: StringNullableWithAggregatesFilter<"app_resposta_pronta"> | string | null
    criada_em?: DateTimeNullableWithAggregatesFilter<"app_resposta_pronta"> | Date | string | null
  }

  export type app_tagWhereInput = {
    AND?: app_tagWhereInput | app_tagWhereInput[]
    OR?: app_tagWhereInput[]
    NOT?: app_tagWhereInput | app_tagWhereInput[]
    id?: IntFilter<"app_tag"> | number
    nome?: StringNullableFilter<"app_tag"> | string | null
    clinica_id?: IntNullableFilter<"app_tag"> | number | null
    criada_em?: DateTimeNullableFilter<"app_tag"> | Date | string | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }

  export type app_tagOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrderInput | SortOrder
    clinica_id?: SortOrderInput | SortOrder
    criada_em?: SortOrderInput | SortOrder
    app_clinica?: app_clinicaOrderByWithRelationInput
  }

  export type app_tagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_tagWhereInput | app_tagWhereInput[]
    OR?: app_tagWhereInput[]
    NOT?: app_tagWhereInput | app_tagWhereInput[]
    nome?: StringNullableFilter<"app_tag"> | string | null
    clinica_id?: IntNullableFilter<"app_tag"> | number | null
    criada_em?: DateTimeNullableFilter<"app_tag"> | Date | string | null
    app_clinica?: XOR<App_clinicaNullableRelationFilter, app_clinicaWhereInput> | null
  }, "id">

  export type app_tagOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrderInput | SortOrder
    clinica_id?: SortOrderInput | SortOrder
    criada_em?: SortOrderInput | SortOrder
    _count?: app_tagCountOrderByAggregateInput
    _avg?: app_tagAvgOrderByAggregateInput
    _max?: app_tagMaxOrderByAggregateInput
    _min?: app_tagMinOrderByAggregateInput
    _sum?: app_tagSumOrderByAggregateInput
  }

  export type app_tagScalarWhereWithAggregatesInput = {
    AND?: app_tagScalarWhereWithAggregatesInput | app_tagScalarWhereWithAggregatesInput[]
    OR?: app_tagScalarWhereWithAggregatesInput[]
    NOT?: app_tagScalarWhereWithAggregatesInput | app_tagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_tag"> | number
    nome?: StringNullableWithAggregatesFilter<"app_tag"> | string | null
    clinica_id?: IntNullableWithAggregatesFilter<"app_tag"> | number | null
    criada_em?: DateTimeNullableWithAggregatesFilter<"app_tag"> | Date | string | null
  }

  export type consultasWhereInput = {
    AND?: consultasWhereInput | consultasWhereInput[]
    OR?: consultasWhereInput[]
    NOT?: consultasWhereInput | consultasWhereInput[]
    id?: IntFilter<"consultas"> | number
    medico_id?: IntNullableFilter<"consultas"> | number | null
    data_hora?: DateTimeFilter<"consultas"> | Date | string
    tipo?: StringFilter<"consultas"> | string
    status?: StringFilter<"consultas"> | string
    paciente_id?: StringNullableFilter<"consultas"> | string | null
    medicos?: XOR<MedicosNullableRelationFilter, medicosWhereInput> | null
    pacientes?: XOR<PacientesNullableRelationFilter, pacientesWhereInput> | null
  }

  export type consultasOrderByWithRelationInput = {
    id?: SortOrder
    medico_id?: SortOrderInput | SortOrder
    data_hora?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    paciente_id?: SortOrderInput | SortOrder
    medicos?: medicosOrderByWithRelationInput
    pacientes?: pacientesOrderByWithRelationInput
  }

  export type consultasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: consultasWhereInput | consultasWhereInput[]
    OR?: consultasWhereInput[]
    NOT?: consultasWhereInput | consultasWhereInput[]
    medico_id?: IntNullableFilter<"consultas"> | number | null
    data_hora?: DateTimeFilter<"consultas"> | Date | string
    tipo?: StringFilter<"consultas"> | string
    status?: StringFilter<"consultas"> | string
    paciente_id?: StringNullableFilter<"consultas"> | string | null
    medicos?: XOR<MedicosNullableRelationFilter, medicosWhereInput> | null
    pacientes?: XOR<PacientesNullableRelationFilter, pacientesWhereInput> | null
  }, "id">

  export type consultasOrderByWithAggregationInput = {
    id?: SortOrder
    medico_id?: SortOrderInput | SortOrder
    data_hora?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    paciente_id?: SortOrderInput | SortOrder
    _count?: consultasCountOrderByAggregateInput
    _avg?: consultasAvgOrderByAggregateInput
    _max?: consultasMaxOrderByAggregateInput
    _min?: consultasMinOrderByAggregateInput
    _sum?: consultasSumOrderByAggregateInput
  }

  export type consultasScalarWhereWithAggregatesInput = {
    AND?: consultasScalarWhereWithAggregatesInput | consultasScalarWhereWithAggregatesInput[]
    OR?: consultasScalarWhereWithAggregatesInput[]
    NOT?: consultasScalarWhereWithAggregatesInput | consultasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"consultas"> | number
    medico_id?: IntNullableWithAggregatesFilter<"consultas"> | number | null
    data_hora?: DateTimeWithAggregatesFilter<"consultas"> | Date | string
    tipo?: StringWithAggregatesFilter<"consultas"> | string
    status?: StringWithAggregatesFilter<"consultas"> | string
    paciente_id?: StringNullableWithAggregatesFilter<"consultas"> | string | null
  }

  export type conversationsWhereInput = {
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    id?: IntFilter<"conversations"> | number
    telefone_user?: StringFilter<"conversations"> | string
    messages?: JsonFilter<"conversations">
    created_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
  }

  export type conversationsOrderByWithRelationInput = {
    id?: SortOrder
    telefone_user?: SortOrder
    messages?: SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type conversationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    telefone_user?: StringFilter<"conversations"> | string
    messages?: JsonFilter<"conversations">
    created_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
  }, "id">

  export type conversationsOrderByWithAggregationInput = {
    id?: SortOrder
    telefone_user?: SortOrder
    messages?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: conversationsCountOrderByAggregateInput
    _avg?: conversationsAvgOrderByAggregateInput
    _max?: conversationsMaxOrderByAggregateInput
    _min?: conversationsMinOrderByAggregateInput
    _sum?: conversationsSumOrderByAggregateInput
  }

  export type conversationsScalarWhereWithAggregatesInput = {
    AND?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    OR?: conversationsScalarWhereWithAggregatesInput[]
    NOT?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"conversations"> | number
    telefone_user?: StringWithAggregatesFilter<"conversations"> | string
    messages?: JsonWithAggregatesFilter<"conversations">
    created_at?: DateTimeNullableWithAggregatesFilter<"conversations"> | Date | string | null
  }

  export type documentsWhereInput = {
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    id?: BigIntFilter<"documents"> | bigint | number
    text?: StringFilter<"documents"> | string
    metadata?: JsonNullableFilter<"documents">
  }

  export type documentsOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    text?: StringFilter<"documents"> | string
    metadata?: JsonNullableFilter<"documents">
  }, "id">

  export type documentsOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: documentsCountOrderByAggregateInput
    _avg?: documentsAvgOrderByAggregateInput
    _max?: documentsMaxOrderByAggregateInput
    _min?: documentsMinOrderByAggregateInput
    _sum?: documentsSumOrderByAggregateInput
  }

  export type documentsScalarWhereWithAggregatesInput = {
    AND?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    OR?: documentsScalarWhereWithAggregatesInput[]
    NOT?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"documents"> | bigint | number
    text?: StringWithAggregatesFilter<"documents"> | string
    metadata?: JsonNullableWithAggregatesFilter<"documents">
  }

  export type especialidadesWhereInput = {
    AND?: especialidadesWhereInput | especialidadesWhereInput[]
    OR?: especialidadesWhereInput[]
    NOT?: especialidadesWhereInput | especialidadesWhereInput[]
    id?: IntFilter<"especialidades"> | number
    nome?: StringFilter<"especialidades"> | string
    descricao?: StringNullableFilter<"especialidades"> | string | null
    medicos?: MedicosListRelationFilter
  }

  export type especialidadesOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    medicos?: medicosOrderByRelationAggregateInput
  }

  export type especialidadesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: especialidadesWhereInput | especialidadesWhereInput[]
    OR?: especialidadesWhereInput[]
    NOT?: especialidadesWhereInput | especialidadesWhereInput[]
    nome?: StringFilter<"especialidades"> | string
    descricao?: StringNullableFilter<"especialidades"> | string | null
    medicos?: MedicosListRelationFilter
  }, "id">

  export type especialidadesOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: especialidadesCountOrderByAggregateInput
    _avg?: especialidadesAvgOrderByAggregateInput
    _max?: especialidadesMaxOrderByAggregateInput
    _min?: especialidadesMinOrderByAggregateInput
    _sum?: especialidadesSumOrderByAggregateInput
  }

  export type especialidadesScalarWhereWithAggregatesInput = {
    AND?: especialidadesScalarWhereWithAggregatesInput | especialidadesScalarWhereWithAggregatesInput[]
    OR?: especialidadesScalarWhereWithAggregatesInput[]
    NOT?: especialidadesScalarWhereWithAggregatesInput | especialidadesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"especialidades"> | number
    nome?: StringWithAggregatesFilter<"especialidades"> | string
    descricao?: StringNullableWithAggregatesFilter<"especialidades"> | string | null
  }

  export type medico_procedimentosWhereInput = {
    AND?: medico_procedimentosWhereInput | medico_procedimentosWhereInput[]
    OR?: medico_procedimentosWhereInput[]
    NOT?: medico_procedimentosWhereInput | medico_procedimentosWhereInput[]
    id?: IntFilter<"medico_procedimentos"> | number
    medico_id?: IntFilter<"medico_procedimentos"> | number
    procedimento_id?: IntFilter<"medico_procedimentos"> | number
    medicos?: XOR<MedicosRelationFilter, medicosWhereInput>
    procedimentos?: XOR<ProcedimentosRelationFilter, procedimentosWhereInput>
  }

  export type medico_procedimentosOrderByWithRelationInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
    medicos?: medicosOrderByWithRelationInput
    procedimentos?: procedimentosOrderByWithRelationInput
  }

  export type medico_procedimentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: medico_procedimentosWhereInput | medico_procedimentosWhereInput[]
    OR?: medico_procedimentosWhereInput[]
    NOT?: medico_procedimentosWhereInput | medico_procedimentosWhereInput[]
    medico_id?: IntFilter<"medico_procedimentos"> | number
    procedimento_id?: IntFilter<"medico_procedimentos"> | number
    medicos?: XOR<MedicosRelationFilter, medicosWhereInput>
    procedimentos?: XOR<ProcedimentosRelationFilter, procedimentosWhereInput>
  }, "id">

  export type medico_procedimentosOrderByWithAggregationInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
    _count?: medico_procedimentosCountOrderByAggregateInput
    _avg?: medico_procedimentosAvgOrderByAggregateInput
    _max?: medico_procedimentosMaxOrderByAggregateInput
    _min?: medico_procedimentosMinOrderByAggregateInput
    _sum?: medico_procedimentosSumOrderByAggregateInput
  }

  export type medico_procedimentosScalarWhereWithAggregatesInput = {
    AND?: medico_procedimentosScalarWhereWithAggregatesInput | medico_procedimentosScalarWhereWithAggregatesInput[]
    OR?: medico_procedimentosScalarWhereWithAggregatesInput[]
    NOT?: medico_procedimentosScalarWhereWithAggregatesInput | medico_procedimentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"medico_procedimentos"> | number
    medico_id?: IntWithAggregatesFilter<"medico_procedimentos"> | number
    procedimento_id?: IntWithAggregatesFilter<"medico_procedimentos"> | number
  }

  export type medico_sintomasWhereInput = {
    AND?: medico_sintomasWhereInput | medico_sintomasWhereInput[]
    OR?: medico_sintomasWhereInput[]
    NOT?: medico_sintomasWhereInput | medico_sintomasWhereInput[]
    id?: IntFilter<"medico_sintomas"> | number
    medico_id?: IntFilter<"medico_sintomas"> | number
    sintoma_id?: IntFilter<"medico_sintomas"> | number
    medicos?: XOR<MedicosRelationFilter, medicosWhereInput>
    sintomas?: XOR<SintomasRelationFilter, sintomasWhereInput>
  }

  export type medico_sintomasOrderByWithRelationInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
    medicos?: medicosOrderByWithRelationInput
    sintomas?: sintomasOrderByWithRelationInput
  }

  export type medico_sintomasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: medico_sintomasWhereInput | medico_sintomasWhereInput[]
    OR?: medico_sintomasWhereInput[]
    NOT?: medico_sintomasWhereInput | medico_sintomasWhereInput[]
    medico_id?: IntFilter<"medico_sintomas"> | number
    sintoma_id?: IntFilter<"medico_sintomas"> | number
    medicos?: XOR<MedicosRelationFilter, medicosWhereInput>
    sintomas?: XOR<SintomasRelationFilter, sintomasWhereInput>
  }, "id">

  export type medico_sintomasOrderByWithAggregationInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
    _count?: medico_sintomasCountOrderByAggregateInput
    _avg?: medico_sintomasAvgOrderByAggregateInput
    _max?: medico_sintomasMaxOrderByAggregateInput
    _min?: medico_sintomasMinOrderByAggregateInput
    _sum?: medico_sintomasSumOrderByAggregateInput
  }

  export type medico_sintomasScalarWhereWithAggregatesInput = {
    AND?: medico_sintomasScalarWhereWithAggregatesInput | medico_sintomasScalarWhereWithAggregatesInput[]
    OR?: medico_sintomasScalarWhereWithAggregatesInput[]
    NOT?: medico_sintomasScalarWhereWithAggregatesInput | medico_sintomasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"medico_sintomas"> | number
    medico_id?: IntWithAggregatesFilter<"medico_sintomas"> | number
    sintoma_id?: IntWithAggregatesFilter<"medico_sintomas"> | number
  }

  export type medicosWhereInput = {
    AND?: medicosWhereInput | medicosWhereInput[]
    OR?: medicosWhereInput[]
    NOT?: medicosWhereInput | medicosWhereInput[]
    id?: IntFilter<"medicos"> | number
    nome?: StringFilter<"medicos"> | string
    especialidade_id?: IntNullableFilter<"medicos"> | number | null
    id_calendario?: StringNullableFilter<"medicos"> | string | null
    dia_atendimento?: StringNullableFilter<"medicos"> | string | null
    metodo_pagamento?: StringNullableFilter<"medicos"> | string | null
    consultas?: ConsultasListRelationFilter
    medico_procedimentos?: Medico_procedimentosListRelationFilter
    medico_sintomas?: Medico_sintomasListRelationFilter
    especialidades?: XOR<EspecialidadesNullableRelationFilter, especialidadesWhereInput> | null
  }

  export type medicosOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    especialidade_id?: SortOrderInput | SortOrder
    id_calendario?: SortOrderInput | SortOrder
    dia_atendimento?: SortOrderInput | SortOrder
    metodo_pagamento?: SortOrderInput | SortOrder
    consultas?: consultasOrderByRelationAggregateInput
    medico_procedimentos?: medico_procedimentosOrderByRelationAggregateInput
    medico_sintomas?: medico_sintomasOrderByRelationAggregateInput
    especialidades?: especialidadesOrderByWithRelationInput
  }

  export type medicosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: medicosWhereInput | medicosWhereInput[]
    OR?: medicosWhereInput[]
    NOT?: medicosWhereInput | medicosWhereInput[]
    nome?: StringFilter<"medicos"> | string
    especialidade_id?: IntNullableFilter<"medicos"> | number | null
    id_calendario?: StringNullableFilter<"medicos"> | string | null
    dia_atendimento?: StringNullableFilter<"medicos"> | string | null
    metodo_pagamento?: StringNullableFilter<"medicos"> | string | null
    consultas?: ConsultasListRelationFilter
    medico_procedimentos?: Medico_procedimentosListRelationFilter
    medico_sintomas?: Medico_sintomasListRelationFilter
    especialidades?: XOR<EspecialidadesNullableRelationFilter, especialidadesWhereInput> | null
  }, "id">

  export type medicosOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    especialidade_id?: SortOrderInput | SortOrder
    id_calendario?: SortOrderInput | SortOrder
    dia_atendimento?: SortOrderInput | SortOrder
    metodo_pagamento?: SortOrderInput | SortOrder
    _count?: medicosCountOrderByAggregateInput
    _avg?: medicosAvgOrderByAggregateInput
    _max?: medicosMaxOrderByAggregateInput
    _min?: medicosMinOrderByAggregateInput
    _sum?: medicosSumOrderByAggregateInput
  }

  export type medicosScalarWhereWithAggregatesInput = {
    AND?: medicosScalarWhereWithAggregatesInput | medicosScalarWhereWithAggregatesInput[]
    OR?: medicosScalarWhereWithAggregatesInput[]
    NOT?: medicosScalarWhereWithAggregatesInput | medicosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"medicos"> | number
    nome?: StringWithAggregatesFilter<"medicos"> | string
    especialidade_id?: IntNullableWithAggregatesFilter<"medicos"> | number | null
    id_calendario?: StringNullableWithAggregatesFilter<"medicos"> | string | null
    dia_atendimento?: StringNullableWithAggregatesFilter<"medicos"> | string | null
    metodo_pagamento?: StringNullableWithAggregatesFilter<"medicos"> | string | null
  }

  export type n8n_chat_historiesWhereInput = {
    AND?: n8n_chat_historiesWhereInput | n8n_chat_historiesWhereInput[]
    OR?: n8n_chat_historiesWhereInput[]
    NOT?: n8n_chat_historiesWhereInput | n8n_chat_historiesWhereInput[]
    id?: IntFilter<"n8n_chat_histories"> | number
    session_id?: StringFilter<"n8n_chat_histories"> | string
    message?: JsonFilter<"n8n_chat_histories">
  }

  export type n8n_chat_historiesOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    message?: SortOrder
  }

  export type n8n_chat_historiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: n8n_chat_historiesWhereInput | n8n_chat_historiesWhereInput[]
    OR?: n8n_chat_historiesWhereInput[]
    NOT?: n8n_chat_historiesWhereInput | n8n_chat_historiesWhereInput[]
    session_id?: StringFilter<"n8n_chat_histories"> | string
    message?: JsonFilter<"n8n_chat_histories">
  }, "id">

  export type n8n_chat_historiesOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    message?: SortOrder
    _count?: n8n_chat_historiesCountOrderByAggregateInput
    _avg?: n8n_chat_historiesAvgOrderByAggregateInput
    _max?: n8n_chat_historiesMaxOrderByAggregateInput
    _min?: n8n_chat_historiesMinOrderByAggregateInput
    _sum?: n8n_chat_historiesSumOrderByAggregateInput
  }

  export type n8n_chat_historiesScalarWhereWithAggregatesInput = {
    AND?: n8n_chat_historiesScalarWhereWithAggregatesInput | n8n_chat_historiesScalarWhereWithAggregatesInput[]
    OR?: n8n_chat_historiesScalarWhereWithAggregatesInput[]
    NOT?: n8n_chat_historiesScalarWhereWithAggregatesInput | n8n_chat_historiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"n8n_chat_histories"> | number
    session_id?: StringWithAggregatesFilter<"n8n_chat_histories"> | string
    message?: JsonWithAggregatesFilter<"n8n_chat_histories">
  }

  export type pacientesWhereInput = {
    AND?: pacientesWhereInput | pacientesWhereInput[]
    OR?: pacientesWhereInput[]
    NOT?: pacientesWhereInput | pacientesWhereInput[]
    id?: IntFilter<"pacientes"> | number
    nome?: StringFilter<"pacientes"> | string
    telefone?: StringFilter<"pacientes"> | string
    consultas?: ConsultasListRelationFilter
  }

  export type pacientesOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    consultas?: consultasOrderByRelationAggregateInput
  }

  export type pacientesWhereUniqueInput = Prisma.AtLeast<{
    telefone?: string
    AND?: pacientesWhereInput | pacientesWhereInput[]
    OR?: pacientesWhereInput[]
    NOT?: pacientesWhereInput | pacientesWhereInput[]
    id?: IntFilter<"pacientes"> | number
    nome?: StringFilter<"pacientes"> | string
    consultas?: ConsultasListRelationFilter
  }, "telefone">

  export type pacientesOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    _count?: pacientesCountOrderByAggregateInput
    _avg?: pacientesAvgOrderByAggregateInput
    _max?: pacientesMaxOrderByAggregateInput
    _min?: pacientesMinOrderByAggregateInput
    _sum?: pacientesSumOrderByAggregateInput
  }

  export type pacientesScalarWhereWithAggregatesInput = {
    AND?: pacientesScalarWhereWithAggregatesInput | pacientesScalarWhereWithAggregatesInput[]
    OR?: pacientesScalarWhereWithAggregatesInput[]
    NOT?: pacientesScalarWhereWithAggregatesInput | pacientesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pacientes"> | number
    nome?: StringWithAggregatesFilter<"pacientes"> | string
    telefone?: StringWithAggregatesFilter<"pacientes"> | string
  }

  export type procedimentosWhereInput = {
    AND?: procedimentosWhereInput | procedimentosWhereInput[]
    OR?: procedimentosWhereInput[]
    NOT?: procedimentosWhereInput | procedimentosWhereInput[]
    id?: IntFilter<"procedimentos"> | number
    nome?: StringFilter<"procedimentos"> | string
    preco?: DecimalNullableFilter<"procedimentos"> | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: StringNullableFilter<"procedimentos"> | string | null
    descricao?: StringNullableFilter<"procedimentos"> | string | null
    medico_procedimentos?: Medico_procedimentosListRelationFilter
  }

  export type procedimentosOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    preco?: SortOrderInput | SortOrder
    tempo_estimado?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    medico_procedimentos?: medico_procedimentosOrderByRelationAggregateInput
  }

  export type procedimentosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: procedimentosWhereInput | procedimentosWhereInput[]
    OR?: procedimentosWhereInput[]
    NOT?: procedimentosWhereInput | procedimentosWhereInput[]
    nome?: StringFilter<"procedimentos"> | string
    preco?: DecimalNullableFilter<"procedimentos"> | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: StringNullableFilter<"procedimentos"> | string | null
    descricao?: StringNullableFilter<"procedimentos"> | string | null
    medico_procedimentos?: Medico_procedimentosListRelationFilter
  }, "id">

  export type procedimentosOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    preco?: SortOrderInput | SortOrder
    tempo_estimado?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: procedimentosCountOrderByAggregateInput
    _avg?: procedimentosAvgOrderByAggregateInput
    _max?: procedimentosMaxOrderByAggregateInput
    _min?: procedimentosMinOrderByAggregateInput
    _sum?: procedimentosSumOrderByAggregateInput
  }

  export type procedimentosScalarWhereWithAggregatesInput = {
    AND?: procedimentosScalarWhereWithAggregatesInput | procedimentosScalarWhereWithAggregatesInput[]
    OR?: procedimentosScalarWhereWithAggregatesInput[]
    NOT?: procedimentosScalarWhereWithAggregatesInput | procedimentosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"procedimentos"> | number
    nome?: StringWithAggregatesFilter<"procedimentos"> | string
    preco?: DecimalNullableWithAggregatesFilter<"procedimentos"> | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: StringNullableWithAggregatesFilter<"procedimentos"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"procedimentos"> | string | null
  }

  export type schema_migrationsWhereInput = {
    AND?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    OR?: schema_migrationsWhereInput[]
    NOT?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    version?: StringFilter<"schema_migrations"> | string
  }

  export type schema_migrationsOrderByWithRelationInput = {
    version?: SortOrder
  }

  export type schema_migrationsWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    OR?: schema_migrationsWhereInput[]
    NOT?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
  }, "version">

  export type schema_migrationsOrderByWithAggregationInput = {
    version?: SortOrder
    _count?: schema_migrationsCountOrderByAggregateInput
    _max?: schema_migrationsMaxOrderByAggregateInput
    _min?: schema_migrationsMinOrderByAggregateInput
  }

  export type schema_migrationsScalarWhereWithAggregatesInput = {
    AND?: schema_migrationsScalarWhereWithAggregatesInput | schema_migrationsScalarWhereWithAggregatesInput[]
    OR?: schema_migrationsScalarWhereWithAggregatesInput[]
    NOT?: schema_migrationsScalarWhereWithAggregatesInput | schema_migrationsScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"schema_migrations"> | string
  }

  export type sintomasWhereInput = {
    AND?: sintomasWhereInput | sintomasWhereInput[]
    OR?: sintomasWhereInput[]
    NOT?: sintomasWhereInput | sintomasWhereInput[]
    id?: IntFilter<"sintomas"> | number
    nome?: StringFilter<"sintomas"> | string
    descricao?: StringNullableFilter<"sintomas"> | string | null
    medico_sintomas?: Medico_sintomasListRelationFilter
  }

  export type sintomasOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    medico_sintomas?: medico_sintomasOrderByRelationAggregateInput
  }

  export type sintomasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sintomasWhereInput | sintomasWhereInput[]
    OR?: sintomasWhereInput[]
    NOT?: sintomasWhereInput | sintomasWhereInput[]
    nome?: StringFilter<"sintomas"> | string
    descricao?: StringNullableFilter<"sintomas"> | string | null
    medico_sintomas?: Medico_sintomasListRelationFilter
  }, "id">

  export type sintomasOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: sintomasCountOrderByAggregateInput
    _avg?: sintomasAvgOrderByAggregateInput
    _max?: sintomasMaxOrderByAggregateInput
    _min?: sintomasMinOrderByAggregateInput
    _sum?: sintomasSumOrderByAggregateInput
  }

  export type sintomasScalarWhereWithAggregatesInput = {
    AND?: sintomasScalarWhereWithAggregatesInput | sintomasScalarWhereWithAggregatesInput[]
    OR?: sintomasScalarWhereWithAggregatesInput[]
    NOT?: sintomasScalarWhereWithAggregatesInput | sintomasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sintomas"> | number
    nome?: StringWithAggregatesFilter<"sintomas"> | string
    descricao?: StringNullableWithAggregatesFilter<"sintomas"> | string | null
  }

  export type agent_controlWhereInput = {
    AND?: agent_controlWhereInput | agent_controlWhereInput[]
    OR?: agent_controlWhereInput[]
    NOT?: agent_controlWhereInput | agent_controlWhereInput[]
    numero?: StringFilter<"agent_control"> | string
    agente_ativo?: BoolFilter<"agent_control"> | boolean
    datehora?: DateTimeFilter<"agent_control"> | Date | string
    ignorar_automacao?: BoolNullableFilter<"agent_control"> | boolean | null
  }

  export type agent_controlOrderByWithRelationInput = {
    numero?: SortOrder
    agente_ativo?: SortOrder
    datehora?: SortOrder
    ignorar_automacao?: SortOrderInput | SortOrder
  }

  export type agent_controlWhereUniqueInput = Prisma.AtLeast<{
    numero?: string
    AND?: agent_controlWhereInput | agent_controlWhereInput[]
    OR?: agent_controlWhereInput[]
    NOT?: agent_controlWhereInput | agent_controlWhereInput[]
    agente_ativo?: BoolFilter<"agent_control"> | boolean
    datehora?: DateTimeFilter<"agent_control"> | Date | string
    ignorar_automacao?: BoolNullableFilter<"agent_control"> | boolean | null
  }, "numero">

  export type agent_controlOrderByWithAggregationInput = {
    numero?: SortOrder
    agente_ativo?: SortOrder
    datehora?: SortOrder
    ignorar_automacao?: SortOrderInput | SortOrder
    _count?: agent_controlCountOrderByAggregateInput
    _max?: agent_controlMaxOrderByAggregateInput
    _min?: agent_controlMinOrderByAggregateInput
  }

  export type agent_controlScalarWhereWithAggregatesInput = {
    AND?: agent_controlScalarWhereWithAggregatesInput | agent_controlScalarWhereWithAggregatesInput[]
    OR?: agent_controlScalarWhereWithAggregatesInput[]
    NOT?: agent_controlScalarWhereWithAggregatesInput | agent_controlScalarWhereWithAggregatesInput[]
    numero?: StringWithAggregatesFilter<"agent_control"> | string
    agente_ativo?: BoolWithAggregatesFilter<"agent_control"> | boolean
    datehora?: DateTimeWithAggregatesFilter<"agent_control"> | Date | string
    ignorar_automacao?: BoolNullableWithAggregatesFilter<"agent_control"> | boolean | null
  }

  export type app_grupoWhereInput = {
    AND?: app_grupoWhereInput | app_grupoWhereInput[]
    OR?: app_grupoWhereInput[]
    NOT?: app_grupoWhereInput | app_grupoWhereInput[]
    id?: IntFilter<"app_grupo"> | number
    jid?: StringFilter<"app_grupo"> | string
    nome?: StringNullableFilter<"app_grupo"> | string | null
    clinica_id?: IntFilter<"app_grupo"> | number
    criado_em?: DateTimeNullableFilter<"app_grupo"> | Date | string | null
    app_conversa?: App_conversaListRelationFilter
    app_clinica?: XOR<App_clinicaRelationFilter, app_clinicaWhereInput>
  }

  export type app_grupoOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    nome?: SortOrderInput | SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrderInput | SortOrder
    app_conversa?: app_conversaOrderByRelationAggregateInput
    app_clinica?: app_clinicaOrderByWithRelationInput
  }

  export type app_grupoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    jid?: string
    AND?: app_grupoWhereInput | app_grupoWhereInput[]
    OR?: app_grupoWhereInput[]
    NOT?: app_grupoWhereInput | app_grupoWhereInput[]
    nome?: StringNullableFilter<"app_grupo"> | string | null
    clinica_id?: IntFilter<"app_grupo"> | number
    criado_em?: DateTimeNullableFilter<"app_grupo"> | Date | string | null
    app_conversa?: App_conversaListRelationFilter
    app_clinica?: XOR<App_clinicaRelationFilter, app_clinicaWhereInput>
  }, "id" | "jid">

  export type app_grupoOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    nome?: SortOrderInput | SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrderInput | SortOrder
    _count?: app_grupoCountOrderByAggregateInput
    _avg?: app_grupoAvgOrderByAggregateInput
    _max?: app_grupoMaxOrderByAggregateInput
    _min?: app_grupoMinOrderByAggregateInput
    _sum?: app_grupoSumOrderByAggregateInput
  }

  export type app_grupoScalarWhereWithAggregatesInput = {
    AND?: app_grupoScalarWhereWithAggregatesInput | app_grupoScalarWhereWithAggregatesInput[]
    OR?: app_grupoScalarWhereWithAggregatesInput[]
    NOT?: app_grupoScalarWhereWithAggregatesInput | app_grupoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_grupo"> | number
    jid?: StringWithAggregatesFilter<"app_grupo"> | string
    nome?: StringNullableWithAggregatesFilter<"app_grupo"> | string | null
    clinica_id?: IntWithAggregatesFilter<"app_grupo"> | number
    criado_em?: DateTimeNullableWithAggregatesFilter<"app_grupo"> | Date | string | null
  }

  export type app_receiptWhereInput = {
    AND?: app_receiptWhereInput | app_receiptWhereInput[]
    OR?: app_receiptWhereInput[]
    NOT?: app_receiptWhereInput | app_receiptWhereInput[]
    id?: IntFilter<"app_receipt"> | number
    mensagem_id?: IntFilter<"app_receipt"> | number
    event_type?: StringFilter<"app_receipt"> | string
    receipt_time?: DateTimeFilter<"app_receipt"> | Date | string
    created_at?: DateTimeNullableFilter<"app_receipt"> | Date | string | null
    app_mensagem?: XOR<App_mensagemRelationFilter, app_mensagemWhereInput>
  }

  export type app_receiptOrderByWithRelationInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    event_type?: SortOrder
    receipt_time?: SortOrder
    created_at?: SortOrderInput | SortOrder
    app_mensagem?: app_mensagemOrderByWithRelationInput
  }

  export type app_receiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_receiptWhereInput | app_receiptWhereInput[]
    OR?: app_receiptWhereInput[]
    NOT?: app_receiptWhereInput | app_receiptWhereInput[]
    mensagem_id?: IntFilter<"app_receipt"> | number
    event_type?: StringFilter<"app_receipt"> | string
    receipt_time?: DateTimeFilter<"app_receipt"> | Date | string
    created_at?: DateTimeNullableFilter<"app_receipt"> | Date | string | null
    app_mensagem?: XOR<App_mensagemRelationFilter, app_mensagemWhereInput>
  }, "id">

  export type app_receiptOrderByWithAggregationInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    event_type?: SortOrder
    receipt_time?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: app_receiptCountOrderByAggregateInput
    _avg?: app_receiptAvgOrderByAggregateInput
    _max?: app_receiptMaxOrderByAggregateInput
    _min?: app_receiptMinOrderByAggregateInput
    _sum?: app_receiptSumOrderByAggregateInput
  }

  export type app_receiptScalarWhereWithAggregatesInput = {
    AND?: app_receiptScalarWhereWithAggregatesInput | app_receiptScalarWhereWithAggregatesInput[]
    OR?: app_receiptScalarWhereWithAggregatesInput[]
    NOT?: app_receiptScalarWhereWithAggregatesInput | app_receiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_receipt"> | number
    mensagem_id?: IntWithAggregatesFilter<"app_receipt"> | number
    event_type?: StringWithAggregatesFilter<"app_receipt"> | string
    receipt_time?: DateTimeWithAggregatesFilter<"app_receipt"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"app_receipt"> | Date | string | null
  }

  export type app_usuarioCreateInput = {
    nome: string
    email: string
    senha: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_log_acao?: app_log_acaoCreateNestedManyWithoutApp_usuarioInput
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaCreateNestedOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_usuarioInput
  }

  export type app_usuarioUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    senha: string
    clinica_id?: number | null
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinicaId?: number | null
    app_log_acao?: app_log_acaoUncheckedCreateNestedManyWithoutApp_usuarioInput
  }

  export type app_usuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_log_acao?: app_log_acaoUpdateManyWithoutApp_usuarioNestedInput
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaUpdateOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_clinica?: app_clinicaUpdateOneWithoutApp_usuarioNestedInput
  }

  export type app_usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    app_log_acao?: app_log_acaoUncheckedUpdateManyWithoutApp_usuarioNestedInput
  }

  export type app_usuarioCreateManyInput = {
    id?: number
    nome: string
    email: string
    senha: string
    clinica_id?: number | null
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinicaId?: number | null
  }

  export type app_usuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_clinicaCreateInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaCreateManyInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
  }

  export type app_clinicaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type app_clinicaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type app_log_acaoCreateInput = {
    acao?: string | null
    criado_em?: Date | string | null
    app_usuario?: app_usuarioCreateNestedOneWithoutApp_log_acaoInput
  }

  export type app_log_acaoUncheckedCreateInput = {
    id?: number
    usuario_id?: number | null
    acao?: string | null
    criado_em?: Date | string | null
  }

  export type app_log_acaoUpdateInput = {
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_usuario?: app_usuarioUpdateOneWithoutApp_log_acaoNestedInput
  }

  export type app_log_acaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_log_acaoCreateManyInput = {
    id?: number
    usuario_id?: number | null
    acao?: string | null
    criado_em?: Date | string | null
  }

  export type app_log_acaoUpdateManyMutationInput = {
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_log_acaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_conversaCreateInput = {
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_conversaInput
    app_paciente?: app_pacienteCreateNestedOneWithoutApp_conversaInput
    app_grupo?: app_grupoCreateNestedOneWithoutApp_conversaInput
    app_mensagem?: app_mensagemCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaUncheckedCreateInput = {
    id?: number
    paciente_id?: number | null
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
    app_mensagem?: app_mensagemUncheckedCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaUpdateInput = {
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_conversaNestedInput
    app_paciente?: app_pacienteUpdateOneWithoutApp_conversaNestedInput
    app_grupo?: app_grupoUpdateOneWithoutApp_conversaNestedInput
    app_mensagem?: app_mensagemUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
    app_mensagem?: app_mensagemUncheckedUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaCreateManyInput = {
    id?: number
    paciente_id?: number | null
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
  }

  export type app_conversaUpdateManyMutationInput = {
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_conversaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_mensagemCreateInput = {
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_conversa?: app_conversaCreateNestedOneWithoutApp_mensagemInput
    app_midia?: app_midiaCreateNestedManyWithoutApp_mensagemInput
    app_receipt?: app_receiptCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemUncheckedCreateInput = {
    id?: number
    conversa_id?: number | null
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_midia?: app_midiaUncheckedCreateNestedManyWithoutApp_mensagemInput
    app_receipt?: app_receiptUncheckedCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemUpdateInput = {
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateOneWithoutApp_mensagemNestedInput
    app_midia?: app_midiaUpdateManyWithoutApp_mensagemNestedInput
    app_receipt?: app_receiptUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_mensagemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversa_id?: NullableIntFieldUpdateOperationsInput | number | null
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_midia?: app_midiaUncheckedUpdateManyWithoutApp_mensagemNestedInput
    app_receipt?: app_receiptUncheckedUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_mensagemCreateManyInput = {
    id?: number
    conversa_id?: number | null
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
  }

  export type app_mensagemUpdateManyMutationInput = {
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversa_id?: NullableIntFieldUpdateOperationsInput | number | null
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagem_sugestaoCreateInput = {
    sugestao: string
    criado_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_mensagem_sugestaoInput
  }

  export type app_mensagem_sugestaoUncheckedCreateInput = {
    id?: number
    clinica_id?: number | null
    sugestao: string
    criado_em?: Date | string | null
  }

  export type app_mensagem_sugestaoUpdateInput = {
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_mensagem_sugestaoNestedInput
  }

  export type app_mensagem_sugestaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagem_sugestaoCreateManyInput = {
    id?: number
    clinica_id?: number | null
    sugestao: string
    criado_em?: Date | string | null
  }

  export type app_mensagem_sugestaoUpdateManyMutationInput = {
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagem_sugestaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_midiaCreateInput = {
    tipo?: string | null
    file_url?: string | null
    criado_em?: Date | string | null
    mime_type?: string | null
    caption?: string | null
    duration?: number | null
    file_size?: bigint | number | null
    app_mensagem: app_mensagemCreateNestedOneWithoutApp_midiaInput
  }

  export type app_midiaUncheckedCreateInput = {
    id?: number
    mensagem_id: number
    tipo?: string | null
    file_url?: string | null
    criado_em?: Date | string | null
    mime_type?: string | null
    caption?: string | null
    duration?: number | null
    file_size?: bigint | number | null
  }

  export type app_midiaUpdateInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    app_mensagem?: app_mensagemUpdateOneRequiredWithoutApp_midiaNestedInput
  }

  export type app_midiaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type app_midiaCreateManyInput = {
    id?: number
    mensagem_id: number
    tipo?: string | null
    file_url?: string | null
    criado_em?: Date | string | null
    mime_type?: string | null
    caption?: string | null
    duration?: number | null
    file_size?: bigint | number | null
  }

  export type app_midiaUpdateManyMutationInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type app_midiaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem_id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type app_pacienteCreateInput = {
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_pacienteInput
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_pacienteInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteUncheckedCreateInput = {
    id?: number
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinica_id?: number | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_pacienteInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_pacienteNestedInput
    app_clinica?: app_clinicaUpdateOneWithoutApp_pacienteNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_pacienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_pacienteNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_pacienteCreateManyInput = {
    id?: number
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinica_id?: number | null
  }

  export type app_pacienteUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_pacienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_paciente_clinicaCreateInput = {
    app_clinica: app_clinicaCreateNestedOneWithoutApp_paciente_clinicaInput
    app_paciente: app_pacienteCreateNestedOneWithoutApp_paciente_clinicaInput
  }

  export type app_paciente_clinicaUncheckedCreateInput = {
    paciente_id: number
    clinica_id: number
  }

  export type app_paciente_clinicaUpdateInput = {
    app_clinica?: app_clinicaUpdateOneRequiredWithoutApp_paciente_clinicaNestedInput
    app_paciente?: app_pacienteUpdateOneRequiredWithoutApp_paciente_clinicaNestedInput
  }

  export type app_paciente_clinicaUncheckedUpdateInput = {
    paciente_id?: IntFieldUpdateOperationsInput | number
    clinica_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_paciente_clinicaCreateManyInput = {
    paciente_id: number
    clinica_id: number
  }

  export type app_paciente_clinicaUpdateManyMutationInput = {

  }

  export type app_paciente_clinicaUncheckedUpdateManyInput = {
    paciente_id?: IntFieldUpdateOperationsInput | number
    clinica_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_resposta_prontaCreateInput = {
    titulo?: string | null
    conteudo?: string | null
    criada_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_resposta_prontaInput
  }

  export type app_resposta_prontaUncheckedCreateInput = {
    id?: number
    clinica_id?: number | null
    titulo?: string | null
    conteudo?: string | null
    criada_em?: Date | string | null
  }

  export type app_resposta_prontaUpdateInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_resposta_prontaNestedInput
  }

  export type app_resposta_prontaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_resposta_prontaCreateManyInput = {
    id?: number
    clinica_id?: number | null
    titulo?: string | null
    conteudo?: string | null
    criada_em?: Date | string | null
  }

  export type app_resposta_prontaUpdateManyMutationInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_resposta_prontaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_tagCreateInput = {
    nome?: string | null
    criada_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_tagInput
  }

  export type app_tagUncheckedCreateInput = {
    id?: number
    nome?: string | null
    clinica_id?: number | null
    criada_em?: Date | string | null
  }

  export type app_tagUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_tagNestedInput
  }

  export type app_tagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_tagCreateManyInput = {
    id?: number
    nome?: string | null
    clinica_id?: number | null
    criada_em?: Date | string | null
  }

  export type app_tagUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_tagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type consultasCreateInput = {
    data_hora: Date | string
    tipo: string
    status?: string
    medicos?: medicosCreateNestedOneWithoutConsultasInput
    pacientes?: pacientesCreateNestedOneWithoutConsultasInput
  }

  export type consultasUncheckedCreateInput = {
    id?: number
    medico_id?: number | null
    data_hora: Date | string
    tipo: string
    status?: string
    paciente_id?: string | null
  }

  export type consultasUpdateInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    medicos?: medicosUpdateOneWithoutConsultasNestedInput
    pacientes?: pacientesUpdateOneWithoutConsultasNestedInput
  }

  export type consultasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: NullableIntFieldUpdateOperationsInput | number | null
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paciente_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type consultasCreateManyInput = {
    id?: number
    medico_id?: number | null
    data_hora: Date | string
    tipo: string
    status?: string
    paciente_id?: string | null
  }

  export type consultasUpdateManyMutationInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type consultasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: NullableIntFieldUpdateOperationsInput | number | null
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paciente_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conversationsCreateInput = {
    telefone_user: string
    messages: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type conversationsUncheckedCreateInput = {
    id?: number
    telefone_user: string
    messages: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type conversationsUpdateInput = {
    telefone_user?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telefone_user?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsCreateManyInput = {
    id?: number
    telefone_user: string
    messages: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type conversationsUpdateManyMutationInput = {
    telefone_user?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telefone_user?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsCreateInput = {
    id?: bigint | number
    text: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type documentsUncheckedCreateInput = {
    id?: bigint | number
    text: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type documentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type documentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type documentsCreateManyInput = {
    id?: bigint | number
    text: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type documentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type documentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type especialidadesCreateInput = {
    nome: string
    descricao?: string | null
    medicos?: medicosCreateNestedManyWithoutEspecialidadesInput
  }

  export type especialidadesUncheckedCreateInput = {
    id?: number
    nome: string
    descricao?: string | null
    medicos?: medicosUncheckedCreateNestedManyWithoutEspecialidadesInput
  }

  export type especialidadesUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    medicos?: medicosUpdateManyWithoutEspecialidadesNestedInput
  }

  export type especialidadesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    medicos?: medicosUncheckedUpdateManyWithoutEspecialidadesNestedInput
  }

  export type especialidadesCreateManyInput = {
    id?: number
    nome: string
    descricao?: string | null
  }

  export type especialidadesUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type especialidadesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medico_procedimentosCreateInput = {
    medicos: medicosCreateNestedOneWithoutMedico_procedimentosInput
    procedimentos: procedimentosCreateNestedOneWithoutMedico_procedimentosInput
  }

  export type medico_procedimentosUncheckedCreateInput = {
    id?: number
    medico_id: number
    procedimento_id: number
  }

  export type medico_procedimentosUpdateInput = {
    medicos?: medicosUpdateOneRequiredWithoutMedico_procedimentosNestedInput
    procedimentos?: procedimentosUpdateOneRequiredWithoutMedico_procedimentosNestedInput
  }

  export type medico_procedimentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
    procedimento_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_procedimentosCreateManyInput = {
    id?: number
    medico_id: number
    procedimento_id: number
  }

  export type medico_procedimentosUpdateManyMutationInput = {

  }

  export type medico_procedimentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
    procedimento_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_sintomasCreateInput = {
    medicos: medicosCreateNestedOneWithoutMedico_sintomasInput
    sintomas: sintomasCreateNestedOneWithoutMedico_sintomasInput
  }

  export type medico_sintomasUncheckedCreateInput = {
    id?: number
    medico_id: number
    sintoma_id: number
  }

  export type medico_sintomasUpdateInput = {
    medicos?: medicosUpdateOneRequiredWithoutMedico_sintomasNestedInput
    sintomas?: sintomasUpdateOneRequiredWithoutMedico_sintomasNestedInput
  }

  export type medico_sintomasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
    sintoma_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_sintomasCreateManyInput = {
    id?: number
    medico_id: number
    sintoma_id: number
  }

  export type medico_sintomasUpdateManyMutationInput = {

  }

  export type medico_sintomasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
    sintoma_id?: IntFieldUpdateOperationsInput | number
  }

  export type medicosCreateInput = {
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasCreateNestedManyWithoutMedicosInput
    medico_procedimentos?: medico_procedimentosCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasCreateNestedManyWithoutMedicosInput
    especialidades?: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateInput = {
    id?: number
    nome: string
    especialidade_id?: number | null
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasUncheckedCreateNestedManyWithoutMedicosInput
    medico_procedimentos?: medico_procedimentosUncheckedCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUpdateManyWithoutMedicosNestedInput
    medico_procedimentos?: medico_procedimentosUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especialidade_id?: NullableIntFieldUpdateOperationsInput | number | null
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUncheckedUpdateManyWithoutMedicosNestedInput
    medico_procedimentos?: medico_procedimentosUncheckedUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type medicosCreateManyInput = {
    id?: number
    nome: string
    especialidade_id?: number | null
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
  }

  export type medicosUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medicosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especialidade_id?: NullableIntFieldUpdateOperationsInput | number | null
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type n8n_chat_historiesCreateInput = {
    session_id: string
    message: JsonNullValueInput | InputJsonValue
  }

  export type n8n_chat_historiesUncheckedCreateInput = {
    id?: number
    session_id: string
    message: JsonNullValueInput | InputJsonValue
  }

  export type n8n_chat_historiesUpdateInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
  }

  export type n8n_chat_historiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
  }

  export type n8n_chat_historiesCreateManyInput = {
    id?: number
    session_id: string
    message: JsonNullValueInput | InputJsonValue
  }

  export type n8n_chat_historiesUpdateManyMutationInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
  }

  export type n8n_chat_historiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
  }

  export type pacientesCreateInput = {
    id?: number
    nome: string
    telefone: string
    consultas?: consultasCreateNestedManyWithoutPacientesInput
  }

  export type pacientesUncheckedCreateInput = {
    id?: number
    nome: string
    telefone: string
    consultas?: consultasUncheckedCreateNestedManyWithoutPacientesInput
  }

  export type pacientesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    consultas?: consultasUpdateManyWithoutPacientesNestedInput
  }

  export type pacientesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    consultas?: consultasUncheckedUpdateManyWithoutPacientesNestedInput
  }

  export type pacientesCreateManyInput = {
    id?: number
    nome: string
    telefone: string
  }

  export type pacientesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type pacientesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type procedimentosCreateInput = {
    nome: string
    preco?: Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: string | null
    descricao?: string | null
    medico_procedimentos?: medico_procedimentosCreateNestedManyWithoutProcedimentosInput
  }

  export type procedimentosUncheckedCreateInput = {
    id?: number
    nome: string
    preco?: Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: string | null
    descricao?: string | null
    medico_procedimentos?: medico_procedimentosUncheckedCreateNestedManyWithoutProcedimentosInput
  }

  export type procedimentosUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    medico_procedimentos?: medico_procedimentosUpdateManyWithoutProcedimentosNestedInput
  }

  export type procedimentosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    preco?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    medico_procedimentos?: medico_procedimentosUncheckedUpdateManyWithoutProcedimentosNestedInput
  }

  export type procedimentosCreateManyInput = {
    id?: number
    nome: string
    preco?: Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: string | null
    descricao?: string | null
  }

  export type procedimentosUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type procedimentosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    preco?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type schema_migrationsCreateInput = {
    version: string
  }

  export type schema_migrationsUncheckedCreateInput = {
    version: string
  }

  export type schema_migrationsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsCreateManyInput = {
    version: string
  }

  export type schema_migrationsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type sintomasCreateInput = {
    nome: string
    descricao?: string | null
    medico_sintomas?: medico_sintomasCreateNestedManyWithoutSintomasInput
  }

  export type sintomasUncheckedCreateInput = {
    id?: number
    nome: string
    descricao?: string | null
    medico_sintomas?: medico_sintomasUncheckedCreateNestedManyWithoutSintomasInput
  }

  export type sintomasUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    medico_sintomas?: medico_sintomasUpdateManyWithoutSintomasNestedInput
  }

  export type sintomasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    medico_sintomas?: medico_sintomasUncheckedUpdateManyWithoutSintomasNestedInput
  }

  export type sintomasCreateManyInput = {
    id?: number
    nome: string
    descricao?: string | null
  }

  export type sintomasUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sintomasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agent_controlCreateInput = {
    numero: string
    agente_ativo?: boolean
    datehora: Date | string
    ignorar_automacao?: boolean | null
  }

  export type agent_controlUncheckedCreateInput = {
    numero: string
    agente_ativo?: boolean
    datehora: Date | string
    ignorar_automacao?: boolean | null
  }

  export type agent_controlUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    agente_ativo?: BoolFieldUpdateOperationsInput | boolean
    datehora?: DateTimeFieldUpdateOperationsInput | Date | string
    ignorar_automacao?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agent_controlUncheckedUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    agente_ativo?: BoolFieldUpdateOperationsInput | boolean
    datehora?: DateTimeFieldUpdateOperationsInput | Date | string
    ignorar_automacao?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agent_controlCreateManyInput = {
    numero: string
    agente_ativo?: boolean
    datehora: Date | string
    ignorar_automacao?: boolean | null
  }

  export type agent_controlUpdateManyMutationInput = {
    numero?: StringFieldUpdateOperationsInput | string
    agente_ativo?: BoolFieldUpdateOperationsInput | boolean
    datehora?: DateTimeFieldUpdateOperationsInput | Date | string
    ignorar_automacao?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type agent_controlUncheckedUpdateManyInput = {
    numero?: StringFieldUpdateOperationsInput | string
    agente_ativo?: BoolFieldUpdateOperationsInput | boolean
    datehora?: DateTimeFieldUpdateOperationsInput | Date | string
    ignorar_automacao?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type app_grupoCreateInput = {
    jid: string
    nome?: string | null
    criado_em?: Date | string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_grupoInput
    app_clinica: app_clinicaCreateNestedOneWithoutApp_grupoInput
  }

  export type app_grupoUncheckedCreateInput = {
    id?: number
    jid: string
    nome?: string | null
    clinica_id: number
    criado_em?: Date | string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_grupoInput
  }

  export type app_grupoUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_grupoNestedInput
    app_clinica?: app_clinicaUpdateOneRequiredWithoutApp_grupoNestedInput
  }

  export type app_grupoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    clinica_id?: IntFieldUpdateOperationsInput | number
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_grupoNestedInput
  }

  export type app_grupoCreateManyInput = {
    id?: number
    jid: string
    nome?: string | null
    clinica_id: number
    criado_em?: Date | string | null
  }

  export type app_grupoUpdateManyMutationInput = {
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_grupoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    clinica_id?: IntFieldUpdateOperationsInput | number
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_receiptCreateInput = {
    event_type: string
    receipt_time: Date | string
    created_at?: Date | string | null
    app_mensagem: app_mensagemCreateNestedOneWithoutApp_receiptInput
  }

  export type app_receiptUncheckedCreateInput = {
    id?: number
    mensagem_id: number
    event_type: string
    receipt_time: Date | string
    created_at?: Date | string | null
  }

  export type app_receiptUpdateInput = {
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_mensagem?: app_mensagemUpdateOneRequiredWithoutApp_receiptNestedInput
  }

  export type app_receiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem_id?: IntFieldUpdateOperationsInput | number
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_receiptCreateManyInput = {
    id?: number
    mensagem_id: number
    event_type: string
    receipt_time: Date | string
    created_at?: Date | string | null
  }

  export type app_receiptUpdateManyMutationInput = {
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_receiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensagem_id?: IntFieldUpdateOperationsInput | number
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type App_log_acaoListRelationFilter = {
    every?: app_log_acaoWhereInput
    some?: app_log_acaoWhereInput
    none?: app_log_acaoWhereInput
  }

  export type App_clinicaNullableRelationFilter = {
    is?: app_clinicaWhereInput | null
    isNot?: app_clinicaWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type app_log_acaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrder
    atualizado_em?: SortOrder
    clinicaId?: SortOrder
  }

  export type app_usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    clinicaId?: SortOrder
  }

  export type app_usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrder
    atualizado_em?: SortOrder
    clinicaId?: SortOrder
  }

  export type app_usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrder
    atualizado_em?: SortOrder
    clinicaId?: SortOrder
  }

  export type app_usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    clinicaId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type App_conversaListRelationFilter = {
    every?: app_conversaWhereInput
    some?: app_conversaWhereInput
    none?: app_conversaWhereInput
  }

  export type App_grupoListRelationFilter = {
    every?: app_grupoWhereInput
    some?: app_grupoWhereInput
    none?: app_grupoWhereInput
  }

  export type App_mensagem_sugestaoListRelationFilter = {
    every?: app_mensagem_sugestaoWhereInput
    some?: app_mensagem_sugestaoWhereInput
    none?: app_mensagem_sugestaoWhereInput
  }

  export type App_pacienteListRelationFilter = {
    every?: app_pacienteWhereInput
    some?: app_pacienteWhereInput
    none?: app_pacienteWhereInput
  }

  export type App_paciente_clinicaListRelationFilter = {
    every?: app_paciente_clinicaWhereInput
    some?: app_paciente_clinicaWhereInput
    none?: app_paciente_clinicaWhereInput
  }

  export type App_resposta_prontaListRelationFilter = {
    every?: app_resposta_prontaWhereInput
    some?: app_resposta_prontaWhereInput
    none?: app_resposta_prontaWhereInput
  }

  export type App_tagListRelationFilter = {
    every?: app_tagWhereInput
    some?: app_tagWhereInput
    none?: app_tagWhereInput
  }

  export type App_usuarioListRelationFilter = {
    every?: app_usuarioWhereInput
    some?: app_usuarioWhereInput
    none?: app_usuarioWhereInput
  }

  export type app_conversaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_grupoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_mensagem_sugestaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_pacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_paciente_clinicaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_resposta_prontaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_tagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_clinicaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    instancia?: SortOrder
    base_url?: SortOrder
    criada_em?: SortOrder
    atualizada_em?: SortOrder
    tokenEvolution?: SortOrder
  }

  export type app_clinicaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type app_clinicaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    instancia?: SortOrder
    base_url?: SortOrder
    criada_em?: SortOrder
    atualizada_em?: SortOrder
    tokenEvolution?: SortOrder
  }

  export type app_clinicaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    instancia?: SortOrder
    base_url?: SortOrder
    criada_em?: SortOrder
    atualizada_em?: SortOrder
    tokenEvolution?: SortOrder
  }

  export type app_clinicaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type App_usuarioNullableRelationFilter = {
    is?: app_usuarioWhereInput | null
    isNot?: app_usuarioWhereInput | null
  }

  export type app_log_acaoCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    acao?: SortOrder
    criado_em?: SortOrder
  }

  export type app_log_acaoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type app_log_acaoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    acao?: SortOrder
    criado_em?: SortOrder
  }

  export type app_log_acaoMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    acao?: SortOrder
    criado_em?: SortOrder
  }

  export type app_log_acaoSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type App_pacienteNullableRelationFilter = {
    is?: app_pacienteWhereInput | null
    isNot?: app_pacienteWhereInput | null
  }

  export type App_grupoNullableRelationFilter = {
    is?: app_grupoWhereInput | null
    isNot?: app_grupoWhereInput | null
  }

  export type App_mensagemListRelationFilter = {
    every?: app_mensagemWhereInput
    some?: app_mensagemWhereInput
    none?: app_mensagemWhereInput
  }

  export type app_mensagemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_conversaCountOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    iniciada_em?: SortOrder
    atualizada_em?: SortOrder
    grupo_id?: SortOrder
  }

  export type app_conversaAvgOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type app_conversaMaxOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    iniciada_em?: SortOrder
    atualizada_em?: SortOrder
    grupo_id?: SortOrder
  }

  export type app_conversaMinOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    iniciada_em?: SortOrder
    atualizada_em?: SortOrder
    grupo_id?: SortOrder
  }

  export type app_conversaSumOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    clinica_id?: SortOrder
    grupo_id?: SortOrder
  }

  export type App_conversaNullableRelationFilter = {
    is?: app_conversaWhereInput | null
    isNot?: app_conversaWhereInput | null
  }

  export type App_midiaListRelationFilter = {
    every?: app_midiaWhereInput
    some?: app_midiaWhereInput
    none?: app_midiaWhereInput
  }

  export type App_receiptListRelationFilter = {
    every?: app_receiptWhereInput
    some?: app_receiptWhereInput
    none?: app_receiptWhereInput
  }

  export type app_midiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_receiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_mensagemCountOrderByAggregateInput = {
    id?: SortOrder
    conversa_id?: SortOrder
    remetente?: SortOrder
    conteudo?: SortOrder
    tipo_mensagem?: SortOrder
    evolution_id?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
  }

  export type app_mensagemAvgOrderByAggregateInput = {
    id?: SortOrder
    conversa_id?: SortOrder
  }

  export type app_mensagemMaxOrderByAggregateInput = {
    id?: SortOrder
    conversa_id?: SortOrder
    remetente?: SortOrder
    conteudo?: SortOrder
    tipo_mensagem?: SortOrder
    evolution_id?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
  }

  export type app_mensagemMinOrderByAggregateInput = {
    id?: SortOrder
    conversa_id?: SortOrder
    remetente?: SortOrder
    conteudo?: SortOrder
    tipo_mensagem?: SortOrder
    evolution_id?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
  }

  export type app_mensagemSumOrderByAggregateInput = {
    id?: SortOrder
    conversa_id?: SortOrder
  }

  export type app_mensagem_sugestaoCountOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    sugestao?: SortOrder
    criado_em?: SortOrder
  }

  export type app_mensagem_sugestaoAvgOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_mensagem_sugestaoMaxOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    sugestao?: SortOrder
    criado_em?: SortOrder
  }

  export type app_mensagem_sugestaoMinOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    sugestao?: SortOrder
    criado_em?: SortOrder
  }

  export type app_mensagem_sugestaoSumOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type App_mensagemRelationFilter = {
    is?: app_mensagemWhereInput
    isNot?: app_mensagemWhereInput
  }

  export type app_midiaCountOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    tipo?: SortOrder
    file_url?: SortOrder
    criado_em?: SortOrder
    mime_type?: SortOrder
    caption?: SortOrder
    duration?: SortOrder
    file_size?: SortOrder
  }

  export type app_midiaAvgOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    duration?: SortOrder
    file_size?: SortOrder
  }

  export type app_midiaMaxOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    tipo?: SortOrder
    file_url?: SortOrder
    criado_em?: SortOrder
    mime_type?: SortOrder
    caption?: SortOrder
    duration?: SortOrder
    file_size?: SortOrder
  }

  export type app_midiaMinOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    tipo?: SortOrder
    file_url?: SortOrder
    criado_em?: SortOrder
    mime_type?: SortOrder
    caption?: SortOrder
    duration?: SortOrder
    file_size?: SortOrder
  }

  export type app_midiaSumOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    duration?: SortOrder
    file_size?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type app_pacienteTelefoneClinica_idCompoundUniqueInput = {
    telefone: string
    clinica_id: number
  }

  export type app_pacienteCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    criado_em?: SortOrder
    atualizado_em?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_pacienteAvgOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_pacienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    criado_em?: SortOrder
    atualizado_em?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_pacienteMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    criado_em?: SortOrder
    atualizado_em?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_pacienteSumOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type App_clinicaRelationFilter = {
    is?: app_clinicaWhereInput
    isNot?: app_clinicaWhereInput
  }

  export type App_pacienteRelationFilter = {
    is?: app_pacienteWhereInput
    isNot?: app_pacienteWhereInput
  }

  export type app_paciente_clinicaPaciente_idClinica_idCompoundUniqueInput = {
    paciente_id: number
    clinica_id: number
  }

  export type app_paciente_clinicaCountOrderByAggregateInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_paciente_clinicaAvgOrderByAggregateInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_paciente_clinicaMaxOrderByAggregateInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_paciente_clinicaMinOrderByAggregateInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_paciente_clinicaSumOrderByAggregateInput = {
    paciente_id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_resposta_prontaCountOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    criada_em?: SortOrder
  }

  export type app_resposta_prontaAvgOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_resposta_prontaMaxOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    criada_em?: SortOrder
  }

  export type app_resposta_prontaMinOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    criada_em?: SortOrder
  }

  export type app_resposta_prontaSumOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_tagCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    clinica_id?: SortOrder
    criada_em?: SortOrder
  }

  export type app_tagAvgOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_tagMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    clinica_id?: SortOrder
    criada_em?: SortOrder
  }

  export type app_tagMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    clinica_id?: SortOrder
    criada_em?: SortOrder
  }

  export type app_tagSumOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MedicosNullableRelationFilter = {
    is?: medicosWhereInput | null
    isNot?: medicosWhereInput | null
  }

  export type PacientesNullableRelationFilter = {
    is?: pacientesWhereInput | null
    isNot?: pacientesWhereInput | null
  }

  export type consultasCountOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    data_hora?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    paciente_id?: SortOrder
  }

  export type consultasAvgOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
  }

  export type consultasMaxOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    data_hora?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    paciente_id?: SortOrder
  }

  export type consultasMinOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    data_hora?: SortOrder
    tipo?: SortOrder
    status?: SortOrder
    paciente_id?: SortOrder
  }

  export type consultasSumOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type conversationsCountOrderByAggregateInput = {
    id?: SortOrder
    telefone_user?: SortOrder
    messages?: SortOrder
    created_at?: SortOrder
  }

  export type conversationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type conversationsMaxOrderByAggregateInput = {
    id?: SortOrder
    telefone_user?: SortOrder
    created_at?: SortOrder
  }

  export type conversationsMinOrderByAggregateInput = {
    id?: SortOrder
    telefone_user?: SortOrder
    created_at?: SortOrder
  }

  export type conversationsSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type documentsCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    metadata?: SortOrder
  }

  export type documentsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type documentsMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type documentsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MedicosListRelationFilter = {
    every?: medicosWhereInput
    some?: medicosWhereInput
    none?: medicosWhereInput
  }

  export type medicosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type especialidadesCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type especialidadesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type especialidadesMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type especialidadesMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type especialidadesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MedicosRelationFilter = {
    is?: medicosWhereInput
    isNot?: medicosWhereInput
  }

  export type ProcedimentosRelationFilter = {
    is?: procedimentosWhereInput
    isNot?: procedimentosWhereInput
  }

  export type medico_procedimentosCountOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
  }

  export type medico_procedimentosAvgOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
  }

  export type medico_procedimentosMaxOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
  }

  export type medico_procedimentosMinOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
  }

  export type medico_procedimentosSumOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    procedimento_id?: SortOrder
  }

  export type SintomasRelationFilter = {
    is?: sintomasWhereInput
    isNot?: sintomasWhereInput
  }

  export type medico_sintomasCountOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
  }

  export type medico_sintomasAvgOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
  }

  export type medico_sintomasMaxOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
  }

  export type medico_sintomasMinOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
  }

  export type medico_sintomasSumOrderByAggregateInput = {
    id?: SortOrder
    medico_id?: SortOrder
    sintoma_id?: SortOrder
  }

  export type ConsultasListRelationFilter = {
    every?: consultasWhereInput
    some?: consultasWhereInput
    none?: consultasWhereInput
  }

  export type Medico_procedimentosListRelationFilter = {
    every?: medico_procedimentosWhereInput
    some?: medico_procedimentosWhereInput
    none?: medico_procedimentosWhereInput
  }

  export type Medico_sintomasListRelationFilter = {
    every?: medico_sintomasWhereInput
    some?: medico_sintomasWhereInput
    none?: medico_sintomasWhereInput
  }

  export type EspecialidadesNullableRelationFilter = {
    is?: especialidadesWhereInput | null
    isNot?: especialidadesWhereInput | null
  }

  export type consultasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medico_procedimentosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medico_sintomasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medicosCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    especialidade_id?: SortOrder
    id_calendario?: SortOrder
    dia_atendimento?: SortOrder
    metodo_pagamento?: SortOrder
  }

  export type medicosAvgOrderByAggregateInput = {
    id?: SortOrder
    especialidade_id?: SortOrder
  }

  export type medicosMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    especialidade_id?: SortOrder
    id_calendario?: SortOrder
    dia_atendimento?: SortOrder
    metodo_pagamento?: SortOrder
  }

  export type medicosMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    especialidade_id?: SortOrder
    id_calendario?: SortOrder
    dia_atendimento?: SortOrder
    metodo_pagamento?: SortOrder
  }

  export type medicosSumOrderByAggregateInput = {
    id?: SortOrder
    especialidade_id?: SortOrder
  }

  export type n8n_chat_historiesCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    message?: SortOrder
  }

  export type n8n_chat_historiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type n8n_chat_historiesMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
  }

  export type n8n_chat_historiesMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
  }

  export type n8n_chat_historiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pacientesCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
  }

  export type pacientesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pacientesMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
  }

  export type pacientesMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
  }

  export type pacientesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type procedimentosCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    preco?: SortOrder
    tempo_estimado?: SortOrder
    descricao?: SortOrder
  }

  export type procedimentosAvgOrderByAggregateInput = {
    id?: SortOrder
    preco?: SortOrder
  }

  export type procedimentosMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    preco?: SortOrder
    tempo_estimado?: SortOrder
    descricao?: SortOrder
  }

  export type procedimentosMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    preco?: SortOrder
    tempo_estimado?: SortOrder
    descricao?: SortOrder
  }

  export type procedimentosSumOrderByAggregateInput = {
    id?: SortOrder
    preco?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type schema_migrationsCountOrderByAggregateInput = {
    version?: SortOrder
  }

  export type schema_migrationsMaxOrderByAggregateInput = {
    version?: SortOrder
  }

  export type schema_migrationsMinOrderByAggregateInput = {
    version?: SortOrder
  }

  export type sintomasCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type sintomasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sintomasMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type sintomasMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type sintomasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type agent_controlCountOrderByAggregateInput = {
    numero?: SortOrder
    agente_ativo?: SortOrder
    datehora?: SortOrder
    ignorar_automacao?: SortOrder
  }

  export type agent_controlMaxOrderByAggregateInput = {
    numero?: SortOrder
    agente_ativo?: SortOrder
    datehora?: SortOrder
    ignorar_automacao?: SortOrder
  }

  export type agent_controlMinOrderByAggregateInput = {
    numero?: SortOrder
    agente_ativo?: SortOrder
    datehora?: SortOrder
    ignorar_automacao?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type app_grupoCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    nome?: SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrder
  }

  export type app_grupoAvgOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_grupoMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    nome?: SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrder
  }

  export type app_grupoMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    nome?: SortOrder
    clinica_id?: SortOrder
    criado_em?: SortOrder
  }

  export type app_grupoSumOrderByAggregateInput = {
    id?: SortOrder
    clinica_id?: SortOrder
  }

  export type app_receiptCountOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    event_type?: SortOrder
    receipt_time?: SortOrder
    created_at?: SortOrder
  }

  export type app_receiptAvgOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
  }

  export type app_receiptMaxOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    event_type?: SortOrder
    receipt_time?: SortOrder
    created_at?: SortOrder
  }

  export type app_receiptMinOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
    event_type?: SortOrder
    receipt_time?: SortOrder
    created_at?: SortOrder
  }

  export type app_receiptSumOrderByAggregateInput = {
    id?: SortOrder
    mensagem_id?: SortOrder
  }

  export type app_log_acaoCreateNestedManyWithoutApp_usuarioInput = {
    create?: XOR<app_log_acaoCreateWithoutApp_usuarioInput, app_log_acaoUncheckedCreateWithoutApp_usuarioInput> | app_log_acaoCreateWithoutApp_usuarioInput[] | app_log_acaoUncheckedCreateWithoutApp_usuarioInput[]
    connectOrCreate?: app_log_acaoCreateOrConnectWithoutApp_usuarioInput | app_log_acaoCreateOrConnectWithoutApp_usuarioInput[]
    createMany?: app_log_acaoCreateManyApp_usuarioInputEnvelope
    connect?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
  }

  export type app_clinicaCreateNestedOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    create?: XOR<app_clinicaCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUncheckedCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_clinicaCreateNestedOneWithoutApp_usuarioInput = {
    create?: XOR<app_clinicaCreateWithoutApp_usuarioInput, app_clinicaUncheckedCreateWithoutApp_usuarioInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_usuarioInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_log_acaoUncheckedCreateNestedManyWithoutApp_usuarioInput = {
    create?: XOR<app_log_acaoCreateWithoutApp_usuarioInput, app_log_acaoUncheckedCreateWithoutApp_usuarioInput> | app_log_acaoCreateWithoutApp_usuarioInput[] | app_log_acaoUncheckedCreateWithoutApp_usuarioInput[]
    connectOrCreate?: app_log_acaoCreateOrConnectWithoutApp_usuarioInput | app_log_acaoCreateOrConnectWithoutApp_usuarioInput[]
    createMany?: app_log_acaoCreateManyApp_usuarioInputEnvelope
    connect?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type app_log_acaoUpdateManyWithoutApp_usuarioNestedInput = {
    create?: XOR<app_log_acaoCreateWithoutApp_usuarioInput, app_log_acaoUncheckedCreateWithoutApp_usuarioInput> | app_log_acaoCreateWithoutApp_usuarioInput[] | app_log_acaoUncheckedCreateWithoutApp_usuarioInput[]
    connectOrCreate?: app_log_acaoCreateOrConnectWithoutApp_usuarioInput | app_log_acaoCreateOrConnectWithoutApp_usuarioInput[]
    upsert?: app_log_acaoUpsertWithWhereUniqueWithoutApp_usuarioInput | app_log_acaoUpsertWithWhereUniqueWithoutApp_usuarioInput[]
    createMany?: app_log_acaoCreateManyApp_usuarioInputEnvelope
    set?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    disconnect?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    delete?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    connect?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    update?: app_log_acaoUpdateWithWhereUniqueWithoutApp_usuarioInput | app_log_acaoUpdateWithWhereUniqueWithoutApp_usuarioInput[]
    updateMany?: app_log_acaoUpdateManyWithWhereWithoutApp_usuarioInput | app_log_acaoUpdateManyWithWhereWithoutApp_usuarioInput[]
    deleteMany?: app_log_acaoScalarWhereInput | app_log_acaoScalarWhereInput[]
  }

  export type app_clinicaUpdateOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUncheckedCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput
    upsert?: app_clinicaUpsertWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>, app_clinicaUncheckedUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_clinicaUpdateOneWithoutApp_usuarioNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_usuarioInput, app_clinicaUncheckedCreateWithoutApp_usuarioInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_usuarioInput
    upsert?: app_clinicaUpsertWithoutApp_usuarioInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_usuarioInput, app_clinicaUpdateWithoutApp_usuarioInput>, app_clinicaUncheckedUpdateWithoutApp_usuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type app_log_acaoUncheckedUpdateManyWithoutApp_usuarioNestedInput = {
    create?: XOR<app_log_acaoCreateWithoutApp_usuarioInput, app_log_acaoUncheckedCreateWithoutApp_usuarioInput> | app_log_acaoCreateWithoutApp_usuarioInput[] | app_log_acaoUncheckedCreateWithoutApp_usuarioInput[]
    connectOrCreate?: app_log_acaoCreateOrConnectWithoutApp_usuarioInput | app_log_acaoCreateOrConnectWithoutApp_usuarioInput[]
    upsert?: app_log_acaoUpsertWithWhereUniqueWithoutApp_usuarioInput | app_log_acaoUpsertWithWhereUniqueWithoutApp_usuarioInput[]
    createMany?: app_log_acaoCreateManyApp_usuarioInputEnvelope
    set?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    disconnect?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    delete?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    connect?: app_log_acaoWhereUniqueInput | app_log_acaoWhereUniqueInput[]
    update?: app_log_acaoUpdateWithWhereUniqueWithoutApp_usuarioInput | app_log_acaoUpdateWithWhereUniqueWithoutApp_usuarioInput[]
    updateMany?: app_log_acaoUpdateManyWithWhereWithoutApp_usuarioInput | app_log_acaoUpdateManyWithWhereWithoutApp_usuarioInput[]
    deleteMany?: app_log_acaoScalarWhereInput | app_log_acaoScalarWhereInput[]
  }

  export type app_conversaCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_conversaCreateWithoutApp_clinicaInput, app_conversaUncheckedCreateWithoutApp_clinicaInput> | app_conversaCreateWithoutApp_clinicaInput[] | app_conversaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_clinicaInput | app_conversaCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_conversaCreateManyApp_clinicaInputEnvelope
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
  }

  export type app_grupoCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_grupoCreateWithoutApp_clinicaInput, app_grupoUncheckedCreateWithoutApp_clinicaInput> | app_grupoCreateWithoutApp_clinicaInput[] | app_grupoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_grupoCreateOrConnectWithoutApp_clinicaInput | app_grupoCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_grupoCreateManyApp_clinicaInputEnvelope
    connect?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
  }

  export type app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_mensagem_sugestaoCreateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput> | app_mensagem_sugestaoCreateWithoutApp_clinicaInput[] | app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput | app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_mensagem_sugestaoCreateManyApp_clinicaInputEnvelope
    connect?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
  }

  export type app_pacienteCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_pacienteCreateWithoutApp_clinicaInput, app_pacienteUncheckedCreateWithoutApp_clinicaInput> | app_pacienteCreateWithoutApp_clinicaInput[] | app_pacienteUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_clinicaInput | app_pacienteCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_pacienteCreateManyApp_clinicaInputEnvelope
    connect?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
  }

  export type app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput> | app_paciente_clinicaCreateWithoutApp_clinicaInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput | app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_paciente_clinicaCreateManyApp_clinicaInputEnvelope
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
  }

  export type app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_resposta_prontaCreateWithoutApp_clinicaInput, app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput> | app_resposta_prontaCreateWithoutApp_clinicaInput[] | app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput | app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_resposta_prontaCreateManyApp_clinicaInputEnvelope
    connect?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
  }

  export type app_tagCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_tagCreateWithoutApp_clinicaInput, app_tagUncheckedCreateWithoutApp_clinicaInput> | app_tagCreateWithoutApp_clinicaInput[] | app_tagUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_tagCreateOrConnectWithoutApp_clinicaInput | app_tagCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_tagCreateManyApp_clinicaInputEnvelope
    connect?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
  }

  export type app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput> | app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInputEnvelope
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
  }

  export type app_usuarioCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinicaInput> | app_usuarioCreateWithoutApp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinicaInputEnvelope
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
  }

  export type app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_conversaCreateWithoutApp_clinicaInput, app_conversaUncheckedCreateWithoutApp_clinicaInput> | app_conversaCreateWithoutApp_clinicaInput[] | app_conversaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_clinicaInput | app_conversaCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_conversaCreateManyApp_clinicaInputEnvelope
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
  }

  export type app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_grupoCreateWithoutApp_clinicaInput, app_grupoUncheckedCreateWithoutApp_clinicaInput> | app_grupoCreateWithoutApp_clinicaInput[] | app_grupoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_grupoCreateOrConnectWithoutApp_clinicaInput | app_grupoCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_grupoCreateManyApp_clinicaInputEnvelope
    connect?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
  }

  export type app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_mensagem_sugestaoCreateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput> | app_mensagem_sugestaoCreateWithoutApp_clinicaInput[] | app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput | app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_mensagem_sugestaoCreateManyApp_clinicaInputEnvelope
    connect?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
  }

  export type app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_pacienteCreateWithoutApp_clinicaInput, app_pacienteUncheckedCreateWithoutApp_clinicaInput> | app_pacienteCreateWithoutApp_clinicaInput[] | app_pacienteUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_clinicaInput | app_pacienteCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_pacienteCreateManyApp_clinicaInputEnvelope
    connect?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
  }

  export type app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput> | app_paciente_clinicaCreateWithoutApp_clinicaInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput | app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_paciente_clinicaCreateManyApp_clinicaInputEnvelope
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
  }

  export type app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_resposta_prontaCreateWithoutApp_clinicaInput, app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput> | app_resposta_prontaCreateWithoutApp_clinicaInput[] | app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput | app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_resposta_prontaCreateManyApp_clinicaInputEnvelope
    connect?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
  }

  export type app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_tagCreateWithoutApp_clinicaInput, app_tagUncheckedCreateWithoutApp_clinicaInput> | app_tagCreateWithoutApp_clinicaInput[] | app_tagUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_tagCreateOrConnectWithoutApp_clinicaInput | app_tagCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_tagCreateManyApp_clinicaInputEnvelope
    connect?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
  }

  export type app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput> | app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInputEnvelope
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
  }

  export type app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinicaInput> | app_usuarioCreateWithoutApp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinicaInputEnvelope
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type app_conversaUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_clinicaInput, app_conversaUncheckedCreateWithoutApp_clinicaInput> | app_conversaCreateWithoutApp_clinicaInput[] | app_conversaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_clinicaInput | app_conversaCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_conversaUpsertWithWhereUniqueWithoutApp_clinicaInput | app_conversaUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_conversaCreateManyApp_clinicaInputEnvelope
    set?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    disconnect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    delete?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    update?: app_conversaUpdateWithWhereUniqueWithoutApp_clinicaInput | app_conversaUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_conversaUpdateManyWithWhereWithoutApp_clinicaInput | app_conversaUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
  }

  export type app_grupoUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_grupoCreateWithoutApp_clinicaInput, app_grupoUncheckedCreateWithoutApp_clinicaInput> | app_grupoCreateWithoutApp_clinicaInput[] | app_grupoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_grupoCreateOrConnectWithoutApp_clinicaInput | app_grupoCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_grupoUpsertWithWhereUniqueWithoutApp_clinicaInput | app_grupoUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_grupoCreateManyApp_clinicaInputEnvelope
    set?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    disconnect?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    delete?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    connect?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    update?: app_grupoUpdateWithWhereUniqueWithoutApp_clinicaInput | app_grupoUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_grupoUpdateManyWithWhereWithoutApp_clinicaInput | app_grupoUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_grupoScalarWhereInput | app_grupoScalarWhereInput[]
  }

  export type app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_mensagem_sugestaoCreateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput> | app_mensagem_sugestaoCreateWithoutApp_clinicaInput[] | app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput | app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_mensagem_sugestaoUpsertWithWhereUniqueWithoutApp_clinicaInput | app_mensagem_sugestaoUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_mensagem_sugestaoCreateManyApp_clinicaInputEnvelope
    set?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    disconnect?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    delete?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    connect?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    update?: app_mensagem_sugestaoUpdateWithWhereUniqueWithoutApp_clinicaInput | app_mensagem_sugestaoUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_mensagem_sugestaoUpdateManyWithWhereWithoutApp_clinicaInput | app_mensagem_sugestaoUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_mensagem_sugestaoScalarWhereInput | app_mensagem_sugestaoScalarWhereInput[]
  }

  export type app_pacienteUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_pacienteCreateWithoutApp_clinicaInput, app_pacienteUncheckedCreateWithoutApp_clinicaInput> | app_pacienteCreateWithoutApp_clinicaInput[] | app_pacienteUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_clinicaInput | app_pacienteCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_pacienteUpsertWithWhereUniqueWithoutApp_clinicaInput | app_pacienteUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_pacienteCreateManyApp_clinicaInputEnvelope
    set?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    disconnect?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    delete?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    connect?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    update?: app_pacienteUpdateWithWhereUniqueWithoutApp_clinicaInput | app_pacienteUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_pacienteUpdateManyWithWhereWithoutApp_clinicaInput | app_pacienteUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_pacienteScalarWhereInput | app_pacienteScalarWhereInput[]
  }

  export type app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput> | app_paciente_clinicaCreateWithoutApp_clinicaInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput | app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_clinicaInput | app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_paciente_clinicaCreateManyApp_clinicaInputEnvelope
    set?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    disconnect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    delete?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    update?: app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_clinicaInput | app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_paciente_clinicaUpdateManyWithWhereWithoutApp_clinicaInput | app_paciente_clinicaUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_paciente_clinicaScalarWhereInput | app_paciente_clinicaScalarWhereInput[]
  }

  export type app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_resposta_prontaCreateWithoutApp_clinicaInput, app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput> | app_resposta_prontaCreateWithoutApp_clinicaInput[] | app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput | app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_resposta_prontaUpsertWithWhereUniqueWithoutApp_clinicaInput | app_resposta_prontaUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_resposta_prontaCreateManyApp_clinicaInputEnvelope
    set?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    disconnect?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    delete?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    connect?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    update?: app_resposta_prontaUpdateWithWhereUniqueWithoutApp_clinicaInput | app_resposta_prontaUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_resposta_prontaUpdateManyWithWhereWithoutApp_clinicaInput | app_resposta_prontaUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_resposta_prontaScalarWhereInput | app_resposta_prontaScalarWhereInput[]
  }

  export type app_tagUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_tagCreateWithoutApp_clinicaInput, app_tagUncheckedCreateWithoutApp_clinicaInput> | app_tagCreateWithoutApp_clinicaInput[] | app_tagUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_tagCreateOrConnectWithoutApp_clinicaInput | app_tagCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_tagUpsertWithWhereUniqueWithoutApp_clinicaInput | app_tagUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_tagCreateManyApp_clinicaInputEnvelope
    set?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    disconnect?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    delete?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    connect?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    update?: app_tagUpdateWithWhereUniqueWithoutApp_clinicaInput | app_tagUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_tagUpdateManyWithWhereWithoutApp_clinicaInput | app_tagUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_tagScalarWhereInput | app_tagScalarWhereInput[]
  }

  export type app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput> | app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    upsert?: app_usuarioUpsertWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioUpsertWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInputEnvelope
    set?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    disconnect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    delete?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    update?: app_usuarioUpdateWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioUpdateWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    updateMany?: app_usuarioUpdateManyWithWhereWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioUpdateManyWithWhereWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    deleteMany?: app_usuarioScalarWhereInput | app_usuarioScalarWhereInput[]
  }

  export type app_usuarioUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinicaInput> | app_usuarioCreateWithoutApp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_usuarioUpsertWithWhereUniqueWithoutApp_clinicaInput | app_usuarioUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinicaInputEnvelope
    set?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    disconnect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    delete?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    update?: app_usuarioUpdateWithWhereUniqueWithoutApp_clinicaInput | app_usuarioUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_usuarioUpdateManyWithWhereWithoutApp_clinicaInput | app_usuarioUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_usuarioScalarWhereInput | app_usuarioScalarWhereInput[]
  }

  export type app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_clinicaInput, app_conversaUncheckedCreateWithoutApp_clinicaInput> | app_conversaCreateWithoutApp_clinicaInput[] | app_conversaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_clinicaInput | app_conversaCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_conversaUpsertWithWhereUniqueWithoutApp_clinicaInput | app_conversaUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_conversaCreateManyApp_clinicaInputEnvelope
    set?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    disconnect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    delete?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    update?: app_conversaUpdateWithWhereUniqueWithoutApp_clinicaInput | app_conversaUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_conversaUpdateManyWithWhereWithoutApp_clinicaInput | app_conversaUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
  }

  export type app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_grupoCreateWithoutApp_clinicaInput, app_grupoUncheckedCreateWithoutApp_clinicaInput> | app_grupoCreateWithoutApp_clinicaInput[] | app_grupoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_grupoCreateOrConnectWithoutApp_clinicaInput | app_grupoCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_grupoUpsertWithWhereUniqueWithoutApp_clinicaInput | app_grupoUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_grupoCreateManyApp_clinicaInputEnvelope
    set?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    disconnect?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    delete?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    connect?: app_grupoWhereUniqueInput | app_grupoWhereUniqueInput[]
    update?: app_grupoUpdateWithWhereUniqueWithoutApp_clinicaInput | app_grupoUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_grupoUpdateManyWithWhereWithoutApp_clinicaInput | app_grupoUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_grupoScalarWhereInput | app_grupoScalarWhereInput[]
  }

  export type app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_mensagem_sugestaoCreateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput> | app_mensagem_sugestaoCreateWithoutApp_clinicaInput[] | app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput | app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_mensagem_sugestaoUpsertWithWhereUniqueWithoutApp_clinicaInput | app_mensagem_sugestaoUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_mensagem_sugestaoCreateManyApp_clinicaInputEnvelope
    set?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    disconnect?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    delete?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    connect?: app_mensagem_sugestaoWhereUniqueInput | app_mensagem_sugestaoWhereUniqueInput[]
    update?: app_mensagem_sugestaoUpdateWithWhereUniqueWithoutApp_clinicaInput | app_mensagem_sugestaoUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_mensagem_sugestaoUpdateManyWithWhereWithoutApp_clinicaInput | app_mensagem_sugestaoUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_mensagem_sugestaoScalarWhereInput | app_mensagem_sugestaoScalarWhereInput[]
  }

  export type app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_pacienteCreateWithoutApp_clinicaInput, app_pacienteUncheckedCreateWithoutApp_clinicaInput> | app_pacienteCreateWithoutApp_clinicaInput[] | app_pacienteUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_clinicaInput | app_pacienteCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_pacienteUpsertWithWhereUniqueWithoutApp_clinicaInput | app_pacienteUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_pacienteCreateManyApp_clinicaInputEnvelope
    set?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    disconnect?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    delete?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    connect?: app_pacienteWhereUniqueInput | app_pacienteWhereUniqueInput[]
    update?: app_pacienteUpdateWithWhereUniqueWithoutApp_clinicaInput | app_pacienteUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_pacienteUpdateManyWithWhereWithoutApp_clinicaInput | app_pacienteUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_pacienteScalarWhereInput | app_pacienteScalarWhereInput[]
  }

  export type app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput> | app_paciente_clinicaCreateWithoutApp_clinicaInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput | app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_clinicaInput | app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_paciente_clinicaCreateManyApp_clinicaInputEnvelope
    set?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    disconnect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    delete?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    update?: app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_clinicaInput | app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_paciente_clinicaUpdateManyWithWhereWithoutApp_clinicaInput | app_paciente_clinicaUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_paciente_clinicaScalarWhereInput | app_paciente_clinicaScalarWhereInput[]
  }

  export type app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_resposta_prontaCreateWithoutApp_clinicaInput, app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput> | app_resposta_prontaCreateWithoutApp_clinicaInput[] | app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput | app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_resposta_prontaUpsertWithWhereUniqueWithoutApp_clinicaInput | app_resposta_prontaUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_resposta_prontaCreateManyApp_clinicaInputEnvelope
    set?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    disconnect?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    delete?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    connect?: app_resposta_prontaWhereUniqueInput | app_resposta_prontaWhereUniqueInput[]
    update?: app_resposta_prontaUpdateWithWhereUniqueWithoutApp_clinicaInput | app_resposta_prontaUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_resposta_prontaUpdateManyWithWhereWithoutApp_clinicaInput | app_resposta_prontaUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_resposta_prontaScalarWhereInput | app_resposta_prontaScalarWhereInput[]
  }

  export type app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_tagCreateWithoutApp_clinicaInput, app_tagUncheckedCreateWithoutApp_clinicaInput> | app_tagCreateWithoutApp_clinicaInput[] | app_tagUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_tagCreateOrConnectWithoutApp_clinicaInput | app_tagCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_tagUpsertWithWhereUniqueWithoutApp_clinicaInput | app_tagUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_tagCreateManyApp_clinicaInputEnvelope
    set?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    disconnect?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    delete?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    connect?: app_tagWhereUniqueInput | app_tagWhereUniqueInput[]
    update?: app_tagUpdateWithWhereUniqueWithoutApp_clinicaInput | app_tagUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_tagUpdateManyWithWhereWithoutApp_clinicaInput | app_tagUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_tagScalarWhereInput | app_tagScalarWhereInput[]
  }

  export type app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput> | app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    upsert?: app_usuarioUpsertWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioUpsertWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInputEnvelope
    set?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    disconnect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    delete?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    update?: app_usuarioUpdateWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioUpdateWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    updateMany?: app_usuarioUpdateManyWithWhereWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioUpdateManyWithWhereWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    deleteMany?: app_usuarioScalarWhereInput | app_usuarioScalarWhereInput[]
  }

  export type app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput = {
    create?: XOR<app_usuarioCreateWithoutApp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinicaInput> | app_usuarioCreateWithoutApp_clinicaInput[] | app_usuarioUncheckedCreateWithoutApp_clinicaInput[]
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_clinicaInput | app_usuarioCreateOrConnectWithoutApp_clinicaInput[]
    upsert?: app_usuarioUpsertWithWhereUniqueWithoutApp_clinicaInput | app_usuarioUpsertWithWhereUniqueWithoutApp_clinicaInput[]
    createMany?: app_usuarioCreateManyApp_clinicaInputEnvelope
    set?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    disconnect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    delete?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    connect?: app_usuarioWhereUniqueInput | app_usuarioWhereUniqueInput[]
    update?: app_usuarioUpdateWithWhereUniqueWithoutApp_clinicaInput | app_usuarioUpdateWithWhereUniqueWithoutApp_clinicaInput[]
    updateMany?: app_usuarioUpdateManyWithWhereWithoutApp_clinicaInput | app_usuarioUpdateManyWithWhereWithoutApp_clinicaInput[]
    deleteMany?: app_usuarioScalarWhereInput | app_usuarioScalarWhereInput[]
  }

  export type app_usuarioCreateNestedOneWithoutApp_log_acaoInput = {
    create?: XOR<app_usuarioCreateWithoutApp_log_acaoInput, app_usuarioUncheckedCreateWithoutApp_log_acaoInput>
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_log_acaoInput
    connect?: app_usuarioWhereUniqueInput
  }

  export type app_usuarioUpdateOneWithoutApp_log_acaoNestedInput = {
    create?: XOR<app_usuarioCreateWithoutApp_log_acaoInput, app_usuarioUncheckedCreateWithoutApp_log_acaoInput>
    connectOrCreate?: app_usuarioCreateOrConnectWithoutApp_log_acaoInput
    upsert?: app_usuarioUpsertWithoutApp_log_acaoInput
    disconnect?: app_usuarioWhereInput | boolean
    delete?: app_usuarioWhereInput | boolean
    connect?: app_usuarioWhereUniqueInput
    update?: XOR<XOR<app_usuarioUpdateToOneWithWhereWithoutApp_log_acaoInput, app_usuarioUpdateWithoutApp_log_acaoInput>, app_usuarioUncheckedUpdateWithoutApp_log_acaoInput>
  }

  export type app_clinicaCreateNestedOneWithoutApp_conversaInput = {
    create?: XOR<app_clinicaCreateWithoutApp_conversaInput, app_clinicaUncheckedCreateWithoutApp_conversaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_conversaInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_pacienteCreateNestedOneWithoutApp_conversaInput = {
    create?: XOR<app_pacienteCreateWithoutApp_conversaInput, app_pacienteUncheckedCreateWithoutApp_conversaInput>
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_conversaInput
    connect?: app_pacienteWhereUniqueInput
  }

  export type app_grupoCreateNestedOneWithoutApp_conversaInput = {
    create?: XOR<app_grupoCreateWithoutApp_conversaInput, app_grupoUncheckedCreateWithoutApp_conversaInput>
    connectOrCreate?: app_grupoCreateOrConnectWithoutApp_conversaInput
    connect?: app_grupoWhereUniqueInput
  }

  export type app_mensagemCreateNestedManyWithoutApp_conversaInput = {
    create?: XOR<app_mensagemCreateWithoutApp_conversaInput, app_mensagemUncheckedCreateWithoutApp_conversaInput> | app_mensagemCreateWithoutApp_conversaInput[] | app_mensagemUncheckedCreateWithoutApp_conversaInput[]
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_conversaInput | app_mensagemCreateOrConnectWithoutApp_conversaInput[]
    createMany?: app_mensagemCreateManyApp_conversaInputEnvelope
    connect?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
  }

  export type app_mensagemUncheckedCreateNestedManyWithoutApp_conversaInput = {
    create?: XOR<app_mensagemCreateWithoutApp_conversaInput, app_mensagemUncheckedCreateWithoutApp_conversaInput> | app_mensagemCreateWithoutApp_conversaInput[] | app_mensagemUncheckedCreateWithoutApp_conversaInput[]
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_conversaInput | app_mensagemCreateOrConnectWithoutApp_conversaInput[]
    createMany?: app_mensagemCreateManyApp_conversaInputEnvelope
    connect?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
  }

  export type app_clinicaUpdateOneWithoutApp_conversaNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_conversaInput, app_clinicaUncheckedCreateWithoutApp_conversaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_conversaInput
    upsert?: app_clinicaUpsertWithoutApp_conversaInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_conversaInput, app_clinicaUpdateWithoutApp_conversaInput>, app_clinicaUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_pacienteUpdateOneWithoutApp_conversaNestedInput = {
    create?: XOR<app_pacienteCreateWithoutApp_conversaInput, app_pacienteUncheckedCreateWithoutApp_conversaInput>
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_conversaInput
    upsert?: app_pacienteUpsertWithoutApp_conversaInput
    disconnect?: app_pacienteWhereInput | boolean
    delete?: app_pacienteWhereInput | boolean
    connect?: app_pacienteWhereUniqueInput
    update?: XOR<XOR<app_pacienteUpdateToOneWithWhereWithoutApp_conversaInput, app_pacienteUpdateWithoutApp_conversaInput>, app_pacienteUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_grupoUpdateOneWithoutApp_conversaNestedInput = {
    create?: XOR<app_grupoCreateWithoutApp_conversaInput, app_grupoUncheckedCreateWithoutApp_conversaInput>
    connectOrCreate?: app_grupoCreateOrConnectWithoutApp_conversaInput
    upsert?: app_grupoUpsertWithoutApp_conversaInput
    disconnect?: app_grupoWhereInput | boolean
    delete?: app_grupoWhereInput | boolean
    connect?: app_grupoWhereUniqueInput
    update?: XOR<XOR<app_grupoUpdateToOneWithWhereWithoutApp_conversaInput, app_grupoUpdateWithoutApp_conversaInput>, app_grupoUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_mensagemUpdateManyWithoutApp_conversaNestedInput = {
    create?: XOR<app_mensagemCreateWithoutApp_conversaInput, app_mensagemUncheckedCreateWithoutApp_conversaInput> | app_mensagemCreateWithoutApp_conversaInput[] | app_mensagemUncheckedCreateWithoutApp_conversaInput[]
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_conversaInput | app_mensagemCreateOrConnectWithoutApp_conversaInput[]
    upsert?: app_mensagemUpsertWithWhereUniqueWithoutApp_conversaInput | app_mensagemUpsertWithWhereUniqueWithoutApp_conversaInput[]
    createMany?: app_mensagemCreateManyApp_conversaInputEnvelope
    set?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    disconnect?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    delete?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    connect?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    update?: app_mensagemUpdateWithWhereUniqueWithoutApp_conversaInput | app_mensagemUpdateWithWhereUniqueWithoutApp_conversaInput[]
    updateMany?: app_mensagemUpdateManyWithWhereWithoutApp_conversaInput | app_mensagemUpdateManyWithWhereWithoutApp_conversaInput[]
    deleteMany?: app_mensagemScalarWhereInput | app_mensagemScalarWhereInput[]
  }

  export type app_mensagemUncheckedUpdateManyWithoutApp_conversaNestedInput = {
    create?: XOR<app_mensagemCreateWithoutApp_conversaInput, app_mensagemUncheckedCreateWithoutApp_conversaInput> | app_mensagemCreateWithoutApp_conversaInput[] | app_mensagemUncheckedCreateWithoutApp_conversaInput[]
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_conversaInput | app_mensagemCreateOrConnectWithoutApp_conversaInput[]
    upsert?: app_mensagemUpsertWithWhereUniqueWithoutApp_conversaInput | app_mensagemUpsertWithWhereUniqueWithoutApp_conversaInput[]
    createMany?: app_mensagemCreateManyApp_conversaInputEnvelope
    set?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    disconnect?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    delete?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    connect?: app_mensagemWhereUniqueInput | app_mensagemWhereUniqueInput[]
    update?: app_mensagemUpdateWithWhereUniqueWithoutApp_conversaInput | app_mensagemUpdateWithWhereUniqueWithoutApp_conversaInput[]
    updateMany?: app_mensagemUpdateManyWithWhereWithoutApp_conversaInput | app_mensagemUpdateManyWithWhereWithoutApp_conversaInput[]
    deleteMany?: app_mensagemScalarWhereInput | app_mensagemScalarWhereInput[]
  }

  export type app_conversaCreateNestedOneWithoutApp_mensagemInput = {
    create?: XOR<app_conversaCreateWithoutApp_mensagemInput, app_conversaUncheckedCreateWithoutApp_mensagemInput>
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_mensagemInput
    connect?: app_conversaWhereUniqueInput
  }

  export type app_midiaCreateNestedManyWithoutApp_mensagemInput = {
    create?: XOR<app_midiaCreateWithoutApp_mensagemInput, app_midiaUncheckedCreateWithoutApp_mensagemInput> | app_midiaCreateWithoutApp_mensagemInput[] | app_midiaUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_midiaCreateOrConnectWithoutApp_mensagemInput | app_midiaCreateOrConnectWithoutApp_mensagemInput[]
    createMany?: app_midiaCreateManyApp_mensagemInputEnvelope
    connect?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
  }

  export type app_receiptCreateNestedManyWithoutApp_mensagemInput = {
    create?: XOR<app_receiptCreateWithoutApp_mensagemInput, app_receiptUncheckedCreateWithoutApp_mensagemInput> | app_receiptCreateWithoutApp_mensagemInput[] | app_receiptUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_receiptCreateOrConnectWithoutApp_mensagemInput | app_receiptCreateOrConnectWithoutApp_mensagemInput[]
    createMany?: app_receiptCreateManyApp_mensagemInputEnvelope
    connect?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
  }

  export type app_midiaUncheckedCreateNestedManyWithoutApp_mensagemInput = {
    create?: XOR<app_midiaCreateWithoutApp_mensagemInput, app_midiaUncheckedCreateWithoutApp_mensagemInput> | app_midiaCreateWithoutApp_mensagemInput[] | app_midiaUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_midiaCreateOrConnectWithoutApp_mensagemInput | app_midiaCreateOrConnectWithoutApp_mensagemInput[]
    createMany?: app_midiaCreateManyApp_mensagemInputEnvelope
    connect?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
  }

  export type app_receiptUncheckedCreateNestedManyWithoutApp_mensagemInput = {
    create?: XOR<app_receiptCreateWithoutApp_mensagemInput, app_receiptUncheckedCreateWithoutApp_mensagemInput> | app_receiptCreateWithoutApp_mensagemInput[] | app_receiptUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_receiptCreateOrConnectWithoutApp_mensagemInput | app_receiptCreateOrConnectWithoutApp_mensagemInput[]
    createMany?: app_receiptCreateManyApp_mensagemInputEnvelope
    connect?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
  }

  export type app_conversaUpdateOneWithoutApp_mensagemNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_mensagemInput, app_conversaUncheckedCreateWithoutApp_mensagemInput>
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_mensagemInput
    upsert?: app_conversaUpsertWithoutApp_mensagemInput
    disconnect?: app_conversaWhereInput | boolean
    delete?: app_conversaWhereInput | boolean
    connect?: app_conversaWhereUniqueInput
    update?: XOR<XOR<app_conversaUpdateToOneWithWhereWithoutApp_mensagemInput, app_conversaUpdateWithoutApp_mensagemInput>, app_conversaUncheckedUpdateWithoutApp_mensagemInput>
  }

  export type app_midiaUpdateManyWithoutApp_mensagemNestedInput = {
    create?: XOR<app_midiaCreateWithoutApp_mensagemInput, app_midiaUncheckedCreateWithoutApp_mensagemInput> | app_midiaCreateWithoutApp_mensagemInput[] | app_midiaUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_midiaCreateOrConnectWithoutApp_mensagemInput | app_midiaCreateOrConnectWithoutApp_mensagemInput[]
    upsert?: app_midiaUpsertWithWhereUniqueWithoutApp_mensagemInput | app_midiaUpsertWithWhereUniqueWithoutApp_mensagemInput[]
    createMany?: app_midiaCreateManyApp_mensagemInputEnvelope
    set?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    disconnect?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    delete?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    connect?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    update?: app_midiaUpdateWithWhereUniqueWithoutApp_mensagemInput | app_midiaUpdateWithWhereUniqueWithoutApp_mensagemInput[]
    updateMany?: app_midiaUpdateManyWithWhereWithoutApp_mensagemInput | app_midiaUpdateManyWithWhereWithoutApp_mensagemInput[]
    deleteMany?: app_midiaScalarWhereInput | app_midiaScalarWhereInput[]
  }

  export type app_receiptUpdateManyWithoutApp_mensagemNestedInput = {
    create?: XOR<app_receiptCreateWithoutApp_mensagemInput, app_receiptUncheckedCreateWithoutApp_mensagemInput> | app_receiptCreateWithoutApp_mensagemInput[] | app_receiptUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_receiptCreateOrConnectWithoutApp_mensagemInput | app_receiptCreateOrConnectWithoutApp_mensagemInput[]
    upsert?: app_receiptUpsertWithWhereUniqueWithoutApp_mensagemInput | app_receiptUpsertWithWhereUniqueWithoutApp_mensagemInput[]
    createMany?: app_receiptCreateManyApp_mensagemInputEnvelope
    set?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    disconnect?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    delete?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    connect?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    update?: app_receiptUpdateWithWhereUniqueWithoutApp_mensagemInput | app_receiptUpdateWithWhereUniqueWithoutApp_mensagemInput[]
    updateMany?: app_receiptUpdateManyWithWhereWithoutApp_mensagemInput | app_receiptUpdateManyWithWhereWithoutApp_mensagemInput[]
    deleteMany?: app_receiptScalarWhereInput | app_receiptScalarWhereInput[]
  }

  export type app_midiaUncheckedUpdateManyWithoutApp_mensagemNestedInput = {
    create?: XOR<app_midiaCreateWithoutApp_mensagemInput, app_midiaUncheckedCreateWithoutApp_mensagemInput> | app_midiaCreateWithoutApp_mensagemInput[] | app_midiaUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_midiaCreateOrConnectWithoutApp_mensagemInput | app_midiaCreateOrConnectWithoutApp_mensagemInput[]
    upsert?: app_midiaUpsertWithWhereUniqueWithoutApp_mensagemInput | app_midiaUpsertWithWhereUniqueWithoutApp_mensagemInput[]
    createMany?: app_midiaCreateManyApp_mensagemInputEnvelope
    set?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    disconnect?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    delete?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    connect?: app_midiaWhereUniqueInput | app_midiaWhereUniqueInput[]
    update?: app_midiaUpdateWithWhereUniqueWithoutApp_mensagemInput | app_midiaUpdateWithWhereUniqueWithoutApp_mensagemInput[]
    updateMany?: app_midiaUpdateManyWithWhereWithoutApp_mensagemInput | app_midiaUpdateManyWithWhereWithoutApp_mensagemInput[]
    deleteMany?: app_midiaScalarWhereInput | app_midiaScalarWhereInput[]
  }

  export type app_receiptUncheckedUpdateManyWithoutApp_mensagemNestedInput = {
    create?: XOR<app_receiptCreateWithoutApp_mensagemInput, app_receiptUncheckedCreateWithoutApp_mensagemInput> | app_receiptCreateWithoutApp_mensagemInput[] | app_receiptUncheckedCreateWithoutApp_mensagemInput[]
    connectOrCreate?: app_receiptCreateOrConnectWithoutApp_mensagemInput | app_receiptCreateOrConnectWithoutApp_mensagemInput[]
    upsert?: app_receiptUpsertWithWhereUniqueWithoutApp_mensagemInput | app_receiptUpsertWithWhereUniqueWithoutApp_mensagemInput[]
    createMany?: app_receiptCreateManyApp_mensagemInputEnvelope
    set?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    disconnect?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    delete?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    connect?: app_receiptWhereUniqueInput | app_receiptWhereUniqueInput[]
    update?: app_receiptUpdateWithWhereUniqueWithoutApp_mensagemInput | app_receiptUpdateWithWhereUniqueWithoutApp_mensagemInput[]
    updateMany?: app_receiptUpdateManyWithWhereWithoutApp_mensagemInput | app_receiptUpdateManyWithWhereWithoutApp_mensagemInput[]
    deleteMany?: app_receiptScalarWhereInput | app_receiptScalarWhereInput[]
  }

  export type app_clinicaCreateNestedOneWithoutApp_mensagem_sugestaoInput = {
    create?: XOR<app_clinicaCreateWithoutApp_mensagem_sugestaoInput, app_clinicaUncheckedCreateWithoutApp_mensagem_sugestaoInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_mensagem_sugestaoInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_clinicaUpdateOneWithoutApp_mensagem_sugestaoNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_mensagem_sugestaoInput, app_clinicaUncheckedCreateWithoutApp_mensagem_sugestaoInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_mensagem_sugestaoInput
    upsert?: app_clinicaUpsertWithoutApp_mensagem_sugestaoInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_mensagem_sugestaoInput, app_clinicaUpdateWithoutApp_mensagem_sugestaoInput>, app_clinicaUncheckedUpdateWithoutApp_mensagem_sugestaoInput>
  }

  export type app_mensagemCreateNestedOneWithoutApp_midiaInput = {
    create?: XOR<app_mensagemCreateWithoutApp_midiaInput, app_mensagemUncheckedCreateWithoutApp_midiaInput>
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_midiaInput
    connect?: app_mensagemWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type app_mensagemUpdateOneRequiredWithoutApp_midiaNestedInput = {
    create?: XOR<app_mensagemCreateWithoutApp_midiaInput, app_mensagemUncheckedCreateWithoutApp_midiaInput>
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_midiaInput
    upsert?: app_mensagemUpsertWithoutApp_midiaInput
    connect?: app_mensagemWhereUniqueInput
    update?: XOR<XOR<app_mensagemUpdateToOneWithWhereWithoutApp_midiaInput, app_mensagemUpdateWithoutApp_midiaInput>, app_mensagemUncheckedUpdateWithoutApp_midiaInput>
  }

  export type app_conversaCreateNestedManyWithoutApp_pacienteInput = {
    create?: XOR<app_conversaCreateWithoutApp_pacienteInput, app_conversaUncheckedCreateWithoutApp_pacienteInput> | app_conversaCreateWithoutApp_pacienteInput[] | app_conversaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_pacienteInput | app_conversaCreateOrConnectWithoutApp_pacienteInput[]
    createMany?: app_conversaCreateManyApp_pacienteInputEnvelope
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
  }

  export type app_clinicaCreateNestedOneWithoutApp_pacienteInput = {
    create?: XOR<app_clinicaCreateWithoutApp_pacienteInput, app_clinicaUncheckedCreateWithoutApp_pacienteInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_pacienteInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_paciente_clinicaCreateNestedManyWithoutApp_pacienteInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput> | app_paciente_clinicaCreateWithoutApp_pacienteInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput | app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput[]
    createMany?: app_paciente_clinicaCreateManyApp_pacienteInputEnvelope
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
  }

  export type app_conversaUncheckedCreateNestedManyWithoutApp_pacienteInput = {
    create?: XOR<app_conversaCreateWithoutApp_pacienteInput, app_conversaUncheckedCreateWithoutApp_pacienteInput> | app_conversaCreateWithoutApp_pacienteInput[] | app_conversaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_pacienteInput | app_conversaCreateOrConnectWithoutApp_pacienteInput[]
    createMany?: app_conversaCreateManyApp_pacienteInputEnvelope
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
  }

  export type app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_pacienteInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput> | app_paciente_clinicaCreateWithoutApp_pacienteInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput | app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput[]
    createMany?: app_paciente_clinicaCreateManyApp_pacienteInputEnvelope
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
  }

  export type app_conversaUpdateManyWithoutApp_pacienteNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_pacienteInput, app_conversaUncheckedCreateWithoutApp_pacienteInput> | app_conversaCreateWithoutApp_pacienteInput[] | app_conversaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_pacienteInput | app_conversaCreateOrConnectWithoutApp_pacienteInput[]
    upsert?: app_conversaUpsertWithWhereUniqueWithoutApp_pacienteInput | app_conversaUpsertWithWhereUniqueWithoutApp_pacienteInput[]
    createMany?: app_conversaCreateManyApp_pacienteInputEnvelope
    set?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    disconnect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    delete?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    update?: app_conversaUpdateWithWhereUniqueWithoutApp_pacienteInput | app_conversaUpdateWithWhereUniqueWithoutApp_pacienteInput[]
    updateMany?: app_conversaUpdateManyWithWhereWithoutApp_pacienteInput | app_conversaUpdateManyWithWhereWithoutApp_pacienteInput[]
    deleteMany?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
  }

  export type app_clinicaUpdateOneWithoutApp_pacienteNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_pacienteInput, app_clinicaUncheckedCreateWithoutApp_pacienteInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_pacienteInput
    upsert?: app_clinicaUpsertWithoutApp_pacienteInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_pacienteInput, app_clinicaUpdateWithoutApp_pacienteInput>, app_clinicaUncheckedUpdateWithoutApp_pacienteInput>
  }

  export type app_paciente_clinicaUpdateManyWithoutApp_pacienteNestedInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput> | app_paciente_clinicaCreateWithoutApp_pacienteInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput | app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput[]
    upsert?: app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_pacienteInput | app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_pacienteInput[]
    createMany?: app_paciente_clinicaCreateManyApp_pacienteInputEnvelope
    set?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    disconnect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    delete?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    update?: app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_pacienteInput | app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_pacienteInput[]
    updateMany?: app_paciente_clinicaUpdateManyWithWhereWithoutApp_pacienteInput | app_paciente_clinicaUpdateManyWithWhereWithoutApp_pacienteInput[]
    deleteMany?: app_paciente_clinicaScalarWhereInput | app_paciente_clinicaScalarWhereInput[]
  }

  export type app_conversaUncheckedUpdateManyWithoutApp_pacienteNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_pacienteInput, app_conversaUncheckedCreateWithoutApp_pacienteInput> | app_conversaCreateWithoutApp_pacienteInput[] | app_conversaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_pacienteInput | app_conversaCreateOrConnectWithoutApp_pacienteInput[]
    upsert?: app_conversaUpsertWithWhereUniqueWithoutApp_pacienteInput | app_conversaUpsertWithWhereUniqueWithoutApp_pacienteInput[]
    createMany?: app_conversaCreateManyApp_pacienteInputEnvelope
    set?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    disconnect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    delete?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    update?: app_conversaUpdateWithWhereUniqueWithoutApp_pacienteInput | app_conversaUpdateWithWhereUniqueWithoutApp_pacienteInput[]
    updateMany?: app_conversaUpdateManyWithWhereWithoutApp_pacienteInput | app_conversaUpdateManyWithWhereWithoutApp_pacienteInput[]
    deleteMany?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
  }

  export type app_paciente_clinicaUncheckedUpdateManyWithoutApp_pacienteNestedInput = {
    create?: XOR<app_paciente_clinicaCreateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput> | app_paciente_clinicaCreateWithoutApp_pacienteInput[] | app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput[]
    connectOrCreate?: app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput | app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput[]
    upsert?: app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_pacienteInput | app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_pacienteInput[]
    createMany?: app_paciente_clinicaCreateManyApp_pacienteInputEnvelope
    set?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    disconnect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    delete?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    connect?: app_paciente_clinicaWhereUniqueInput | app_paciente_clinicaWhereUniqueInput[]
    update?: app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_pacienteInput | app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_pacienteInput[]
    updateMany?: app_paciente_clinicaUpdateManyWithWhereWithoutApp_pacienteInput | app_paciente_clinicaUpdateManyWithWhereWithoutApp_pacienteInput[]
    deleteMany?: app_paciente_clinicaScalarWhereInput | app_paciente_clinicaScalarWhereInput[]
  }

  export type app_clinicaCreateNestedOneWithoutApp_paciente_clinicaInput = {
    create?: XOR<app_clinicaCreateWithoutApp_paciente_clinicaInput, app_clinicaUncheckedCreateWithoutApp_paciente_clinicaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_paciente_clinicaInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_pacienteCreateNestedOneWithoutApp_paciente_clinicaInput = {
    create?: XOR<app_pacienteCreateWithoutApp_paciente_clinicaInput, app_pacienteUncheckedCreateWithoutApp_paciente_clinicaInput>
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_paciente_clinicaInput
    connect?: app_pacienteWhereUniqueInput
  }

  export type app_clinicaUpdateOneRequiredWithoutApp_paciente_clinicaNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_paciente_clinicaInput, app_clinicaUncheckedCreateWithoutApp_paciente_clinicaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_paciente_clinicaInput
    upsert?: app_clinicaUpsertWithoutApp_paciente_clinicaInput
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_paciente_clinicaInput, app_clinicaUpdateWithoutApp_paciente_clinicaInput>, app_clinicaUncheckedUpdateWithoutApp_paciente_clinicaInput>
  }

  export type app_pacienteUpdateOneRequiredWithoutApp_paciente_clinicaNestedInput = {
    create?: XOR<app_pacienteCreateWithoutApp_paciente_clinicaInput, app_pacienteUncheckedCreateWithoutApp_paciente_clinicaInput>
    connectOrCreate?: app_pacienteCreateOrConnectWithoutApp_paciente_clinicaInput
    upsert?: app_pacienteUpsertWithoutApp_paciente_clinicaInput
    connect?: app_pacienteWhereUniqueInput
    update?: XOR<XOR<app_pacienteUpdateToOneWithWhereWithoutApp_paciente_clinicaInput, app_pacienteUpdateWithoutApp_paciente_clinicaInput>, app_pacienteUncheckedUpdateWithoutApp_paciente_clinicaInput>
  }

  export type app_clinicaCreateNestedOneWithoutApp_resposta_prontaInput = {
    create?: XOR<app_clinicaCreateWithoutApp_resposta_prontaInput, app_clinicaUncheckedCreateWithoutApp_resposta_prontaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_resposta_prontaInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_clinicaUpdateOneWithoutApp_resposta_prontaNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_resposta_prontaInput, app_clinicaUncheckedCreateWithoutApp_resposta_prontaInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_resposta_prontaInput
    upsert?: app_clinicaUpsertWithoutApp_resposta_prontaInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_resposta_prontaInput, app_clinicaUpdateWithoutApp_resposta_prontaInput>, app_clinicaUncheckedUpdateWithoutApp_resposta_prontaInput>
  }

  export type app_clinicaCreateNestedOneWithoutApp_tagInput = {
    create?: XOR<app_clinicaCreateWithoutApp_tagInput, app_clinicaUncheckedCreateWithoutApp_tagInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_tagInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_clinicaUpdateOneWithoutApp_tagNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_tagInput, app_clinicaUncheckedCreateWithoutApp_tagInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_tagInput
    upsert?: app_clinicaUpsertWithoutApp_tagInput
    disconnect?: app_clinicaWhereInput | boolean
    delete?: app_clinicaWhereInput | boolean
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_tagInput, app_clinicaUpdateWithoutApp_tagInput>, app_clinicaUncheckedUpdateWithoutApp_tagInput>
  }

  export type medicosCreateNestedOneWithoutConsultasInput = {
    create?: XOR<medicosCreateWithoutConsultasInput, medicosUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: medicosCreateOrConnectWithoutConsultasInput
    connect?: medicosWhereUniqueInput
  }

  export type pacientesCreateNestedOneWithoutConsultasInput = {
    create?: XOR<pacientesCreateWithoutConsultasInput, pacientesUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: pacientesCreateOrConnectWithoutConsultasInput
    connect?: pacientesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type medicosUpdateOneWithoutConsultasNestedInput = {
    create?: XOR<medicosCreateWithoutConsultasInput, medicosUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: medicosCreateOrConnectWithoutConsultasInput
    upsert?: medicosUpsertWithoutConsultasInput
    disconnect?: medicosWhereInput | boolean
    delete?: medicosWhereInput | boolean
    connect?: medicosWhereUniqueInput
    update?: XOR<XOR<medicosUpdateToOneWithWhereWithoutConsultasInput, medicosUpdateWithoutConsultasInput>, medicosUncheckedUpdateWithoutConsultasInput>
  }

  export type pacientesUpdateOneWithoutConsultasNestedInput = {
    create?: XOR<pacientesCreateWithoutConsultasInput, pacientesUncheckedCreateWithoutConsultasInput>
    connectOrCreate?: pacientesCreateOrConnectWithoutConsultasInput
    upsert?: pacientesUpsertWithoutConsultasInput
    disconnect?: pacientesWhereInput | boolean
    delete?: pacientesWhereInput | boolean
    connect?: pacientesWhereUniqueInput
    update?: XOR<XOR<pacientesUpdateToOneWithWhereWithoutConsultasInput, pacientesUpdateWithoutConsultasInput>, pacientesUncheckedUpdateWithoutConsultasInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type medicosCreateNestedManyWithoutEspecialidadesInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
  }

  export type medicosUncheckedCreateNestedManyWithoutEspecialidadesInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
  }

  export type medicosUpdateManyWithoutEspecialidadesNestedInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    upsert?: medicosUpsertWithWhereUniqueWithoutEspecialidadesInput | medicosUpsertWithWhereUniqueWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    set?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    disconnect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    delete?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    update?: medicosUpdateWithWhereUniqueWithoutEspecialidadesInput | medicosUpdateWithWhereUniqueWithoutEspecialidadesInput[]
    updateMany?: medicosUpdateManyWithWhereWithoutEspecialidadesInput | medicosUpdateManyWithWhereWithoutEspecialidadesInput[]
    deleteMany?: medicosScalarWhereInput | medicosScalarWhereInput[]
  }

  export type medicosUncheckedUpdateManyWithoutEspecialidadesNestedInput = {
    create?: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput> | medicosCreateWithoutEspecialidadesInput[] | medicosUncheckedCreateWithoutEspecialidadesInput[]
    connectOrCreate?: medicosCreateOrConnectWithoutEspecialidadesInput | medicosCreateOrConnectWithoutEspecialidadesInput[]
    upsert?: medicosUpsertWithWhereUniqueWithoutEspecialidadesInput | medicosUpsertWithWhereUniqueWithoutEspecialidadesInput[]
    createMany?: medicosCreateManyEspecialidadesInputEnvelope
    set?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    disconnect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    delete?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    connect?: medicosWhereUniqueInput | medicosWhereUniqueInput[]
    update?: medicosUpdateWithWhereUniqueWithoutEspecialidadesInput | medicosUpdateWithWhereUniqueWithoutEspecialidadesInput[]
    updateMany?: medicosUpdateManyWithWhereWithoutEspecialidadesInput | medicosUpdateManyWithWhereWithoutEspecialidadesInput[]
    deleteMany?: medicosScalarWhereInput | medicosScalarWhereInput[]
  }

  export type medicosCreateNestedOneWithoutMedico_procedimentosInput = {
    create?: XOR<medicosCreateWithoutMedico_procedimentosInput, medicosUncheckedCreateWithoutMedico_procedimentosInput>
    connectOrCreate?: medicosCreateOrConnectWithoutMedico_procedimentosInput
    connect?: medicosWhereUniqueInput
  }

  export type procedimentosCreateNestedOneWithoutMedico_procedimentosInput = {
    create?: XOR<procedimentosCreateWithoutMedico_procedimentosInput, procedimentosUncheckedCreateWithoutMedico_procedimentosInput>
    connectOrCreate?: procedimentosCreateOrConnectWithoutMedico_procedimentosInput
    connect?: procedimentosWhereUniqueInput
  }

  export type medicosUpdateOneRequiredWithoutMedico_procedimentosNestedInput = {
    create?: XOR<medicosCreateWithoutMedico_procedimentosInput, medicosUncheckedCreateWithoutMedico_procedimentosInput>
    connectOrCreate?: medicosCreateOrConnectWithoutMedico_procedimentosInput
    upsert?: medicosUpsertWithoutMedico_procedimentosInput
    connect?: medicosWhereUniqueInput
    update?: XOR<XOR<medicosUpdateToOneWithWhereWithoutMedico_procedimentosInput, medicosUpdateWithoutMedico_procedimentosInput>, medicosUncheckedUpdateWithoutMedico_procedimentosInput>
  }

  export type procedimentosUpdateOneRequiredWithoutMedico_procedimentosNestedInput = {
    create?: XOR<procedimentosCreateWithoutMedico_procedimentosInput, procedimentosUncheckedCreateWithoutMedico_procedimentosInput>
    connectOrCreate?: procedimentosCreateOrConnectWithoutMedico_procedimentosInput
    upsert?: procedimentosUpsertWithoutMedico_procedimentosInput
    connect?: procedimentosWhereUniqueInput
    update?: XOR<XOR<procedimentosUpdateToOneWithWhereWithoutMedico_procedimentosInput, procedimentosUpdateWithoutMedico_procedimentosInput>, procedimentosUncheckedUpdateWithoutMedico_procedimentosInput>
  }

  export type medicosCreateNestedOneWithoutMedico_sintomasInput = {
    create?: XOR<medicosCreateWithoutMedico_sintomasInput, medicosUncheckedCreateWithoutMedico_sintomasInput>
    connectOrCreate?: medicosCreateOrConnectWithoutMedico_sintomasInput
    connect?: medicosWhereUniqueInput
  }

  export type sintomasCreateNestedOneWithoutMedico_sintomasInput = {
    create?: XOR<sintomasCreateWithoutMedico_sintomasInput, sintomasUncheckedCreateWithoutMedico_sintomasInput>
    connectOrCreate?: sintomasCreateOrConnectWithoutMedico_sintomasInput
    connect?: sintomasWhereUniqueInput
  }

  export type medicosUpdateOneRequiredWithoutMedico_sintomasNestedInput = {
    create?: XOR<medicosCreateWithoutMedico_sintomasInput, medicosUncheckedCreateWithoutMedico_sintomasInput>
    connectOrCreate?: medicosCreateOrConnectWithoutMedico_sintomasInput
    upsert?: medicosUpsertWithoutMedico_sintomasInput
    connect?: medicosWhereUniqueInput
    update?: XOR<XOR<medicosUpdateToOneWithWhereWithoutMedico_sintomasInput, medicosUpdateWithoutMedico_sintomasInput>, medicosUncheckedUpdateWithoutMedico_sintomasInput>
  }

  export type sintomasUpdateOneRequiredWithoutMedico_sintomasNestedInput = {
    create?: XOR<sintomasCreateWithoutMedico_sintomasInput, sintomasUncheckedCreateWithoutMedico_sintomasInput>
    connectOrCreate?: sintomasCreateOrConnectWithoutMedico_sintomasInput
    upsert?: sintomasUpsertWithoutMedico_sintomasInput
    connect?: sintomasWhereUniqueInput
    update?: XOR<XOR<sintomasUpdateToOneWithWhereWithoutMedico_sintomasInput, sintomasUpdateWithoutMedico_sintomasInput>, sintomasUncheckedUpdateWithoutMedico_sintomasInput>
  }

  export type consultasCreateNestedManyWithoutMedicosInput = {
    create?: XOR<consultasCreateWithoutMedicosInput, consultasUncheckedCreateWithoutMedicosInput> | consultasCreateWithoutMedicosInput[] | consultasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutMedicosInput | consultasCreateOrConnectWithoutMedicosInput[]
    createMany?: consultasCreateManyMedicosInputEnvelope
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
  }

  export type medico_procedimentosCreateNestedManyWithoutMedicosInput = {
    create?: XOR<medico_procedimentosCreateWithoutMedicosInput, medico_procedimentosUncheckedCreateWithoutMedicosInput> | medico_procedimentosCreateWithoutMedicosInput[] | medico_procedimentosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutMedicosInput | medico_procedimentosCreateOrConnectWithoutMedicosInput[]
    createMany?: medico_procedimentosCreateManyMedicosInputEnvelope
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
  }

  export type medico_sintomasCreateNestedManyWithoutMedicosInput = {
    create?: XOR<medico_sintomasCreateWithoutMedicosInput, medico_sintomasUncheckedCreateWithoutMedicosInput> | medico_sintomasCreateWithoutMedicosInput[] | medico_sintomasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutMedicosInput | medico_sintomasCreateOrConnectWithoutMedicosInput[]
    createMany?: medico_sintomasCreateManyMedicosInputEnvelope
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
  }

  export type especialidadesCreateNestedOneWithoutMedicosInput = {
    create?: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
    connectOrCreate?: especialidadesCreateOrConnectWithoutMedicosInput
    connect?: especialidadesWhereUniqueInput
  }

  export type consultasUncheckedCreateNestedManyWithoutMedicosInput = {
    create?: XOR<consultasCreateWithoutMedicosInput, consultasUncheckedCreateWithoutMedicosInput> | consultasCreateWithoutMedicosInput[] | consultasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutMedicosInput | consultasCreateOrConnectWithoutMedicosInput[]
    createMany?: consultasCreateManyMedicosInputEnvelope
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
  }

  export type medico_procedimentosUncheckedCreateNestedManyWithoutMedicosInput = {
    create?: XOR<medico_procedimentosCreateWithoutMedicosInput, medico_procedimentosUncheckedCreateWithoutMedicosInput> | medico_procedimentosCreateWithoutMedicosInput[] | medico_procedimentosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutMedicosInput | medico_procedimentosCreateOrConnectWithoutMedicosInput[]
    createMany?: medico_procedimentosCreateManyMedicosInputEnvelope
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
  }

  export type medico_sintomasUncheckedCreateNestedManyWithoutMedicosInput = {
    create?: XOR<medico_sintomasCreateWithoutMedicosInput, medico_sintomasUncheckedCreateWithoutMedicosInput> | medico_sintomasCreateWithoutMedicosInput[] | medico_sintomasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutMedicosInput | medico_sintomasCreateOrConnectWithoutMedicosInput[]
    createMany?: medico_sintomasCreateManyMedicosInputEnvelope
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
  }

  export type consultasUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<consultasCreateWithoutMedicosInput, consultasUncheckedCreateWithoutMedicosInput> | consultasCreateWithoutMedicosInput[] | consultasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutMedicosInput | consultasCreateOrConnectWithoutMedicosInput[]
    upsert?: consultasUpsertWithWhereUniqueWithoutMedicosInput | consultasUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: consultasCreateManyMedicosInputEnvelope
    set?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    disconnect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    delete?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    update?: consultasUpdateWithWhereUniqueWithoutMedicosInput | consultasUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: consultasUpdateManyWithWhereWithoutMedicosInput | consultasUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: consultasScalarWhereInput | consultasScalarWhereInput[]
  }

  export type medico_procedimentosUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<medico_procedimentosCreateWithoutMedicosInput, medico_procedimentosUncheckedCreateWithoutMedicosInput> | medico_procedimentosCreateWithoutMedicosInput[] | medico_procedimentosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutMedicosInput | medico_procedimentosCreateOrConnectWithoutMedicosInput[]
    upsert?: medico_procedimentosUpsertWithWhereUniqueWithoutMedicosInput | medico_procedimentosUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: medico_procedimentosCreateManyMedicosInputEnvelope
    set?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    disconnect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    delete?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    update?: medico_procedimentosUpdateWithWhereUniqueWithoutMedicosInput | medico_procedimentosUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: medico_procedimentosUpdateManyWithWhereWithoutMedicosInput | medico_procedimentosUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: medico_procedimentosScalarWhereInput | medico_procedimentosScalarWhereInput[]
  }

  export type medico_sintomasUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<medico_sintomasCreateWithoutMedicosInput, medico_sintomasUncheckedCreateWithoutMedicosInput> | medico_sintomasCreateWithoutMedicosInput[] | medico_sintomasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutMedicosInput | medico_sintomasCreateOrConnectWithoutMedicosInput[]
    upsert?: medico_sintomasUpsertWithWhereUniqueWithoutMedicosInput | medico_sintomasUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: medico_sintomasCreateManyMedicosInputEnvelope
    set?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    disconnect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    delete?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    update?: medico_sintomasUpdateWithWhereUniqueWithoutMedicosInput | medico_sintomasUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: medico_sintomasUpdateManyWithWhereWithoutMedicosInput | medico_sintomasUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: medico_sintomasScalarWhereInput | medico_sintomasScalarWhereInput[]
  }

  export type especialidadesUpdateOneWithoutMedicosNestedInput = {
    create?: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
    connectOrCreate?: especialidadesCreateOrConnectWithoutMedicosInput
    upsert?: especialidadesUpsertWithoutMedicosInput
    disconnect?: especialidadesWhereInput | boolean
    delete?: especialidadesWhereInput | boolean
    connect?: especialidadesWhereUniqueInput
    update?: XOR<XOR<especialidadesUpdateToOneWithWhereWithoutMedicosInput, especialidadesUpdateWithoutMedicosInput>, especialidadesUncheckedUpdateWithoutMedicosInput>
  }

  export type consultasUncheckedUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<consultasCreateWithoutMedicosInput, consultasUncheckedCreateWithoutMedicosInput> | consultasCreateWithoutMedicosInput[] | consultasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutMedicosInput | consultasCreateOrConnectWithoutMedicosInput[]
    upsert?: consultasUpsertWithWhereUniqueWithoutMedicosInput | consultasUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: consultasCreateManyMedicosInputEnvelope
    set?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    disconnect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    delete?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    update?: consultasUpdateWithWhereUniqueWithoutMedicosInput | consultasUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: consultasUpdateManyWithWhereWithoutMedicosInput | consultasUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: consultasScalarWhereInput | consultasScalarWhereInput[]
  }

  export type medico_procedimentosUncheckedUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<medico_procedimentosCreateWithoutMedicosInput, medico_procedimentosUncheckedCreateWithoutMedicosInput> | medico_procedimentosCreateWithoutMedicosInput[] | medico_procedimentosUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutMedicosInput | medico_procedimentosCreateOrConnectWithoutMedicosInput[]
    upsert?: medico_procedimentosUpsertWithWhereUniqueWithoutMedicosInput | medico_procedimentosUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: medico_procedimentosCreateManyMedicosInputEnvelope
    set?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    disconnect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    delete?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    update?: medico_procedimentosUpdateWithWhereUniqueWithoutMedicosInput | medico_procedimentosUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: medico_procedimentosUpdateManyWithWhereWithoutMedicosInput | medico_procedimentosUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: medico_procedimentosScalarWhereInput | medico_procedimentosScalarWhereInput[]
  }

  export type medico_sintomasUncheckedUpdateManyWithoutMedicosNestedInput = {
    create?: XOR<medico_sintomasCreateWithoutMedicosInput, medico_sintomasUncheckedCreateWithoutMedicosInput> | medico_sintomasCreateWithoutMedicosInput[] | medico_sintomasUncheckedCreateWithoutMedicosInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutMedicosInput | medico_sintomasCreateOrConnectWithoutMedicosInput[]
    upsert?: medico_sintomasUpsertWithWhereUniqueWithoutMedicosInput | medico_sintomasUpsertWithWhereUniqueWithoutMedicosInput[]
    createMany?: medico_sintomasCreateManyMedicosInputEnvelope
    set?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    disconnect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    delete?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    update?: medico_sintomasUpdateWithWhereUniqueWithoutMedicosInput | medico_sintomasUpdateWithWhereUniqueWithoutMedicosInput[]
    updateMany?: medico_sintomasUpdateManyWithWhereWithoutMedicosInput | medico_sintomasUpdateManyWithWhereWithoutMedicosInput[]
    deleteMany?: medico_sintomasScalarWhereInput | medico_sintomasScalarWhereInput[]
  }

  export type consultasCreateNestedManyWithoutPacientesInput = {
    create?: XOR<consultasCreateWithoutPacientesInput, consultasUncheckedCreateWithoutPacientesInput> | consultasCreateWithoutPacientesInput[] | consultasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutPacientesInput | consultasCreateOrConnectWithoutPacientesInput[]
    createMany?: consultasCreateManyPacientesInputEnvelope
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
  }

  export type consultasUncheckedCreateNestedManyWithoutPacientesInput = {
    create?: XOR<consultasCreateWithoutPacientesInput, consultasUncheckedCreateWithoutPacientesInput> | consultasCreateWithoutPacientesInput[] | consultasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutPacientesInput | consultasCreateOrConnectWithoutPacientesInput[]
    createMany?: consultasCreateManyPacientesInputEnvelope
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
  }

  export type consultasUpdateManyWithoutPacientesNestedInput = {
    create?: XOR<consultasCreateWithoutPacientesInput, consultasUncheckedCreateWithoutPacientesInput> | consultasCreateWithoutPacientesInput[] | consultasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutPacientesInput | consultasCreateOrConnectWithoutPacientesInput[]
    upsert?: consultasUpsertWithWhereUniqueWithoutPacientesInput | consultasUpsertWithWhereUniqueWithoutPacientesInput[]
    createMany?: consultasCreateManyPacientesInputEnvelope
    set?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    disconnect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    delete?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    update?: consultasUpdateWithWhereUniqueWithoutPacientesInput | consultasUpdateWithWhereUniqueWithoutPacientesInput[]
    updateMany?: consultasUpdateManyWithWhereWithoutPacientesInput | consultasUpdateManyWithWhereWithoutPacientesInput[]
    deleteMany?: consultasScalarWhereInput | consultasScalarWhereInput[]
  }

  export type consultasUncheckedUpdateManyWithoutPacientesNestedInput = {
    create?: XOR<consultasCreateWithoutPacientesInput, consultasUncheckedCreateWithoutPacientesInput> | consultasCreateWithoutPacientesInput[] | consultasUncheckedCreateWithoutPacientesInput[]
    connectOrCreate?: consultasCreateOrConnectWithoutPacientesInput | consultasCreateOrConnectWithoutPacientesInput[]
    upsert?: consultasUpsertWithWhereUniqueWithoutPacientesInput | consultasUpsertWithWhereUniqueWithoutPacientesInput[]
    createMany?: consultasCreateManyPacientesInputEnvelope
    set?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    disconnect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    delete?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    connect?: consultasWhereUniqueInput | consultasWhereUniqueInput[]
    update?: consultasUpdateWithWhereUniqueWithoutPacientesInput | consultasUpdateWithWhereUniqueWithoutPacientesInput[]
    updateMany?: consultasUpdateManyWithWhereWithoutPacientesInput | consultasUpdateManyWithWhereWithoutPacientesInput[]
    deleteMany?: consultasScalarWhereInput | consultasScalarWhereInput[]
  }

  export type medico_procedimentosCreateNestedManyWithoutProcedimentosInput = {
    create?: XOR<medico_procedimentosCreateWithoutProcedimentosInput, medico_procedimentosUncheckedCreateWithoutProcedimentosInput> | medico_procedimentosCreateWithoutProcedimentosInput[] | medico_procedimentosUncheckedCreateWithoutProcedimentosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutProcedimentosInput | medico_procedimentosCreateOrConnectWithoutProcedimentosInput[]
    createMany?: medico_procedimentosCreateManyProcedimentosInputEnvelope
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
  }

  export type medico_procedimentosUncheckedCreateNestedManyWithoutProcedimentosInput = {
    create?: XOR<medico_procedimentosCreateWithoutProcedimentosInput, medico_procedimentosUncheckedCreateWithoutProcedimentosInput> | medico_procedimentosCreateWithoutProcedimentosInput[] | medico_procedimentosUncheckedCreateWithoutProcedimentosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutProcedimentosInput | medico_procedimentosCreateOrConnectWithoutProcedimentosInput[]
    createMany?: medico_procedimentosCreateManyProcedimentosInputEnvelope
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type medico_procedimentosUpdateManyWithoutProcedimentosNestedInput = {
    create?: XOR<medico_procedimentosCreateWithoutProcedimentosInput, medico_procedimentosUncheckedCreateWithoutProcedimentosInput> | medico_procedimentosCreateWithoutProcedimentosInput[] | medico_procedimentosUncheckedCreateWithoutProcedimentosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutProcedimentosInput | medico_procedimentosCreateOrConnectWithoutProcedimentosInput[]
    upsert?: medico_procedimentosUpsertWithWhereUniqueWithoutProcedimentosInput | medico_procedimentosUpsertWithWhereUniqueWithoutProcedimentosInput[]
    createMany?: medico_procedimentosCreateManyProcedimentosInputEnvelope
    set?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    disconnect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    delete?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    update?: medico_procedimentosUpdateWithWhereUniqueWithoutProcedimentosInput | medico_procedimentosUpdateWithWhereUniqueWithoutProcedimentosInput[]
    updateMany?: medico_procedimentosUpdateManyWithWhereWithoutProcedimentosInput | medico_procedimentosUpdateManyWithWhereWithoutProcedimentosInput[]
    deleteMany?: medico_procedimentosScalarWhereInput | medico_procedimentosScalarWhereInput[]
  }

  export type medico_procedimentosUncheckedUpdateManyWithoutProcedimentosNestedInput = {
    create?: XOR<medico_procedimentosCreateWithoutProcedimentosInput, medico_procedimentosUncheckedCreateWithoutProcedimentosInput> | medico_procedimentosCreateWithoutProcedimentosInput[] | medico_procedimentosUncheckedCreateWithoutProcedimentosInput[]
    connectOrCreate?: medico_procedimentosCreateOrConnectWithoutProcedimentosInput | medico_procedimentosCreateOrConnectWithoutProcedimentosInput[]
    upsert?: medico_procedimentosUpsertWithWhereUniqueWithoutProcedimentosInput | medico_procedimentosUpsertWithWhereUniqueWithoutProcedimentosInput[]
    createMany?: medico_procedimentosCreateManyProcedimentosInputEnvelope
    set?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    disconnect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    delete?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    connect?: medico_procedimentosWhereUniqueInput | medico_procedimentosWhereUniqueInput[]
    update?: medico_procedimentosUpdateWithWhereUniqueWithoutProcedimentosInput | medico_procedimentosUpdateWithWhereUniqueWithoutProcedimentosInput[]
    updateMany?: medico_procedimentosUpdateManyWithWhereWithoutProcedimentosInput | medico_procedimentosUpdateManyWithWhereWithoutProcedimentosInput[]
    deleteMany?: medico_procedimentosScalarWhereInput | medico_procedimentosScalarWhereInput[]
  }

  export type medico_sintomasCreateNestedManyWithoutSintomasInput = {
    create?: XOR<medico_sintomasCreateWithoutSintomasInput, medico_sintomasUncheckedCreateWithoutSintomasInput> | medico_sintomasCreateWithoutSintomasInput[] | medico_sintomasUncheckedCreateWithoutSintomasInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutSintomasInput | medico_sintomasCreateOrConnectWithoutSintomasInput[]
    createMany?: medico_sintomasCreateManySintomasInputEnvelope
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
  }

  export type medico_sintomasUncheckedCreateNestedManyWithoutSintomasInput = {
    create?: XOR<medico_sintomasCreateWithoutSintomasInput, medico_sintomasUncheckedCreateWithoutSintomasInput> | medico_sintomasCreateWithoutSintomasInput[] | medico_sintomasUncheckedCreateWithoutSintomasInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutSintomasInput | medico_sintomasCreateOrConnectWithoutSintomasInput[]
    createMany?: medico_sintomasCreateManySintomasInputEnvelope
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
  }

  export type medico_sintomasUpdateManyWithoutSintomasNestedInput = {
    create?: XOR<medico_sintomasCreateWithoutSintomasInput, medico_sintomasUncheckedCreateWithoutSintomasInput> | medico_sintomasCreateWithoutSintomasInput[] | medico_sintomasUncheckedCreateWithoutSintomasInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutSintomasInput | medico_sintomasCreateOrConnectWithoutSintomasInput[]
    upsert?: medico_sintomasUpsertWithWhereUniqueWithoutSintomasInput | medico_sintomasUpsertWithWhereUniqueWithoutSintomasInput[]
    createMany?: medico_sintomasCreateManySintomasInputEnvelope
    set?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    disconnect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    delete?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    update?: medico_sintomasUpdateWithWhereUniqueWithoutSintomasInput | medico_sintomasUpdateWithWhereUniqueWithoutSintomasInput[]
    updateMany?: medico_sintomasUpdateManyWithWhereWithoutSintomasInput | medico_sintomasUpdateManyWithWhereWithoutSintomasInput[]
    deleteMany?: medico_sintomasScalarWhereInput | medico_sintomasScalarWhereInput[]
  }

  export type medico_sintomasUncheckedUpdateManyWithoutSintomasNestedInput = {
    create?: XOR<medico_sintomasCreateWithoutSintomasInput, medico_sintomasUncheckedCreateWithoutSintomasInput> | medico_sintomasCreateWithoutSintomasInput[] | medico_sintomasUncheckedCreateWithoutSintomasInput[]
    connectOrCreate?: medico_sintomasCreateOrConnectWithoutSintomasInput | medico_sintomasCreateOrConnectWithoutSintomasInput[]
    upsert?: medico_sintomasUpsertWithWhereUniqueWithoutSintomasInput | medico_sintomasUpsertWithWhereUniqueWithoutSintomasInput[]
    createMany?: medico_sintomasCreateManySintomasInputEnvelope
    set?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    disconnect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    delete?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    connect?: medico_sintomasWhereUniqueInput | medico_sintomasWhereUniqueInput[]
    update?: medico_sintomasUpdateWithWhereUniqueWithoutSintomasInput | medico_sintomasUpdateWithWhereUniqueWithoutSintomasInput[]
    updateMany?: medico_sintomasUpdateManyWithWhereWithoutSintomasInput | medico_sintomasUpdateManyWithWhereWithoutSintomasInput[]
    deleteMany?: medico_sintomasScalarWhereInput | medico_sintomasScalarWhereInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type app_conversaCreateNestedManyWithoutApp_grupoInput = {
    create?: XOR<app_conversaCreateWithoutApp_grupoInput, app_conversaUncheckedCreateWithoutApp_grupoInput> | app_conversaCreateWithoutApp_grupoInput[] | app_conversaUncheckedCreateWithoutApp_grupoInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_grupoInput | app_conversaCreateOrConnectWithoutApp_grupoInput[]
    createMany?: app_conversaCreateManyApp_grupoInputEnvelope
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
  }

  export type app_clinicaCreateNestedOneWithoutApp_grupoInput = {
    create?: XOR<app_clinicaCreateWithoutApp_grupoInput, app_clinicaUncheckedCreateWithoutApp_grupoInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_grupoInput
    connect?: app_clinicaWhereUniqueInput
  }

  export type app_conversaUncheckedCreateNestedManyWithoutApp_grupoInput = {
    create?: XOR<app_conversaCreateWithoutApp_grupoInput, app_conversaUncheckedCreateWithoutApp_grupoInput> | app_conversaCreateWithoutApp_grupoInput[] | app_conversaUncheckedCreateWithoutApp_grupoInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_grupoInput | app_conversaCreateOrConnectWithoutApp_grupoInput[]
    createMany?: app_conversaCreateManyApp_grupoInputEnvelope
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
  }

  export type app_conversaUpdateManyWithoutApp_grupoNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_grupoInput, app_conversaUncheckedCreateWithoutApp_grupoInput> | app_conversaCreateWithoutApp_grupoInput[] | app_conversaUncheckedCreateWithoutApp_grupoInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_grupoInput | app_conversaCreateOrConnectWithoutApp_grupoInput[]
    upsert?: app_conversaUpsertWithWhereUniqueWithoutApp_grupoInput | app_conversaUpsertWithWhereUniqueWithoutApp_grupoInput[]
    createMany?: app_conversaCreateManyApp_grupoInputEnvelope
    set?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    disconnect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    delete?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    update?: app_conversaUpdateWithWhereUniqueWithoutApp_grupoInput | app_conversaUpdateWithWhereUniqueWithoutApp_grupoInput[]
    updateMany?: app_conversaUpdateManyWithWhereWithoutApp_grupoInput | app_conversaUpdateManyWithWhereWithoutApp_grupoInput[]
    deleteMany?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
  }

  export type app_clinicaUpdateOneRequiredWithoutApp_grupoNestedInput = {
    create?: XOR<app_clinicaCreateWithoutApp_grupoInput, app_clinicaUncheckedCreateWithoutApp_grupoInput>
    connectOrCreate?: app_clinicaCreateOrConnectWithoutApp_grupoInput
    upsert?: app_clinicaUpsertWithoutApp_grupoInput
    connect?: app_clinicaWhereUniqueInput
    update?: XOR<XOR<app_clinicaUpdateToOneWithWhereWithoutApp_grupoInput, app_clinicaUpdateWithoutApp_grupoInput>, app_clinicaUncheckedUpdateWithoutApp_grupoInput>
  }

  export type app_conversaUncheckedUpdateManyWithoutApp_grupoNestedInput = {
    create?: XOR<app_conversaCreateWithoutApp_grupoInput, app_conversaUncheckedCreateWithoutApp_grupoInput> | app_conversaCreateWithoutApp_grupoInput[] | app_conversaUncheckedCreateWithoutApp_grupoInput[]
    connectOrCreate?: app_conversaCreateOrConnectWithoutApp_grupoInput | app_conversaCreateOrConnectWithoutApp_grupoInput[]
    upsert?: app_conversaUpsertWithWhereUniqueWithoutApp_grupoInput | app_conversaUpsertWithWhereUniqueWithoutApp_grupoInput[]
    createMany?: app_conversaCreateManyApp_grupoInputEnvelope
    set?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    disconnect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    delete?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    connect?: app_conversaWhereUniqueInput | app_conversaWhereUniqueInput[]
    update?: app_conversaUpdateWithWhereUniqueWithoutApp_grupoInput | app_conversaUpdateWithWhereUniqueWithoutApp_grupoInput[]
    updateMany?: app_conversaUpdateManyWithWhereWithoutApp_grupoInput | app_conversaUpdateManyWithWhereWithoutApp_grupoInput[]
    deleteMany?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
  }

  export type app_mensagemCreateNestedOneWithoutApp_receiptInput = {
    create?: XOR<app_mensagemCreateWithoutApp_receiptInput, app_mensagemUncheckedCreateWithoutApp_receiptInput>
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_receiptInput
    connect?: app_mensagemWhereUniqueInput
  }

  export type app_mensagemUpdateOneRequiredWithoutApp_receiptNestedInput = {
    create?: XOR<app_mensagemCreateWithoutApp_receiptInput, app_mensagemUncheckedCreateWithoutApp_receiptInput>
    connectOrCreate?: app_mensagemCreateOrConnectWithoutApp_receiptInput
    upsert?: app_mensagemUpsertWithoutApp_receiptInput
    connect?: app_mensagemWhereUniqueInput
    update?: XOR<XOR<app_mensagemUpdateToOneWithWhereWithoutApp_receiptInput, app_mensagemUpdateWithoutApp_receiptInput>, app_mensagemUncheckedUpdateWithoutApp_receiptInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type app_log_acaoCreateWithoutApp_usuarioInput = {
    acao?: string | null
    criado_em?: Date | string | null
  }

  export type app_log_acaoUncheckedCreateWithoutApp_usuarioInput = {
    id?: number
    acao?: string | null
    criado_em?: Date | string | null
  }

  export type app_log_acaoCreateOrConnectWithoutApp_usuarioInput = {
    where: app_log_acaoWhereUniqueInput
    create: XOR<app_log_acaoCreateWithoutApp_usuarioInput, app_log_acaoUncheckedCreateWithoutApp_usuarioInput>
  }

  export type app_log_acaoCreateManyApp_usuarioInputEnvelope = {
    data: app_log_acaoCreateManyApp_usuarioInput | app_log_acaoCreateManyApp_usuarioInput[]
    skipDuplicates?: boolean
  }

  export type app_clinicaCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUncheckedCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_clinicaCreateWithoutApp_usuarioInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_usuarioInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_usuarioInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_usuarioInput, app_clinicaUncheckedCreateWithoutApp_usuarioInput>
  }

  export type app_log_acaoUpsertWithWhereUniqueWithoutApp_usuarioInput = {
    where: app_log_acaoWhereUniqueInput
    update: XOR<app_log_acaoUpdateWithoutApp_usuarioInput, app_log_acaoUncheckedUpdateWithoutApp_usuarioInput>
    create: XOR<app_log_acaoCreateWithoutApp_usuarioInput, app_log_acaoUncheckedCreateWithoutApp_usuarioInput>
  }

  export type app_log_acaoUpdateWithWhereUniqueWithoutApp_usuarioInput = {
    where: app_log_acaoWhereUniqueInput
    data: XOR<app_log_acaoUpdateWithoutApp_usuarioInput, app_log_acaoUncheckedUpdateWithoutApp_usuarioInput>
  }

  export type app_log_acaoUpdateManyWithWhereWithoutApp_usuarioInput = {
    where: app_log_acaoScalarWhereInput
    data: XOR<app_log_acaoUpdateManyMutationInput, app_log_acaoUncheckedUpdateManyWithoutApp_usuarioInput>
  }

  export type app_log_acaoScalarWhereInput = {
    AND?: app_log_acaoScalarWhereInput | app_log_acaoScalarWhereInput[]
    OR?: app_log_acaoScalarWhereInput[]
    NOT?: app_log_acaoScalarWhereInput | app_log_acaoScalarWhereInput[]
    id?: IntFilter<"app_log_acao"> | number
    usuario_id?: IntNullableFilter<"app_log_acao"> | number | null
    acao?: StringNullableFilter<"app_log_acao"> | string | null
    criado_em?: DateTimeNullableFilter<"app_log_acao"> | Date | string | null
  }

  export type app_clinicaUpsertWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    update: XOR<app_clinicaUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUncheckedUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
    create: XOR<app_clinicaCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUncheckedCreateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput, app_clinicaUncheckedUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_clinicaUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUpsertWithoutApp_usuarioInput = {
    update: XOR<app_clinicaUpdateWithoutApp_usuarioInput, app_clinicaUncheckedUpdateWithoutApp_usuarioInput>
    create: XOR<app_clinicaCreateWithoutApp_usuarioInput, app_clinicaUncheckedCreateWithoutApp_usuarioInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_usuarioInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_usuarioInput, app_clinicaUncheckedUpdateWithoutApp_usuarioInput>
  }

  export type app_clinicaUpdateWithoutApp_usuarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
  }

  export type app_conversaCreateWithoutApp_clinicaInput = {
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    app_paciente?: app_pacienteCreateNestedOneWithoutApp_conversaInput
    app_grupo?: app_grupoCreateNestedOneWithoutApp_conversaInput
    app_mensagem?: app_mensagemCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    paciente_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
    app_mensagem?: app_mensagemUncheckedCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaCreateOrConnectWithoutApp_clinicaInput = {
    where: app_conversaWhereUniqueInput
    create: XOR<app_conversaCreateWithoutApp_clinicaInput, app_conversaUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_conversaCreateManyApp_clinicaInputEnvelope = {
    data: app_conversaCreateManyApp_clinicaInput | app_conversaCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_grupoCreateWithoutApp_clinicaInput = {
    jid: string
    nome?: string | null
    criado_em?: Date | string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_grupoInput
  }

  export type app_grupoUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    jid: string
    nome?: string | null
    criado_em?: Date | string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_grupoInput
  }

  export type app_grupoCreateOrConnectWithoutApp_clinicaInput = {
    where: app_grupoWhereUniqueInput
    create: XOR<app_grupoCreateWithoutApp_clinicaInput, app_grupoUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_grupoCreateManyApp_clinicaInputEnvelope = {
    data: app_grupoCreateManyApp_clinicaInput | app_grupoCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_mensagem_sugestaoCreateWithoutApp_clinicaInput = {
    sugestao: string
    criado_em?: Date | string | null
  }

  export type app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    sugestao: string
    criado_em?: Date | string | null
  }

  export type app_mensagem_sugestaoCreateOrConnectWithoutApp_clinicaInput = {
    where: app_mensagem_sugestaoWhereUniqueInput
    create: XOR<app_mensagem_sugestaoCreateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_mensagem_sugestaoCreateManyApp_clinicaInputEnvelope = {
    data: app_mensagem_sugestaoCreateManyApp_clinicaInput | app_mensagem_sugestaoCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_pacienteCreateWithoutApp_clinicaInput = {
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_pacienteInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_pacienteInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteCreateOrConnectWithoutApp_clinicaInput = {
    where: app_pacienteWhereUniqueInput
    create: XOR<app_pacienteCreateWithoutApp_clinicaInput, app_pacienteUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_pacienteCreateManyApp_clinicaInputEnvelope = {
    data: app_pacienteCreateManyApp_clinicaInput | app_pacienteCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_paciente_clinicaCreateWithoutApp_clinicaInput = {
    app_paciente: app_pacienteCreateNestedOneWithoutApp_paciente_clinicaInput
  }

  export type app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput = {
    paciente_id: number
  }

  export type app_paciente_clinicaCreateOrConnectWithoutApp_clinicaInput = {
    where: app_paciente_clinicaWhereUniqueInput
    create: XOR<app_paciente_clinicaCreateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_paciente_clinicaCreateManyApp_clinicaInputEnvelope = {
    data: app_paciente_clinicaCreateManyApp_clinicaInput | app_paciente_clinicaCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_resposta_prontaCreateWithoutApp_clinicaInput = {
    titulo?: string | null
    conteudo?: string | null
    criada_em?: Date | string | null
  }

  export type app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    titulo?: string | null
    conteudo?: string | null
    criada_em?: Date | string | null
  }

  export type app_resposta_prontaCreateOrConnectWithoutApp_clinicaInput = {
    where: app_resposta_prontaWhereUniqueInput
    create: XOR<app_resposta_prontaCreateWithoutApp_clinicaInput, app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_resposta_prontaCreateManyApp_clinicaInputEnvelope = {
    data: app_resposta_prontaCreateManyApp_clinicaInput | app_resposta_prontaCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_tagCreateWithoutApp_clinicaInput = {
    nome?: string | null
    criada_em?: Date | string | null
  }

  export type app_tagUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    nome?: string | null
    criada_em?: Date | string | null
  }

  export type app_tagCreateOrConnectWithoutApp_clinicaInput = {
    where: app_tagWhereUniqueInput
    create: XOR<app_tagCreateWithoutApp_clinicaInput, app_tagUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_tagCreateManyApp_clinicaInputEnvelope = {
    data: app_tagCreateManyApp_clinicaInput | app_tagCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    nome: string
    email: string
    senha: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_log_acao?: app_log_acaoCreateNestedManyWithoutApp_usuarioInput
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_usuarioInput
  }

  export type app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    id?: number
    nome: string
    email: string
    senha: string
    clinica_id?: number | null
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_log_acao?: app_log_acaoUncheckedCreateNestedManyWithoutApp_usuarioInput
  }

  export type app_usuarioCreateOrConnectWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    where: app_usuarioWhereUniqueInput
    create: XOR<app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInputEnvelope = {
    data: app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInput | app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_usuarioCreateWithoutApp_clinicaInput = {
    nome: string
    email: string
    senha: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_log_acao?: app_log_acaoCreateNestedManyWithoutApp_usuarioInput
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaCreateNestedOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput
  }

  export type app_usuarioUncheckedCreateWithoutApp_clinicaInput = {
    id?: number
    nome: string
    email: string
    senha: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinicaId?: number | null
    app_log_acao?: app_log_acaoUncheckedCreateNestedManyWithoutApp_usuarioInput
  }

  export type app_usuarioCreateOrConnectWithoutApp_clinicaInput = {
    where: app_usuarioWhereUniqueInput
    create: XOR<app_usuarioCreateWithoutApp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_usuarioCreateManyApp_clinicaInputEnvelope = {
    data: app_usuarioCreateManyApp_clinicaInput | app_usuarioCreateManyApp_clinicaInput[]
    skipDuplicates?: boolean
  }

  export type app_conversaUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_conversaWhereUniqueInput
    update: XOR<app_conversaUpdateWithoutApp_clinicaInput, app_conversaUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_conversaCreateWithoutApp_clinicaInput, app_conversaUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_conversaUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_conversaWhereUniqueInput
    data: XOR<app_conversaUpdateWithoutApp_clinicaInput, app_conversaUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_conversaUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_conversaScalarWhereInput
    data: XOR<app_conversaUpdateManyMutationInput, app_conversaUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_conversaScalarWhereInput = {
    AND?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
    OR?: app_conversaScalarWhereInput[]
    NOT?: app_conversaScalarWhereInput | app_conversaScalarWhereInput[]
    id?: IntFilter<"app_conversa"> | number
    paciente_id?: IntNullableFilter<"app_conversa"> | number | null
    clinica_id?: IntNullableFilter<"app_conversa"> | number | null
    iniciada_em?: DateTimeNullableFilter<"app_conversa"> | Date | string | null
    atualizada_em?: DateTimeNullableFilter<"app_conversa"> | Date | string | null
    grupo_id?: IntNullableFilter<"app_conversa"> | number | null
  }

  export type app_grupoUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_grupoWhereUniqueInput
    update: XOR<app_grupoUpdateWithoutApp_clinicaInput, app_grupoUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_grupoCreateWithoutApp_clinicaInput, app_grupoUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_grupoUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_grupoWhereUniqueInput
    data: XOR<app_grupoUpdateWithoutApp_clinicaInput, app_grupoUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_grupoUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_grupoScalarWhereInput
    data: XOR<app_grupoUpdateManyMutationInput, app_grupoUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_grupoScalarWhereInput = {
    AND?: app_grupoScalarWhereInput | app_grupoScalarWhereInput[]
    OR?: app_grupoScalarWhereInput[]
    NOT?: app_grupoScalarWhereInput | app_grupoScalarWhereInput[]
    id?: IntFilter<"app_grupo"> | number
    jid?: StringFilter<"app_grupo"> | string
    nome?: StringNullableFilter<"app_grupo"> | string | null
    clinica_id?: IntFilter<"app_grupo"> | number
    criado_em?: DateTimeNullableFilter<"app_grupo"> | Date | string | null
  }

  export type app_mensagem_sugestaoUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_mensagem_sugestaoWhereUniqueInput
    update: XOR<app_mensagem_sugestaoUpdateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_mensagem_sugestaoCreateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_mensagem_sugestaoUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_mensagem_sugestaoWhereUniqueInput
    data: XOR<app_mensagem_sugestaoUpdateWithoutApp_clinicaInput, app_mensagem_sugestaoUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_mensagem_sugestaoUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_mensagem_sugestaoScalarWhereInput
    data: XOR<app_mensagem_sugestaoUpdateManyMutationInput, app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_mensagem_sugestaoScalarWhereInput = {
    AND?: app_mensagem_sugestaoScalarWhereInput | app_mensagem_sugestaoScalarWhereInput[]
    OR?: app_mensagem_sugestaoScalarWhereInput[]
    NOT?: app_mensagem_sugestaoScalarWhereInput | app_mensagem_sugestaoScalarWhereInput[]
    id?: IntFilter<"app_mensagem_sugestao"> | number
    clinica_id?: IntNullableFilter<"app_mensagem_sugestao"> | number | null
    sugestao?: StringFilter<"app_mensagem_sugestao"> | string
    criado_em?: DateTimeNullableFilter<"app_mensagem_sugestao"> | Date | string | null
  }

  export type app_pacienteUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_pacienteWhereUniqueInput
    update: XOR<app_pacienteUpdateWithoutApp_clinicaInput, app_pacienteUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_pacienteCreateWithoutApp_clinicaInput, app_pacienteUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_pacienteUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_pacienteWhereUniqueInput
    data: XOR<app_pacienteUpdateWithoutApp_clinicaInput, app_pacienteUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_pacienteUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_pacienteScalarWhereInput
    data: XOR<app_pacienteUpdateManyMutationInput, app_pacienteUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_pacienteScalarWhereInput = {
    AND?: app_pacienteScalarWhereInput | app_pacienteScalarWhereInput[]
    OR?: app_pacienteScalarWhereInput[]
    NOT?: app_pacienteScalarWhereInput | app_pacienteScalarWhereInput[]
    id?: IntFilter<"app_paciente"> | number
    nome?: StringFilter<"app_paciente"> | string
    email?: StringNullableFilter<"app_paciente"> | string | null
    telefone?: StringFilter<"app_paciente"> | string
    criado_em?: DateTimeNullableFilter<"app_paciente"> | Date | string | null
    atualizado_em?: DateTimeNullableFilter<"app_paciente"> | Date | string | null
    clinica_id?: IntNullableFilter<"app_paciente"> | number | null
  }

  export type app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_paciente_clinicaWhereUniqueInput
    update: XOR<app_paciente_clinicaUpdateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_paciente_clinicaCreateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_paciente_clinicaWhereUniqueInput
    data: XOR<app_paciente_clinicaUpdateWithoutApp_clinicaInput, app_paciente_clinicaUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_paciente_clinicaUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_paciente_clinicaScalarWhereInput
    data: XOR<app_paciente_clinicaUpdateManyMutationInput, app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_paciente_clinicaScalarWhereInput = {
    AND?: app_paciente_clinicaScalarWhereInput | app_paciente_clinicaScalarWhereInput[]
    OR?: app_paciente_clinicaScalarWhereInput[]
    NOT?: app_paciente_clinicaScalarWhereInput | app_paciente_clinicaScalarWhereInput[]
    paciente_id?: IntFilter<"app_paciente_clinica"> | number
    clinica_id?: IntFilter<"app_paciente_clinica"> | number
  }

  export type app_resposta_prontaUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_resposta_prontaWhereUniqueInput
    update: XOR<app_resposta_prontaUpdateWithoutApp_clinicaInput, app_resposta_prontaUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_resposta_prontaCreateWithoutApp_clinicaInput, app_resposta_prontaUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_resposta_prontaUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_resposta_prontaWhereUniqueInput
    data: XOR<app_resposta_prontaUpdateWithoutApp_clinicaInput, app_resposta_prontaUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_resposta_prontaUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_resposta_prontaScalarWhereInput
    data: XOR<app_resposta_prontaUpdateManyMutationInput, app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_resposta_prontaScalarWhereInput = {
    AND?: app_resposta_prontaScalarWhereInput | app_resposta_prontaScalarWhereInput[]
    OR?: app_resposta_prontaScalarWhereInput[]
    NOT?: app_resposta_prontaScalarWhereInput | app_resposta_prontaScalarWhereInput[]
    id?: IntFilter<"app_resposta_pronta"> | number
    clinica_id?: IntNullableFilter<"app_resposta_pronta"> | number | null
    titulo?: StringNullableFilter<"app_resposta_pronta"> | string | null
    conteudo?: StringNullableFilter<"app_resposta_pronta"> | string | null
    criada_em?: DateTimeNullableFilter<"app_resposta_pronta"> | Date | string | null
  }

  export type app_tagUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_tagWhereUniqueInput
    update: XOR<app_tagUpdateWithoutApp_clinicaInput, app_tagUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_tagCreateWithoutApp_clinicaInput, app_tagUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_tagUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_tagWhereUniqueInput
    data: XOR<app_tagUpdateWithoutApp_clinicaInput, app_tagUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_tagUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_tagScalarWhereInput
    data: XOR<app_tagUpdateManyMutationInput, app_tagUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_tagScalarWhereInput = {
    AND?: app_tagScalarWhereInput | app_tagScalarWhereInput[]
    OR?: app_tagScalarWhereInput[]
    NOT?: app_tagScalarWhereInput | app_tagScalarWhereInput[]
    id?: IntFilter<"app_tag"> | number
    nome?: StringNullableFilter<"app_tag"> | string | null
    clinica_id?: IntNullableFilter<"app_tag"> | number | null
    criada_em?: DateTimeNullableFilter<"app_tag"> | Date | string | null
  }

  export type app_usuarioUpsertWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    where: app_usuarioWhereUniqueInput
    update: XOR<app_usuarioUpdateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedUpdateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput>
    create: XOR<app_usuarioCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_usuarioUpdateWithWhereUniqueWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    where: app_usuarioWhereUniqueInput
    data: XOR<app_usuarioUpdateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput, app_usuarioUncheckedUpdateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_usuarioUpdateManyWithWhereWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    where: app_usuarioScalarWhereInput
    data: XOR<app_usuarioUpdateManyMutationInput, app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput>
  }

  export type app_usuarioScalarWhereInput = {
    AND?: app_usuarioScalarWhereInput | app_usuarioScalarWhereInput[]
    OR?: app_usuarioScalarWhereInput[]
    NOT?: app_usuarioScalarWhereInput | app_usuarioScalarWhereInput[]
    id?: IntFilter<"app_usuario"> | number
    nome?: StringFilter<"app_usuario"> | string
    email?: StringFilter<"app_usuario"> | string
    senha?: StringFilter<"app_usuario"> | string
    clinica_id?: IntNullableFilter<"app_usuario"> | number | null
    criado_em?: DateTimeNullableFilter<"app_usuario"> | Date | string | null
    atualizado_em?: DateTimeNullableFilter<"app_usuario"> | Date | string | null
    clinicaId?: IntNullableFilter<"app_usuario"> | number | null
  }

  export type app_usuarioUpsertWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_usuarioWhereUniqueInput
    update: XOR<app_usuarioUpdateWithoutApp_clinicaInput, app_usuarioUncheckedUpdateWithoutApp_clinicaInput>
    create: XOR<app_usuarioCreateWithoutApp_clinicaInput, app_usuarioUncheckedCreateWithoutApp_clinicaInput>
  }

  export type app_usuarioUpdateWithWhereUniqueWithoutApp_clinicaInput = {
    where: app_usuarioWhereUniqueInput
    data: XOR<app_usuarioUpdateWithoutApp_clinicaInput, app_usuarioUncheckedUpdateWithoutApp_clinicaInput>
  }

  export type app_usuarioUpdateManyWithWhereWithoutApp_clinicaInput = {
    where: app_usuarioScalarWhereInput
    data: XOR<app_usuarioUpdateManyMutationInput, app_usuarioUncheckedUpdateManyWithoutApp_clinicaInput>
  }

  export type app_usuarioCreateWithoutApp_log_acaoInput = {
    nome: string
    email: string
    senha: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaCreateNestedOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaInput
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_usuarioInput
  }

  export type app_usuarioUncheckedCreateWithoutApp_log_acaoInput = {
    id?: number
    nome: string
    email: string
    senha: string
    clinica_id?: number | null
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinicaId?: number | null
  }

  export type app_usuarioCreateOrConnectWithoutApp_log_acaoInput = {
    where: app_usuarioWhereUniqueInput
    create: XOR<app_usuarioCreateWithoutApp_log_acaoInput, app_usuarioUncheckedCreateWithoutApp_log_acaoInput>
  }

  export type app_usuarioUpsertWithoutApp_log_acaoInput = {
    update: XOR<app_usuarioUpdateWithoutApp_log_acaoInput, app_usuarioUncheckedUpdateWithoutApp_log_acaoInput>
    create: XOR<app_usuarioCreateWithoutApp_log_acaoInput, app_usuarioUncheckedCreateWithoutApp_log_acaoInput>
    where?: app_usuarioWhereInput
  }

  export type app_usuarioUpdateToOneWithWhereWithoutApp_log_acaoInput = {
    where?: app_usuarioWhereInput
    data: XOR<app_usuarioUpdateWithoutApp_log_acaoInput, app_usuarioUncheckedUpdateWithoutApp_log_acaoInput>
  }

  export type app_usuarioUpdateWithoutApp_log_acaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaUpdateOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_clinica?: app_clinicaUpdateOneWithoutApp_usuarioNestedInput
  }

  export type app_usuarioUncheckedUpdateWithoutApp_log_acaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_clinicaCreateWithoutApp_conversaInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_conversaInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_conversaInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_conversaInput, app_clinicaUncheckedCreateWithoutApp_conversaInput>
  }

  export type app_pacienteCreateWithoutApp_conversaInput = {
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_pacienteInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteUncheckedCreateWithoutApp_conversaInput = {
    id?: number
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinica_id?: number | null
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteCreateOrConnectWithoutApp_conversaInput = {
    where: app_pacienteWhereUniqueInput
    create: XOR<app_pacienteCreateWithoutApp_conversaInput, app_pacienteUncheckedCreateWithoutApp_conversaInput>
  }

  export type app_grupoCreateWithoutApp_conversaInput = {
    jid: string
    nome?: string | null
    criado_em?: Date | string | null
    app_clinica: app_clinicaCreateNestedOneWithoutApp_grupoInput
  }

  export type app_grupoUncheckedCreateWithoutApp_conversaInput = {
    id?: number
    jid: string
    nome?: string | null
    clinica_id: number
    criado_em?: Date | string | null
  }

  export type app_grupoCreateOrConnectWithoutApp_conversaInput = {
    where: app_grupoWhereUniqueInput
    create: XOR<app_grupoCreateWithoutApp_conversaInput, app_grupoUncheckedCreateWithoutApp_conversaInput>
  }

  export type app_mensagemCreateWithoutApp_conversaInput = {
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_midia?: app_midiaCreateNestedManyWithoutApp_mensagemInput
    app_receipt?: app_receiptCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemUncheckedCreateWithoutApp_conversaInput = {
    id?: number
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_midia?: app_midiaUncheckedCreateNestedManyWithoutApp_mensagemInput
    app_receipt?: app_receiptUncheckedCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemCreateOrConnectWithoutApp_conversaInput = {
    where: app_mensagemWhereUniqueInput
    create: XOR<app_mensagemCreateWithoutApp_conversaInput, app_mensagemUncheckedCreateWithoutApp_conversaInput>
  }

  export type app_mensagemCreateManyApp_conversaInputEnvelope = {
    data: app_mensagemCreateManyApp_conversaInput | app_mensagemCreateManyApp_conversaInput[]
    skipDuplicates?: boolean
  }

  export type app_clinicaUpsertWithoutApp_conversaInput = {
    update: XOR<app_clinicaUpdateWithoutApp_conversaInput, app_clinicaUncheckedUpdateWithoutApp_conversaInput>
    create: XOR<app_clinicaCreateWithoutApp_conversaInput, app_clinicaUncheckedCreateWithoutApp_conversaInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_conversaInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_conversaInput, app_clinicaUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_clinicaUpdateWithoutApp_conversaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_conversaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_pacienteUpsertWithoutApp_conversaInput = {
    update: XOR<app_pacienteUpdateWithoutApp_conversaInput, app_pacienteUncheckedUpdateWithoutApp_conversaInput>
    create: XOR<app_pacienteCreateWithoutApp_conversaInput, app_pacienteUncheckedCreateWithoutApp_conversaInput>
    where?: app_pacienteWhereInput
  }

  export type app_pacienteUpdateToOneWithWhereWithoutApp_conversaInput = {
    where?: app_pacienteWhereInput
    data: XOR<app_pacienteUpdateWithoutApp_conversaInput, app_pacienteUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_pacienteUpdateWithoutApp_conversaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_pacienteNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_pacienteUncheckedUpdateWithoutApp_conversaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_grupoUpsertWithoutApp_conversaInput = {
    update: XOR<app_grupoUpdateWithoutApp_conversaInput, app_grupoUncheckedUpdateWithoutApp_conversaInput>
    create: XOR<app_grupoCreateWithoutApp_conversaInput, app_grupoUncheckedCreateWithoutApp_conversaInput>
    where?: app_grupoWhereInput
  }

  export type app_grupoUpdateToOneWithWhereWithoutApp_conversaInput = {
    where?: app_grupoWhereInput
    data: XOR<app_grupoUpdateWithoutApp_conversaInput, app_grupoUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_grupoUpdateWithoutApp_conversaInput = {
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneRequiredWithoutApp_grupoNestedInput
  }

  export type app_grupoUncheckedUpdateWithoutApp_conversaInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    clinica_id?: IntFieldUpdateOperationsInput | number
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagemUpsertWithWhereUniqueWithoutApp_conversaInput = {
    where: app_mensagemWhereUniqueInput
    update: XOR<app_mensagemUpdateWithoutApp_conversaInput, app_mensagemUncheckedUpdateWithoutApp_conversaInput>
    create: XOR<app_mensagemCreateWithoutApp_conversaInput, app_mensagemUncheckedCreateWithoutApp_conversaInput>
  }

  export type app_mensagemUpdateWithWhereUniqueWithoutApp_conversaInput = {
    where: app_mensagemWhereUniqueInput
    data: XOR<app_mensagemUpdateWithoutApp_conversaInput, app_mensagemUncheckedUpdateWithoutApp_conversaInput>
  }

  export type app_mensagemUpdateManyWithWhereWithoutApp_conversaInput = {
    where: app_mensagemScalarWhereInput
    data: XOR<app_mensagemUpdateManyMutationInput, app_mensagemUncheckedUpdateManyWithoutApp_conversaInput>
  }

  export type app_mensagemScalarWhereInput = {
    AND?: app_mensagemScalarWhereInput | app_mensagemScalarWhereInput[]
    OR?: app_mensagemScalarWhereInput[]
    NOT?: app_mensagemScalarWhereInput | app_mensagemScalarWhereInput[]
    id?: IntFilter<"app_mensagem"> | number
    conversa_id?: IntNullableFilter<"app_mensagem"> | number | null
    remetente?: StringNullableFilter<"app_mensagem"> | string | null
    conteudo?: StringNullableFilter<"app_mensagem"> | string | null
    tipo_mensagem?: StringNullableFilter<"app_mensagem"> | string | null
    evolution_id?: StringNullableFilter<"app_mensagem"> | string | null
    status?: StringNullableFilter<"app_mensagem"> | string | null
    criadaEm?: DateTimeNullableFilter<"app_mensagem"> | Date | string | null
  }

  export type app_conversaCreateWithoutApp_mensagemInput = {
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_conversaInput
    app_paciente?: app_pacienteCreateNestedOneWithoutApp_conversaInput
    app_grupo?: app_grupoCreateNestedOneWithoutApp_conversaInput
  }

  export type app_conversaUncheckedCreateWithoutApp_mensagemInput = {
    id?: number
    paciente_id?: number | null
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
  }

  export type app_conversaCreateOrConnectWithoutApp_mensagemInput = {
    where: app_conversaWhereUniqueInput
    create: XOR<app_conversaCreateWithoutApp_mensagemInput, app_conversaUncheckedCreateWithoutApp_mensagemInput>
  }

  export type app_midiaCreateWithoutApp_mensagemInput = {
    tipo?: string | null
    file_url?: string | null
    criado_em?: Date | string | null
    mime_type?: string | null
    caption?: string | null
    duration?: number | null
    file_size?: bigint | number | null
  }

  export type app_midiaUncheckedCreateWithoutApp_mensagemInput = {
    id?: number
    tipo?: string | null
    file_url?: string | null
    criado_em?: Date | string | null
    mime_type?: string | null
    caption?: string | null
    duration?: number | null
    file_size?: bigint | number | null
  }

  export type app_midiaCreateOrConnectWithoutApp_mensagemInput = {
    where: app_midiaWhereUniqueInput
    create: XOR<app_midiaCreateWithoutApp_mensagemInput, app_midiaUncheckedCreateWithoutApp_mensagemInput>
  }

  export type app_midiaCreateManyApp_mensagemInputEnvelope = {
    data: app_midiaCreateManyApp_mensagemInput | app_midiaCreateManyApp_mensagemInput[]
    skipDuplicates?: boolean
  }

  export type app_receiptCreateWithoutApp_mensagemInput = {
    event_type: string
    receipt_time: Date | string
    created_at?: Date | string | null
  }

  export type app_receiptUncheckedCreateWithoutApp_mensagemInput = {
    id?: number
    event_type: string
    receipt_time: Date | string
    created_at?: Date | string | null
  }

  export type app_receiptCreateOrConnectWithoutApp_mensagemInput = {
    where: app_receiptWhereUniqueInput
    create: XOR<app_receiptCreateWithoutApp_mensagemInput, app_receiptUncheckedCreateWithoutApp_mensagemInput>
  }

  export type app_receiptCreateManyApp_mensagemInputEnvelope = {
    data: app_receiptCreateManyApp_mensagemInput | app_receiptCreateManyApp_mensagemInput[]
    skipDuplicates?: boolean
  }

  export type app_conversaUpsertWithoutApp_mensagemInput = {
    update: XOR<app_conversaUpdateWithoutApp_mensagemInput, app_conversaUncheckedUpdateWithoutApp_mensagemInput>
    create: XOR<app_conversaCreateWithoutApp_mensagemInput, app_conversaUncheckedCreateWithoutApp_mensagemInput>
    where?: app_conversaWhereInput
  }

  export type app_conversaUpdateToOneWithWhereWithoutApp_mensagemInput = {
    where?: app_conversaWhereInput
    data: XOR<app_conversaUpdateWithoutApp_mensagemInput, app_conversaUncheckedUpdateWithoutApp_mensagemInput>
  }

  export type app_conversaUpdateWithoutApp_mensagemInput = {
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_conversaNestedInput
    app_paciente?: app_pacienteUpdateOneWithoutApp_conversaNestedInput
    app_grupo?: app_grupoUpdateOneWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateWithoutApp_mensagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_midiaUpsertWithWhereUniqueWithoutApp_mensagemInput = {
    where: app_midiaWhereUniqueInput
    update: XOR<app_midiaUpdateWithoutApp_mensagemInput, app_midiaUncheckedUpdateWithoutApp_mensagemInput>
    create: XOR<app_midiaCreateWithoutApp_mensagemInput, app_midiaUncheckedCreateWithoutApp_mensagemInput>
  }

  export type app_midiaUpdateWithWhereUniqueWithoutApp_mensagemInput = {
    where: app_midiaWhereUniqueInput
    data: XOR<app_midiaUpdateWithoutApp_mensagemInput, app_midiaUncheckedUpdateWithoutApp_mensagemInput>
  }

  export type app_midiaUpdateManyWithWhereWithoutApp_mensagemInput = {
    where: app_midiaScalarWhereInput
    data: XOR<app_midiaUpdateManyMutationInput, app_midiaUncheckedUpdateManyWithoutApp_mensagemInput>
  }

  export type app_midiaScalarWhereInput = {
    AND?: app_midiaScalarWhereInput | app_midiaScalarWhereInput[]
    OR?: app_midiaScalarWhereInput[]
    NOT?: app_midiaScalarWhereInput | app_midiaScalarWhereInput[]
    id?: IntFilter<"app_midia"> | number
    mensagem_id?: IntFilter<"app_midia"> | number
    tipo?: StringNullableFilter<"app_midia"> | string | null
    file_url?: StringNullableFilter<"app_midia"> | string | null
    criado_em?: DateTimeNullableFilter<"app_midia"> | Date | string | null
    mime_type?: StringNullableFilter<"app_midia"> | string | null
    caption?: StringNullableFilter<"app_midia"> | string | null
    duration?: IntNullableFilter<"app_midia"> | number | null
    file_size?: BigIntNullableFilter<"app_midia"> | bigint | number | null
  }

  export type app_receiptUpsertWithWhereUniqueWithoutApp_mensagemInput = {
    where: app_receiptWhereUniqueInput
    update: XOR<app_receiptUpdateWithoutApp_mensagemInput, app_receiptUncheckedUpdateWithoutApp_mensagemInput>
    create: XOR<app_receiptCreateWithoutApp_mensagemInput, app_receiptUncheckedCreateWithoutApp_mensagemInput>
  }

  export type app_receiptUpdateWithWhereUniqueWithoutApp_mensagemInput = {
    where: app_receiptWhereUniqueInput
    data: XOR<app_receiptUpdateWithoutApp_mensagemInput, app_receiptUncheckedUpdateWithoutApp_mensagemInput>
  }

  export type app_receiptUpdateManyWithWhereWithoutApp_mensagemInput = {
    where: app_receiptScalarWhereInput
    data: XOR<app_receiptUpdateManyMutationInput, app_receiptUncheckedUpdateManyWithoutApp_mensagemInput>
  }

  export type app_receiptScalarWhereInput = {
    AND?: app_receiptScalarWhereInput | app_receiptScalarWhereInput[]
    OR?: app_receiptScalarWhereInput[]
    NOT?: app_receiptScalarWhereInput | app_receiptScalarWhereInput[]
    id?: IntFilter<"app_receipt"> | number
    mensagem_id?: IntFilter<"app_receipt"> | number
    event_type?: StringFilter<"app_receipt"> | string
    receipt_time?: DateTimeFilter<"app_receipt"> | Date | string
    created_at?: DateTimeNullableFilter<"app_receipt"> | Date | string | null
  }

  export type app_clinicaCreateWithoutApp_mensagem_sugestaoInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_mensagem_sugestaoInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_mensagem_sugestaoInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_mensagem_sugestaoInput, app_clinicaUncheckedCreateWithoutApp_mensagem_sugestaoInput>
  }

  export type app_clinicaUpsertWithoutApp_mensagem_sugestaoInput = {
    update: XOR<app_clinicaUpdateWithoutApp_mensagem_sugestaoInput, app_clinicaUncheckedUpdateWithoutApp_mensagem_sugestaoInput>
    create: XOR<app_clinicaCreateWithoutApp_mensagem_sugestaoInput, app_clinicaUncheckedCreateWithoutApp_mensagem_sugestaoInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_mensagem_sugestaoInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_mensagem_sugestaoInput, app_clinicaUncheckedUpdateWithoutApp_mensagem_sugestaoInput>
  }

  export type app_clinicaUpdateWithoutApp_mensagem_sugestaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_mensagem_sugestaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_mensagemCreateWithoutApp_midiaInput = {
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_conversa?: app_conversaCreateNestedOneWithoutApp_mensagemInput
    app_receipt?: app_receiptCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemUncheckedCreateWithoutApp_midiaInput = {
    id?: number
    conversa_id?: number | null
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_receipt?: app_receiptUncheckedCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemCreateOrConnectWithoutApp_midiaInput = {
    where: app_mensagemWhereUniqueInput
    create: XOR<app_mensagemCreateWithoutApp_midiaInput, app_mensagemUncheckedCreateWithoutApp_midiaInput>
  }

  export type app_mensagemUpsertWithoutApp_midiaInput = {
    update: XOR<app_mensagemUpdateWithoutApp_midiaInput, app_mensagemUncheckedUpdateWithoutApp_midiaInput>
    create: XOR<app_mensagemCreateWithoutApp_midiaInput, app_mensagemUncheckedCreateWithoutApp_midiaInput>
    where?: app_mensagemWhereInput
  }

  export type app_mensagemUpdateToOneWithWhereWithoutApp_midiaInput = {
    where?: app_mensagemWhereInput
    data: XOR<app_mensagemUpdateWithoutApp_midiaInput, app_mensagemUncheckedUpdateWithoutApp_midiaInput>
  }

  export type app_mensagemUpdateWithoutApp_midiaInput = {
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateOneWithoutApp_mensagemNestedInput
    app_receipt?: app_receiptUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_mensagemUncheckedUpdateWithoutApp_midiaInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversa_id?: NullableIntFieldUpdateOperationsInput | number | null
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_receipt?: app_receiptUncheckedUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_conversaCreateWithoutApp_pacienteInput = {
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_conversaInput
    app_grupo?: app_grupoCreateNestedOneWithoutApp_conversaInput
    app_mensagem?: app_mensagemCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaUncheckedCreateWithoutApp_pacienteInput = {
    id?: number
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
    app_mensagem?: app_mensagemUncheckedCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaCreateOrConnectWithoutApp_pacienteInput = {
    where: app_conversaWhereUniqueInput
    create: XOR<app_conversaCreateWithoutApp_pacienteInput, app_conversaUncheckedCreateWithoutApp_pacienteInput>
  }

  export type app_conversaCreateManyApp_pacienteInputEnvelope = {
    data: app_conversaCreateManyApp_pacienteInput | app_conversaCreateManyApp_pacienteInput[]
    skipDuplicates?: boolean
  }

  export type app_clinicaCreateWithoutApp_pacienteInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_pacienteInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_pacienteInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_pacienteInput, app_clinicaUncheckedCreateWithoutApp_pacienteInput>
  }

  export type app_paciente_clinicaCreateWithoutApp_pacienteInput = {
    app_clinica: app_clinicaCreateNestedOneWithoutApp_paciente_clinicaInput
  }

  export type app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput = {
    clinica_id: number
  }

  export type app_paciente_clinicaCreateOrConnectWithoutApp_pacienteInput = {
    where: app_paciente_clinicaWhereUniqueInput
    create: XOR<app_paciente_clinicaCreateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput>
  }

  export type app_paciente_clinicaCreateManyApp_pacienteInputEnvelope = {
    data: app_paciente_clinicaCreateManyApp_pacienteInput | app_paciente_clinicaCreateManyApp_pacienteInput[]
    skipDuplicates?: boolean
  }

  export type app_conversaUpsertWithWhereUniqueWithoutApp_pacienteInput = {
    where: app_conversaWhereUniqueInput
    update: XOR<app_conversaUpdateWithoutApp_pacienteInput, app_conversaUncheckedUpdateWithoutApp_pacienteInput>
    create: XOR<app_conversaCreateWithoutApp_pacienteInput, app_conversaUncheckedCreateWithoutApp_pacienteInput>
  }

  export type app_conversaUpdateWithWhereUniqueWithoutApp_pacienteInput = {
    where: app_conversaWhereUniqueInput
    data: XOR<app_conversaUpdateWithoutApp_pacienteInput, app_conversaUncheckedUpdateWithoutApp_pacienteInput>
  }

  export type app_conversaUpdateManyWithWhereWithoutApp_pacienteInput = {
    where: app_conversaScalarWhereInput
    data: XOR<app_conversaUpdateManyMutationInput, app_conversaUncheckedUpdateManyWithoutApp_pacienteInput>
  }

  export type app_clinicaUpsertWithoutApp_pacienteInput = {
    update: XOR<app_clinicaUpdateWithoutApp_pacienteInput, app_clinicaUncheckedUpdateWithoutApp_pacienteInput>
    create: XOR<app_clinicaCreateWithoutApp_pacienteInput, app_clinicaUncheckedCreateWithoutApp_pacienteInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_pacienteInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_pacienteInput, app_clinicaUncheckedUpdateWithoutApp_pacienteInput>
  }

  export type app_clinicaUpdateWithoutApp_pacienteInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_pacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_paciente_clinicaUpsertWithWhereUniqueWithoutApp_pacienteInput = {
    where: app_paciente_clinicaWhereUniqueInput
    update: XOR<app_paciente_clinicaUpdateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedUpdateWithoutApp_pacienteInput>
    create: XOR<app_paciente_clinicaCreateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedCreateWithoutApp_pacienteInput>
  }

  export type app_paciente_clinicaUpdateWithWhereUniqueWithoutApp_pacienteInput = {
    where: app_paciente_clinicaWhereUniqueInput
    data: XOR<app_paciente_clinicaUpdateWithoutApp_pacienteInput, app_paciente_clinicaUncheckedUpdateWithoutApp_pacienteInput>
  }

  export type app_paciente_clinicaUpdateManyWithWhereWithoutApp_pacienteInput = {
    where: app_paciente_clinicaScalarWhereInput
    data: XOR<app_paciente_clinicaUpdateManyMutationInput, app_paciente_clinicaUncheckedUpdateManyWithoutApp_pacienteInput>
  }

  export type app_clinicaCreateWithoutApp_paciente_clinicaInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_paciente_clinicaInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_paciente_clinicaInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_paciente_clinicaInput, app_clinicaUncheckedCreateWithoutApp_paciente_clinicaInput>
  }

  export type app_pacienteCreateWithoutApp_paciente_clinicaInput = {
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_pacienteInput
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_pacienteInput
  }

  export type app_pacienteUncheckedCreateWithoutApp_paciente_clinicaInput = {
    id?: number
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinica_id?: number | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_pacienteInput
  }

  export type app_pacienteCreateOrConnectWithoutApp_paciente_clinicaInput = {
    where: app_pacienteWhereUniqueInput
    create: XOR<app_pacienteCreateWithoutApp_paciente_clinicaInput, app_pacienteUncheckedCreateWithoutApp_paciente_clinicaInput>
  }

  export type app_clinicaUpsertWithoutApp_paciente_clinicaInput = {
    update: XOR<app_clinicaUpdateWithoutApp_paciente_clinicaInput, app_clinicaUncheckedUpdateWithoutApp_paciente_clinicaInput>
    create: XOR<app_clinicaCreateWithoutApp_paciente_clinicaInput, app_clinicaUncheckedCreateWithoutApp_paciente_clinicaInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_paciente_clinicaInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_paciente_clinicaInput, app_clinicaUncheckedUpdateWithoutApp_paciente_clinicaInput>
  }

  export type app_clinicaUpdateWithoutApp_paciente_clinicaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_paciente_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_pacienteUpsertWithoutApp_paciente_clinicaInput = {
    update: XOR<app_pacienteUpdateWithoutApp_paciente_clinicaInput, app_pacienteUncheckedUpdateWithoutApp_paciente_clinicaInput>
    create: XOR<app_pacienteCreateWithoutApp_paciente_clinicaInput, app_pacienteUncheckedCreateWithoutApp_paciente_clinicaInput>
    where?: app_pacienteWhereInput
  }

  export type app_pacienteUpdateToOneWithWhereWithoutApp_paciente_clinicaInput = {
    where?: app_pacienteWhereInput
    data: XOR<app_pacienteUpdateWithoutApp_paciente_clinicaInput, app_pacienteUncheckedUpdateWithoutApp_paciente_clinicaInput>
  }

  export type app_pacienteUpdateWithoutApp_paciente_clinicaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_pacienteNestedInput
    app_clinica?: app_clinicaUpdateOneWithoutApp_pacienteNestedInput
  }

  export type app_pacienteUncheckedUpdateWithoutApp_paciente_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_clinicaCreateWithoutApp_resposta_prontaInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_resposta_prontaInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_resposta_prontaInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_resposta_prontaInput, app_clinicaUncheckedCreateWithoutApp_resposta_prontaInput>
  }

  export type app_clinicaUpsertWithoutApp_resposta_prontaInput = {
    update: XOR<app_clinicaUpdateWithoutApp_resposta_prontaInput, app_clinicaUncheckedUpdateWithoutApp_resposta_prontaInput>
    create: XOR<app_clinicaCreateWithoutApp_resposta_prontaInput, app_clinicaUncheckedCreateWithoutApp_resposta_prontaInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_resposta_prontaInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_resposta_prontaInput, app_clinicaUncheckedUpdateWithoutApp_resposta_prontaInput>
  }

  export type app_clinicaUpdateWithoutApp_resposta_prontaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_resposta_prontaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaCreateWithoutApp_tagInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_tagInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_grupo?: app_grupoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_tagInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_tagInput, app_clinicaUncheckedCreateWithoutApp_tagInput>
  }

  export type app_clinicaUpsertWithoutApp_tagInput = {
    update: XOR<app_clinicaUpdateWithoutApp_tagInput, app_clinicaUncheckedUpdateWithoutApp_tagInput>
    create: XOR<app_clinicaCreateWithoutApp_tagInput, app_clinicaUncheckedCreateWithoutApp_tagInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_tagInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_tagInput, app_clinicaUncheckedUpdateWithoutApp_tagInput>
  }

  export type app_clinicaUpdateWithoutApp_tagInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_tagInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_grupo?: app_grupoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type medicosCreateWithoutConsultasInput = {
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    medico_procedimentos?: medico_procedimentosCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasCreateNestedManyWithoutMedicosInput
    especialidades?: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutConsultasInput = {
    id?: number
    nome: string
    especialidade_id?: number | null
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    medico_procedimentos?: medico_procedimentosUncheckedCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutConsultasInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutConsultasInput, medicosUncheckedCreateWithoutConsultasInput>
  }

  export type pacientesCreateWithoutConsultasInput = {
    id?: number
    nome: string
    telefone: string
  }

  export type pacientesUncheckedCreateWithoutConsultasInput = {
    id?: number
    nome: string
    telefone: string
  }

  export type pacientesCreateOrConnectWithoutConsultasInput = {
    where: pacientesWhereUniqueInput
    create: XOR<pacientesCreateWithoutConsultasInput, pacientesUncheckedCreateWithoutConsultasInput>
  }

  export type medicosUpsertWithoutConsultasInput = {
    update: XOR<medicosUpdateWithoutConsultasInput, medicosUncheckedUpdateWithoutConsultasInput>
    create: XOR<medicosCreateWithoutConsultasInput, medicosUncheckedCreateWithoutConsultasInput>
    where?: medicosWhereInput
  }

  export type medicosUpdateToOneWithWhereWithoutConsultasInput = {
    where?: medicosWhereInput
    data: XOR<medicosUpdateWithoutConsultasInput, medicosUncheckedUpdateWithoutConsultasInput>
  }

  export type medicosUpdateWithoutConsultasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    medico_procedimentos?: medico_procedimentosUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutConsultasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especialidade_id?: NullableIntFieldUpdateOperationsInput | number | null
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    medico_procedimentos?: medico_procedimentosUncheckedUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type pacientesUpsertWithoutConsultasInput = {
    update: XOR<pacientesUpdateWithoutConsultasInput, pacientesUncheckedUpdateWithoutConsultasInput>
    create: XOR<pacientesCreateWithoutConsultasInput, pacientesUncheckedCreateWithoutConsultasInput>
    where?: pacientesWhereInput
  }

  export type pacientesUpdateToOneWithWhereWithoutConsultasInput = {
    where?: pacientesWhereInput
    data: XOR<pacientesUpdateWithoutConsultasInput, pacientesUncheckedUpdateWithoutConsultasInput>
  }

  export type pacientesUpdateWithoutConsultasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type pacientesUncheckedUpdateWithoutConsultasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
  }

  export type medicosCreateWithoutEspecialidadesInput = {
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasCreateNestedManyWithoutMedicosInput
    medico_procedimentos?: medico_procedimentosCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasCreateNestedManyWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutEspecialidadesInput = {
    id?: number
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasUncheckedCreateNestedManyWithoutMedicosInput
    medico_procedimentos?: medico_procedimentosUncheckedCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutEspecialidadesInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput>
  }

  export type medicosCreateManyEspecialidadesInputEnvelope = {
    data: medicosCreateManyEspecialidadesInput | medicosCreateManyEspecialidadesInput[]
    skipDuplicates?: boolean
  }

  export type medicosUpsertWithWhereUniqueWithoutEspecialidadesInput = {
    where: medicosWhereUniqueInput
    update: XOR<medicosUpdateWithoutEspecialidadesInput, medicosUncheckedUpdateWithoutEspecialidadesInput>
    create: XOR<medicosCreateWithoutEspecialidadesInput, medicosUncheckedCreateWithoutEspecialidadesInput>
  }

  export type medicosUpdateWithWhereUniqueWithoutEspecialidadesInput = {
    where: medicosWhereUniqueInput
    data: XOR<medicosUpdateWithoutEspecialidadesInput, medicosUncheckedUpdateWithoutEspecialidadesInput>
  }

  export type medicosUpdateManyWithWhereWithoutEspecialidadesInput = {
    where: medicosScalarWhereInput
    data: XOR<medicosUpdateManyMutationInput, medicosUncheckedUpdateManyWithoutEspecialidadesInput>
  }

  export type medicosScalarWhereInput = {
    AND?: medicosScalarWhereInput | medicosScalarWhereInput[]
    OR?: medicosScalarWhereInput[]
    NOT?: medicosScalarWhereInput | medicosScalarWhereInput[]
    id?: IntFilter<"medicos"> | number
    nome?: StringFilter<"medicos"> | string
    especialidade_id?: IntNullableFilter<"medicos"> | number | null
    id_calendario?: StringNullableFilter<"medicos"> | string | null
    dia_atendimento?: StringNullableFilter<"medicos"> | string | null
    metodo_pagamento?: StringNullableFilter<"medicos"> | string | null
  }

  export type medicosCreateWithoutMedico_procedimentosInput = {
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasCreateNestedManyWithoutMedicosInput
    especialidades?: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutMedico_procedimentosInput = {
    id?: number
    nome: string
    especialidade_id?: number | null
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasUncheckedCreateNestedManyWithoutMedicosInput
    medico_sintomas?: medico_sintomasUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutMedico_procedimentosInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutMedico_procedimentosInput, medicosUncheckedCreateWithoutMedico_procedimentosInput>
  }

  export type procedimentosCreateWithoutMedico_procedimentosInput = {
    nome: string
    preco?: Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: string | null
    descricao?: string | null
  }

  export type procedimentosUncheckedCreateWithoutMedico_procedimentosInput = {
    id?: number
    nome: string
    preco?: Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: string | null
    descricao?: string | null
  }

  export type procedimentosCreateOrConnectWithoutMedico_procedimentosInput = {
    where: procedimentosWhereUniqueInput
    create: XOR<procedimentosCreateWithoutMedico_procedimentosInput, procedimentosUncheckedCreateWithoutMedico_procedimentosInput>
  }

  export type medicosUpsertWithoutMedico_procedimentosInput = {
    update: XOR<medicosUpdateWithoutMedico_procedimentosInput, medicosUncheckedUpdateWithoutMedico_procedimentosInput>
    create: XOR<medicosCreateWithoutMedico_procedimentosInput, medicosUncheckedCreateWithoutMedico_procedimentosInput>
    where?: medicosWhereInput
  }

  export type medicosUpdateToOneWithWhereWithoutMedico_procedimentosInput = {
    where?: medicosWhereInput
    data: XOR<medicosUpdateWithoutMedico_procedimentosInput, medicosUncheckedUpdateWithoutMedico_procedimentosInput>
  }

  export type medicosUpdateWithoutMedico_procedimentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutMedico_procedimentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especialidade_id?: NullableIntFieldUpdateOperationsInput | number | null
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUncheckedUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type procedimentosUpsertWithoutMedico_procedimentosInput = {
    update: XOR<procedimentosUpdateWithoutMedico_procedimentosInput, procedimentosUncheckedUpdateWithoutMedico_procedimentosInput>
    create: XOR<procedimentosCreateWithoutMedico_procedimentosInput, procedimentosUncheckedCreateWithoutMedico_procedimentosInput>
    where?: procedimentosWhereInput
  }

  export type procedimentosUpdateToOneWithWhereWithoutMedico_procedimentosInput = {
    where?: procedimentosWhereInput
    data: XOR<procedimentosUpdateWithoutMedico_procedimentosInput, procedimentosUncheckedUpdateWithoutMedico_procedimentosInput>
  }

  export type procedimentosUpdateWithoutMedico_procedimentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type procedimentosUncheckedUpdateWithoutMedico_procedimentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    preco?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempo_estimado?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medicosCreateWithoutMedico_sintomasInput = {
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasCreateNestedManyWithoutMedicosInput
    medico_procedimentos?: medico_procedimentosCreateNestedManyWithoutMedicosInput
    especialidades?: especialidadesCreateNestedOneWithoutMedicosInput
  }

  export type medicosUncheckedCreateWithoutMedico_sintomasInput = {
    id?: number
    nome: string
    especialidade_id?: number | null
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
    consultas?: consultasUncheckedCreateNestedManyWithoutMedicosInput
    medico_procedimentos?: medico_procedimentosUncheckedCreateNestedManyWithoutMedicosInput
  }

  export type medicosCreateOrConnectWithoutMedico_sintomasInput = {
    where: medicosWhereUniqueInput
    create: XOR<medicosCreateWithoutMedico_sintomasInput, medicosUncheckedCreateWithoutMedico_sintomasInput>
  }

  export type sintomasCreateWithoutMedico_sintomasInput = {
    nome: string
    descricao?: string | null
  }

  export type sintomasUncheckedCreateWithoutMedico_sintomasInput = {
    id?: number
    nome: string
    descricao?: string | null
  }

  export type sintomasCreateOrConnectWithoutMedico_sintomasInput = {
    where: sintomasWhereUniqueInput
    create: XOR<sintomasCreateWithoutMedico_sintomasInput, sintomasUncheckedCreateWithoutMedico_sintomasInput>
  }

  export type medicosUpsertWithoutMedico_sintomasInput = {
    update: XOR<medicosUpdateWithoutMedico_sintomasInput, medicosUncheckedUpdateWithoutMedico_sintomasInput>
    create: XOR<medicosCreateWithoutMedico_sintomasInput, medicosUncheckedCreateWithoutMedico_sintomasInput>
    where?: medicosWhereInput
  }

  export type medicosUpdateToOneWithWhereWithoutMedico_sintomasInput = {
    where?: medicosWhereInput
    data: XOR<medicosUpdateWithoutMedico_sintomasInput, medicosUncheckedUpdateWithoutMedico_sintomasInput>
  }

  export type medicosUpdateWithoutMedico_sintomasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUpdateManyWithoutMedicosNestedInput
    medico_procedimentos?: medico_procedimentosUpdateManyWithoutMedicosNestedInput
    especialidades?: especialidadesUpdateOneWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutMedico_sintomasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especialidade_id?: NullableIntFieldUpdateOperationsInput | number | null
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUncheckedUpdateManyWithoutMedicosNestedInput
    medico_procedimentos?: medico_procedimentosUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type sintomasUpsertWithoutMedico_sintomasInput = {
    update: XOR<sintomasUpdateWithoutMedico_sintomasInput, sintomasUncheckedUpdateWithoutMedico_sintomasInput>
    create: XOR<sintomasCreateWithoutMedico_sintomasInput, sintomasUncheckedCreateWithoutMedico_sintomasInput>
    where?: sintomasWhereInput
  }

  export type sintomasUpdateToOneWithWhereWithoutMedico_sintomasInput = {
    where?: sintomasWhereInput
    data: XOR<sintomasUpdateWithoutMedico_sintomasInput, sintomasUncheckedUpdateWithoutMedico_sintomasInput>
  }

  export type sintomasUpdateWithoutMedico_sintomasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sintomasUncheckedUpdateWithoutMedico_sintomasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type consultasCreateWithoutMedicosInput = {
    data_hora: Date | string
    tipo: string
    status?: string
    pacientes?: pacientesCreateNestedOneWithoutConsultasInput
  }

  export type consultasUncheckedCreateWithoutMedicosInput = {
    id?: number
    data_hora: Date | string
    tipo: string
    status?: string
    paciente_id?: string | null
  }

  export type consultasCreateOrConnectWithoutMedicosInput = {
    where: consultasWhereUniqueInput
    create: XOR<consultasCreateWithoutMedicosInput, consultasUncheckedCreateWithoutMedicosInput>
  }

  export type consultasCreateManyMedicosInputEnvelope = {
    data: consultasCreateManyMedicosInput | consultasCreateManyMedicosInput[]
    skipDuplicates?: boolean
  }

  export type medico_procedimentosCreateWithoutMedicosInput = {
    procedimentos: procedimentosCreateNestedOneWithoutMedico_procedimentosInput
  }

  export type medico_procedimentosUncheckedCreateWithoutMedicosInput = {
    id?: number
    procedimento_id: number
  }

  export type medico_procedimentosCreateOrConnectWithoutMedicosInput = {
    where: medico_procedimentosWhereUniqueInput
    create: XOR<medico_procedimentosCreateWithoutMedicosInput, medico_procedimentosUncheckedCreateWithoutMedicosInput>
  }

  export type medico_procedimentosCreateManyMedicosInputEnvelope = {
    data: medico_procedimentosCreateManyMedicosInput | medico_procedimentosCreateManyMedicosInput[]
    skipDuplicates?: boolean
  }

  export type medico_sintomasCreateWithoutMedicosInput = {
    sintomas: sintomasCreateNestedOneWithoutMedico_sintomasInput
  }

  export type medico_sintomasUncheckedCreateWithoutMedicosInput = {
    id?: number
    sintoma_id: number
  }

  export type medico_sintomasCreateOrConnectWithoutMedicosInput = {
    where: medico_sintomasWhereUniqueInput
    create: XOR<medico_sintomasCreateWithoutMedicosInput, medico_sintomasUncheckedCreateWithoutMedicosInput>
  }

  export type medico_sintomasCreateManyMedicosInputEnvelope = {
    data: medico_sintomasCreateManyMedicosInput | medico_sintomasCreateManyMedicosInput[]
    skipDuplicates?: boolean
  }

  export type especialidadesCreateWithoutMedicosInput = {
    nome: string
    descricao?: string | null
  }

  export type especialidadesUncheckedCreateWithoutMedicosInput = {
    id?: number
    nome: string
    descricao?: string | null
  }

  export type especialidadesCreateOrConnectWithoutMedicosInput = {
    where: especialidadesWhereUniqueInput
    create: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
  }

  export type consultasUpsertWithWhereUniqueWithoutMedicosInput = {
    where: consultasWhereUniqueInput
    update: XOR<consultasUpdateWithoutMedicosInput, consultasUncheckedUpdateWithoutMedicosInput>
    create: XOR<consultasCreateWithoutMedicosInput, consultasUncheckedCreateWithoutMedicosInput>
  }

  export type consultasUpdateWithWhereUniqueWithoutMedicosInput = {
    where: consultasWhereUniqueInput
    data: XOR<consultasUpdateWithoutMedicosInput, consultasUncheckedUpdateWithoutMedicosInput>
  }

  export type consultasUpdateManyWithWhereWithoutMedicosInput = {
    where: consultasScalarWhereInput
    data: XOR<consultasUpdateManyMutationInput, consultasUncheckedUpdateManyWithoutMedicosInput>
  }

  export type consultasScalarWhereInput = {
    AND?: consultasScalarWhereInput | consultasScalarWhereInput[]
    OR?: consultasScalarWhereInput[]
    NOT?: consultasScalarWhereInput | consultasScalarWhereInput[]
    id?: IntFilter<"consultas"> | number
    medico_id?: IntNullableFilter<"consultas"> | number | null
    data_hora?: DateTimeFilter<"consultas"> | Date | string
    tipo?: StringFilter<"consultas"> | string
    status?: StringFilter<"consultas"> | string
    paciente_id?: StringNullableFilter<"consultas"> | string | null
  }

  export type medico_procedimentosUpsertWithWhereUniqueWithoutMedicosInput = {
    where: medico_procedimentosWhereUniqueInput
    update: XOR<medico_procedimentosUpdateWithoutMedicosInput, medico_procedimentosUncheckedUpdateWithoutMedicosInput>
    create: XOR<medico_procedimentosCreateWithoutMedicosInput, medico_procedimentosUncheckedCreateWithoutMedicosInput>
  }

  export type medico_procedimentosUpdateWithWhereUniqueWithoutMedicosInput = {
    where: medico_procedimentosWhereUniqueInput
    data: XOR<medico_procedimentosUpdateWithoutMedicosInput, medico_procedimentosUncheckedUpdateWithoutMedicosInput>
  }

  export type medico_procedimentosUpdateManyWithWhereWithoutMedicosInput = {
    where: medico_procedimentosScalarWhereInput
    data: XOR<medico_procedimentosUpdateManyMutationInput, medico_procedimentosUncheckedUpdateManyWithoutMedicosInput>
  }

  export type medico_procedimentosScalarWhereInput = {
    AND?: medico_procedimentosScalarWhereInput | medico_procedimentosScalarWhereInput[]
    OR?: medico_procedimentosScalarWhereInput[]
    NOT?: medico_procedimentosScalarWhereInput | medico_procedimentosScalarWhereInput[]
    id?: IntFilter<"medico_procedimentos"> | number
    medico_id?: IntFilter<"medico_procedimentos"> | number
    procedimento_id?: IntFilter<"medico_procedimentos"> | number
  }

  export type medico_sintomasUpsertWithWhereUniqueWithoutMedicosInput = {
    where: medico_sintomasWhereUniqueInput
    update: XOR<medico_sintomasUpdateWithoutMedicosInput, medico_sintomasUncheckedUpdateWithoutMedicosInput>
    create: XOR<medico_sintomasCreateWithoutMedicosInput, medico_sintomasUncheckedCreateWithoutMedicosInput>
  }

  export type medico_sintomasUpdateWithWhereUniqueWithoutMedicosInput = {
    where: medico_sintomasWhereUniqueInput
    data: XOR<medico_sintomasUpdateWithoutMedicosInput, medico_sintomasUncheckedUpdateWithoutMedicosInput>
  }

  export type medico_sintomasUpdateManyWithWhereWithoutMedicosInput = {
    where: medico_sintomasScalarWhereInput
    data: XOR<medico_sintomasUpdateManyMutationInput, medico_sintomasUncheckedUpdateManyWithoutMedicosInput>
  }

  export type medico_sintomasScalarWhereInput = {
    AND?: medico_sintomasScalarWhereInput | medico_sintomasScalarWhereInput[]
    OR?: medico_sintomasScalarWhereInput[]
    NOT?: medico_sintomasScalarWhereInput | medico_sintomasScalarWhereInput[]
    id?: IntFilter<"medico_sintomas"> | number
    medico_id?: IntFilter<"medico_sintomas"> | number
    sintoma_id?: IntFilter<"medico_sintomas"> | number
  }

  export type especialidadesUpsertWithoutMedicosInput = {
    update: XOR<especialidadesUpdateWithoutMedicosInput, especialidadesUncheckedUpdateWithoutMedicosInput>
    create: XOR<especialidadesCreateWithoutMedicosInput, especialidadesUncheckedCreateWithoutMedicosInput>
    where?: especialidadesWhereInput
  }

  export type especialidadesUpdateToOneWithWhereWithoutMedicosInput = {
    where?: especialidadesWhereInput
    data: XOR<especialidadesUpdateWithoutMedicosInput, especialidadesUncheckedUpdateWithoutMedicosInput>
  }

  export type especialidadesUpdateWithoutMedicosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type especialidadesUncheckedUpdateWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type consultasCreateWithoutPacientesInput = {
    data_hora: Date | string
    tipo: string
    status?: string
    medicos?: medicosCreateNestedOneWithoutConsultasInput
  }

  export type consultasUncheckedCreateWithoutPacientesInput = {
    id?: number
    medico_id?: number | null
    data_hora: Date | string
    tipo: string
    status?: string
  }

  export type consultasCreateOrConnectWithoutPacientesInput = {
    where: consultasWhereUniqueInput
    create: XOR<consultasCreateWithoutPacientesInput, consultasUncheckedCreateWithoutPacientesInput>
  }

  export type consultasCreateManyPacientesInputEnvelope = {
    data: consultasCreateManyPacientesInput | consultasCreateManyPacientesInput[]
    skipDuplicates?: boolean
  }

  export type consultasUpsertWithWhereUniqueWithoutPacientesInput = {
    where: consultasWhereUniqueInput
    update: XOR<consultasUpdateWithoutPacientesInput, consultasUncheckedUpdateWithoutPacientesInput>
    create: XOR<consultasCreateWithoutPacientesInput, consultasUncheckedCreateWithoutPacientesInput>
  }

  export type consultasUpdateWithWhereUniqueWithoutPacientesInput = {
    where: consultasWhereUniqueInput
    data: XOR<consultasUpdateWithoutPacientesInput, consultasUncheckedUpdateWithoutPacientesInput>
  }

  export type consultasUpdateManyWithWhereWithoutPacientesInput = {
    where: consultasScalarWhereInput
    data: XOR<consultasUpdateManyMutationInput, consultasUncheckedUpdateManyWithoutPacientesInput>
  }

  export type medico_procedimentosCreateWithoutProcedimentosInput = {
    medicos: medicosCreateNestedOneWithoutMedico_procedimentosInput
  }

  export type medico_procedimentosUncheckedCreateWithoutProcedimentosInput = {
    id?: number
    medico_id: number
  }

  export type medico_procedimentosCreateOrConnectWithoutProcedimentosInput = {
    where: medico_procedimentosWhereUniqueInput
    create: XOR<medico_procedimentosCreateWithoutProcedimentosInput, medico_procedimentosUncheckedCreateWithoutProcedimentosInput>
  }

  export type medico_procedimentosCreateManyProcedimentosInputEnvelope = {
    data: medico_procedimentosCreateManyProcedimentosInput | medico_procedimentosCreateManyProcedimentosInput[]
    skipDuplicates?: boolean
  }

  export type medico_procedimentosUpsertWithWhereUniqueWithoutProcedimentosInput = {
    where: medico_procedimentosWhereUniqueInput
    update: XOR<medico_procedimentosUpdateWithoutProcedimentosInput, medico_procedimentosUncheckedUpdateWithoutProcedimentosInput>
    create: XOR<medico_procedimentosCreateWithoutProcedimentosInput, medico_procedimentosUncheckedCreateWithoutProcedimentosInput>
  }

  export type medico_procedimentosUpdateWithWhereUniqueWithoutProcedimentosInput = {
    where: medico_procedimentosWhereUniqueInput
    data: XOR<medico_procedimentosUpdateWithoutProcedimentosInput, medico_procedimentosUncheckedUpdateWithoutProcedimentosInput>
  }

  export type medico_procedimentosUpdateManyWithWhereWithoutProcedimentosInput = {
    where: medico_procedimentosScalarWhereInput
    data: XOR<medico_procedimentosUpdateManyMutationInput, medico_procedimentosUncheckedUpdateManyWithoutProcedimentosInput>
  }

  export type medico_sintomasCreateWithoutSintomasInput = {
    medicos: medicosCreateNestedOneWithoutMedico_sintomasInput
  }

  export type medico_sintomasUncheckedCreateWithoutSintomasInput = {
    id?: number
    medico_id: number
  }

  export type medico_sintomasCreateOrConnectWithoutSintomasInput = {
    where: medico_sintomasWhereUniqueInput
    create: XOR<medico_sintomasCreateWithoutSintomasInput, medico_sintomasUncheckedCreateWithoutSintomasInput>
  }

  export type medico_sintomasCreateManySintomasInputEnvelope = {
    data: medico_sintomasCreateManySintomasInput | medico_sintomasCreateManySintomasInput[]
    skipDuplicates?: boolean
  }

  export type medico_sintomasUpsertWithWhereUniqueWithoutSintomasInput = {
    where: medico_sintomasWhereUniqueInput
    update: XOR<medico_sintomasUpdateWithoutSintomasInput, medico_sintomasUncheckedUpdateWithoutSintomasInput>
    create: XOR<medico_sintomasCreateWithoutSintomasInput, medico_sintomasUncheckedCreateWithoutSintomasInput>
  }

  export type medico_sintomasUpdateWithWhereUniqueWithoutSintomasInput = {
    where: medico_sintomasWhereUniqueInput
    data: XOR<medico_sintomasUpdateWithoutSintomasInput, medico_sintomasUncheckedUpdateWithoutSintomasInput>
  }

  export type medico_sintomasUpdateManyWithWhereWithoutSintomasInput = {
    where: medico_sintomasScalarWhereInput
    data: XOR<medico_sintomasUpdateManyMutationInput, medico_sintomasUncheckedUpdateManyWithoutSintomasInput>
  }

  export type app_conversaCreateWithoutApp_grupoInput = {
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    app_clinica?: app_clinicaCreateNestedOneWithoutApp_conversaInput
    app_paciente?: app_pacienteCreateNestedOneWithoutApp_conversaInput
    app_mensagem?: app_mensagemCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaUncheckedCreateWithoutApp_grupoInput = {
    id?: number
    paciente_id?: number | null
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    app_mensagem?: app_mensagemUncheckedCreateNestedManyWithoutApp_conversaInput
  }

  export type app_conversaCreateOrConnectWithoutApp_grupoInput = {
    where: app_conversaWhereUniqueInput
    create: XOR<app_conversaCreateWithoutApp_grupoInput, app_conversaUncheckedCreateWithoutApp_grupoInput>
  }

  export type app_conversaCreateManyApp_grupoInputEnvelope = {
    data: app_conversaCreateManyApp_grupoInput | app_conversaCreateManyApp_grupoInput[]
    skipDuplicates?: boolean
  }

  export type app_clinicaCreateWithoutApp_grupoInput = {
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaUncheckedCreateWithoutApp_grupoInput = {
    id?: number
    nome: string
    endereco?: string | null
    telefone?: string | null
    email?: string | null
    instancia?: string | null
    base_url?: string | null
    criada_em?: Date | string | null
    atualizada_em?: Date | string | null
    tokenEvolution?: string | null
    app_conversa?: app_conversaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente?: app_pacienteUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_resposta_pronta?: app_resposta_prontaUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_tag?: app_tagUncheckedCreateNestedManyWithoutApp_clinicaInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput
    app_usuario?: app_usuarioUncheckedCreateNestedManyWithoutApp_clinicaInput
  }

  export type app_clinicaCreateOrConnectWithoutApp_grupoInput = {
    where: app_clinicaWhereUniqueInput
    create: XOR<app_clinicaCreateWithoutApp_grupoInput, app_clinicaUncheckedCreateWithoutApp_grupoInput>
  }

  export type app_conversaUpsertWithWhereUniqueWithoutApp_grupoInput = {
    where: app_conversaWhereUniqueInput
    update: XOR<app_conversaUpdateWithoutApp_grupoInput, app_conversaUncheckedUpdateWithoutApp_grupoInput>
    create: XOR<app_conversaCreateWithoutApp_grupoInput, app_conversaUncheckedCreateWithoutApp_grupoInput>
  }

  export type app_conversaUpdateWithWhereUniqueWithoutApp_grupoInput = {
    where: app_conversaWhereUniqueInput
    data: XOR<app_conversaUpdateWithoutApp_grupoInput, app_conversaUncheckedUpdateWithoutApp_grupoInput>
  }

  export type app_conversaUpdateManyWithWhereWithoutApp_grupoInput = {
    where: app_conversaScalarWhereInput
    data: XOR<app_conversaUpdateManyMutationInput, app_conversaUncheckedUpdateManyWithoutApp_grupoInput>
  }

  export type app_clinicaUpsertWithoutApp_grupoInput = {
    update: XOR<app_clinicaUpdateWithoutApp_grupoInput, app_clinicaUncheckedUpdateWithoutApp_grupoInput>
    create: XOR<app_clinicaCreateWithoutApp_grupoInput, app_clinicaUncheckedCreateWithoutApp_grupoInput>
    where?: app_clinicaWhereInput
  }

  export type app_clinicaUpdateToOneWithWhereWithoutApp_grupoInput = {
    where?: app_clinicaWhereInput
    data: XOR<app_clinicaUpdateWithoutApp_grupoInput, app_clinicaUncheckedUpdateWithoutApp_grupoInput>
  }

  export type app_clinicaUpdateWithoutApp_grupoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_clinicaUncheckedUpdateWithoutApp_grupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instancia?: NullableStringFieldUpdateOperationsInput | string | null
    base_url?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenEvolution?: NullableStringFieldUpdateOperationsInput | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_mensagem_sugestao?: app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente?: app_pacienteUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_resposta_pronta?: app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_tag?: app_tagUncheckedUpdateManyWithoutApp_clinicaNestedInput
    app_usuario_app_usuario_clinicaIdToapp_clinica?: app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaNestedInput
    app_usuario?: app_usuarioUncheckedUpdateManyWithoutApp_clinicaNestedInput
  }

  export type app_mensagemCreateWithoutApp_receiptInput = {
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_conversa?: app_conversaCreateNestedOneWithoutApp_mensagemInput
    app_midia?: app_midiaCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemUncheckedCreateWithoutApp_receiptInput = {
    id?: number
    conversa_id?: number | null
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
    app_midia?: app_midiaUncheckedCreateNestedManyWithoutApp_mensagemInput
  }

  export type app_mensagemCreateOrConnectWithoutApp_receiptInput = {
    where: app_mensagemWhereUniqueInput
    create: XOR<app_mensagemCreateWithoutApp_receiptInput, app_mensagemUncheckedCreateWithoutApp_receiptInput>
  }

  export type app_mensagemUpsertWithoutApp_receiptInput = {
    update: XOR<app_mensagemUpdateWithoutApp_receiptInput, app_mensagemUncheckedUpdateWithoutApp_receiptInput>
    create: XOR<app_mensagemCreateWithoutApp_receiptInput, app_mensagemUncheckedCreateWithoutApp_receiptInput>
    where?: app_mensagemWhereInput
  }

  export type app_mensagemUpdateToOneWithWhereWithoutApp_receiptInput = {
    where?: app_mensagemWhereInput
    data: XOR<app_mensagemUpdateWithoutApp_receiptInput, app_mensagemUncheckedUpdateWithoutApp_receiptInput>
  }

  export type app_mensagemUpdateWithoutApp_receiptInput = {
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateOneWithoutApp_mensagemNestedInput
    app_midia?: app_midiaUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_mensagemUncheckedUpdateWithoutApp_receiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversa_id?: NullableIntFieldUpdateOperationsInput | number | null
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_midia?: app_midiaUncheckedUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_log_acaoCreateManyApp_usuarioInput = {
    id?: number
    acao?: string | null
    criado_em?: Date | string | null
  }

  export type app_log_acaoUpdateWithoutApp_usuarioInput = {
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_log_acaoUncheckedUpdateWithoutApp_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_log_acaoUncheckedUpdateManyWithoutApp_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    acao?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_conversaCreateManyApp_clinicaInput = {
    id?: number
    paciente_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
  }

  export type app_grupoCreateManyApp_clinicaInput = {
    id?: number
    jid: string
    nome?: string | null
    criado_em?: Date | string | null
  }

  export type app_mensagem_sugestaoCreateManyApp_clinicaInput = {
    id?: number
    sugestao: string
    criado_em?: Date | string | null
  }

  export type app_pacienteCreateManyApp_clinicaInput = {
    id?: number
    nome: string
    email?: string | null
    telefone: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
  }

  export type app_paciente_clinicaCreateManyApp_clinicaInput = {
    paciente_id: number
  }

  export type app_resposta_prontaCreateManyApp_clinicaInput = {
    id?: number
    titulo?: string | null
    conteudo?: string | null
    criada_em?: Date | string | null
  }

  export type app_tagCreateManyApp_clinicaInput = {
    id?: number
    nome?: string | null
    criada_em?: Date | string | null
  }

  export type app_usuarioCreateManyApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    id?: number
    nome: string
    email: string
    senha: string
    clinica_id?: number | null
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
  }

  export type app_usuarioCreateManyApp_clinicaInput = {
    id?: number
    nome: string
    email: string
    senha: string
    criado_em?: Date | string | null
    atualizado_em?: Date | string | null
    clinicaId?: number | null
  }

  export type app_conversaUpdateWithoutApp_clinicaInput = {
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_paciente?: app_pacienteUpdateOneWithoutApp_conversaNestedInput
    app_grupo?: app_grupoUpdateOneWithoutApp_conversaNestedInput
    app_mensagem?: app_mensagemUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
    app_mensagem?: app_mensagemUncheckedUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_grupoUpdateWithoutApp_clinicaInput = {
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_grupoNestedInput
  }

  export type app_grupoUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_grupoNestedInput
  }

  export type app_grupoUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagem_sugestaoUpdateWithoutApp_clinicaInput = {
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagem_sugestaoUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_mensagem_sugestaoUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    sugestao?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_pacienteUpdateWithoutApp_clinicaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUpdateManyWithoutApp_pacienteNestedInput
    app_paciente_clinica?: app_paciente_clinicaUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_pacienteUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_conversa?: app_conversaUncheckedUpdateManyWithoutApp_pacienteNestedInput
    app_paciente_clinica?: app_paciente_clinicaUncheckedUpdateManyWithoutApp_pacienteNestedInput
  }

  export type app_pacienteUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_paciente_clinicaUpdateWithoutApp_clinicaInput = {
    app_paciente?: app_pacienteUpdateOneRequiredWithoutApp_paciente_clinicaNestedInput
  }

  export type app_paciente_clinicaUncheckedUpdateWithoutApp_clinicaInput = {
    paciente_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_paciente_clinicaUncheckedUpdateManyWithoutApp_clinicaInput = {
    paciente_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_resposta_prontaUpdateWithoutApp_clinicaInput = {
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_resposta_prontaUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_resposta_prontaUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_tagUpdateWithoutApp_clinicaInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_tagUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_tagUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    criada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_usuarioUpdateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_log_acao?: app_log_acaoUpdateManyWithoutApp_usuarioNestedInput
    app_clinica?: app_clinicaUpdateOneWithoutApp_usuarioNestedInput
  }

  export type app_usuarioUncheckedUpdateWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_log_acao?: app_log_acaoUncheckedUpdateManyWithoutApp_usuarioNestedInput
  }

  export type app_usuarioUncheckedUpdateManyWithoutApp_clinica_app_usuario_clinicaIdToapp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_usuarioUpdateWithoutApp_clinicaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_log_acao?: app_log_acaoUpdateManyWithoutApp_usuarioNestedInput
    app_clinica_app_usuario_clinicaIdToapp_clinica?: app_clinicaUpdateOneWithoutApp_usuario_app_usuario_clinicaIdToapp_clinicaNestedInput
  }

  export type app_usuarioUncheckedUpdateWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    app_log_acao?: app_log_acaoUncheckedUpdateManyWithoutApp_usuarioNestedInput
  }

  export type app_usuarioUncheckedUpdateManyWithoutApp_clinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_mensagemCreateManyApp_conversaInput = {
    id?: number
    remetente?: string | null
    conteudo?: string | null
    tipo_mensagem?: string | null
    evolution_id?: string | null
    status?: string | null
    criadaEm?: Date | string | null
  }

  export type app_mensagemUpdateWithoutApp_conversaInput = {
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_midia?: app_midiaUpdateManyWithoutApp_mensagemNestedInput
    app_receipt?: app_receiptUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_mensagemUncheckedUpdateWithoutApp_conversaInput = {
    id?: IntFieldUpdateOperationsInput | number
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_midia?: app_midiaUncheckedUpdateManyWithoutApp_mensagemNestedInput
    app_receipt?: app_receiptUncheckedUpdateManyWithoutApp_mensagemNestedInput
  }

  export type app_mensagemUncheckedUpdateManyWithoutApp_conversaInput = {
    id?: IntFieldUpdateOperationsInput | number
    remetente?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_mensagem?: NullableStringFieldUpdateOperationsInput | string | null
    evolution_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    criadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_midiaCreateManyApp_mensagemInput = {
    id?: number
    tipo?: string | null
    file_url?: string | null
    criado_em?: Date | string | null
    mime_type?: string | null
    caption?: string | null
    duration?: number | null
    file_size?: bigint | number | null
  }

  export type app_receiptCreateManyApp_mensagemInput = {
    id?: number
    event_type: string
    receipt_time: Date | string
    created_at?: Date | string | null
  }

  export type app_midiaUpdateWithoutApp_mensagemInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type app_midiaUncheckedUpdateWithoutApp_mensagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type app_midiaUncheckedUpdateManyWithoutApp_mensagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    criado_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type app_receiptUpdateWithoutApp_mensagemInput = {
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_receiptUncheckedUpdateWithoutApp_mensagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_receiptUncheckedUpdateManyWithoutApp_mensagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_type?: StringFieldUpdateOperationsInput | string
    receipt_time?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_conversaCreateManyApp_pacienteInput = {
    id?: number
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
    grupo_id?: number | null
  }

  export type app_paciente_clinicaCreateManyApp_pacienteInput = {
    clinica_id: number
  }

  export type app_conversaUpdateWithoutApp_pacienteInput = {
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_conversaNestedInput
    app_grupo?: app_grupoUpdateOneWithoutApp_conversaNestedInput
    app_mensagem?: app_mensagemUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateWithoutApp_pacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
    app_mensagem?: app_mensagemUncheckedUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateManyWithoutApp_pacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type app_paciente_clinicaUpdateWithoutApp_pacienteInput = {
    app_clinica?: app_clinicaUpdateOneRequiredWithoutApp_paciente_clinicaNestedInput
  }

  export type app_paciente_clinicaUncheckedUpdateWithoutApp_pacienteInput = {
    clinica_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_paciente_clinicaUncheckedUpdateManyWithoutApp_pacienteInput = {
    clinica_id?: IntFieldUpdateOperationsInput | number
  }

  export type medicosCreateManyEspecialidadesInput = {
    id?: number
    nome: string
    id_calendario?: string | null
    dia_atendimento?: string | null
    metodo_pagamento?: string | null
  }

  export type medicosUpdateWithoutEspecialidadesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUpdateManyWithoutMedicosNestedInput
    medico_procedimentos?: medico_procedimentosUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUpdateManyWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateWithoutEspecialidadesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
    consultas?: consultasUncheckedUpdateManyWithoutMedicosNestedInput
    medico_procedimentos?: medico_procedimentosUncheckedUpdateManyWithoutMedicosNestedInput
    medico_sintomas?: medico_sintomasUncheckedUpdateManyWithoutMedicosNestedInput
  }

  export type medicosUncheckedUpdateManyWithoutEspecialidadesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    id_calendario?: NullableStringFieldUpdateOperationsInput | string | null
    dia_atendimento?: NullableStringFieldUpdateOperationsInput | string | null
    metodo_pagamento?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type consultasCreateManyMedicosInput = {
    id?: number
    data_hora: Date | string
    tipo: string
    status?: string
    paciente_id?: string | null
  }

  export type medico_procedimentosCreateManyMedicosInput = {
    id?: number
    procedimento_id: number
  }

  export type medico_sintomasCreateManyMedicosInput = {
    id?: number
    sintoma_id: number
  }

  export type consultasUpdateWithoutMedicosInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pacientes?: pacientesUpdateOneWithoutConsultasNestedInput
  }

  export type consultasUncheckedUpdateWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paciente_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type consultasUncheckedUpdateManyWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paciente_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medico_procedimentosUpdateWithoutMedicosInput = {
    procedimentos?: procedimentosUpdateOneRequiredWithoutMedico_procedimentosNestedInput
  }

  export type medico_procedimentosUncheckedUpdateWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    procedimento_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_procedimentosUncheckedUpdateManyWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    procedimento_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_sintomasUpdateWithoutMedicosInput = {
    sintomas?: sintomasUpdateOneRequiredWithoutMedico_sintomasNestedInput
  }

  export type medico_sintomasUncheckedUpdateWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    sintoma_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_sintomasUncheckedUpdateManyWithoutMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    sintoma_id?: IntFieldUpdateOperationsInput | number
  }

  export type consultasCreateManyPacientesInput = {
    id?: number
    medico_id?: number | null
    data_hora: Date | string
    tipo: string
    status?: string
  }

  export type consultasUpdateWithoutPacientesInput = {
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    medicos?: medicosUpdateOneWithoutConsultasNestedInput
  }

  export type consultasUncheckedUpdateWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: NullableIntFieldUpdateOperationsInput | number | null
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type consultasUncheckedUpdateManyWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: NullableIntFieldUpdateOperationsInput | number | null
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type medico_procedimentosCreateManyProcedimentosInput = {
    id?: number
    medico_id: number
  }

  export type medico_procedimentosUpdateWithoutProcedimentosInput = {
    medicos?: medicosUpdateOneRequiredWithoutMedico_procedimentosNestedInput
  }

  export type medico_procedimentosUncheckedUpdateWithoutProcedimentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_procedimentosUncheckedUpdateManyWithoutProcedimentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_sintomasCreateManySintomasInput = {
    id?: number
    medico_id: number
  }

  export type medico_sintomasUpdateWithoutSintomasInput = {
    medicos?: medicosUpdateOneRequiredWithoutMedico_sintomasNestedInput
  }

  export type medico_sintomasUncheckedUpdateWithoutSintomasInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
  }

  export type medico_sintomasUncheckedUpdateManyWithoutSintomasInput = {
    id?: IntFieldUpdateOperationsInput | number
    medico_id?: IntFieldUpdateOperationsInput | number
  }

  export type app_conversaCreateManyApp_grupoInput = {
    id?: number
    paciente_id?: number | null
    clinica_id?: number | null
    iniciada_em?: Date | string | null
    atualizada_em?: Date | string | null
  }

  export type app_conversaUpdateWithoutApp_grupoInput = {
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_clinica?: app_clinicaUpdateOneWithoutApp_conversaNestedInput
    app_paciente?: app_pacienteUpdateOneWithoutApp_conversaNestedInput
    app_mensagem?: app_mensagemUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateWithoutApp_grupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    app_mensagem?: app_mensagemUncheckedUpdateManyWithoutApp_conversaNestedInput
  }

  export type app_conversaUncheckedUpdateManyWithoutApp_grupoInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: NullableIntFieldUpdateOperationsInput | number | null
    clinica_id?: NullableIntFieldUpdateOperationsInput | number | null
    iniciada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    atualizada_em?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use App_usuarioCountOutputTypeDefaultArgs instead
     */
    export type App_usuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_usuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use App_clinicaCountOutputTypeDefaultArgs instead
     */
    export type App_clinicaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_clinicaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use App_conversaCountOutputTypeDefaultArgs instead
     */
    export type App_conversaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_conversaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use App_mensagemCountOutputTypeDefaultArgs instead
     */
    export type App_mensagemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_mensagemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use App_pacienteCountOutputTypeDefaultArgs instead
     */
    export type App_pacienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_pacienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecialidadesCountOutputTypeDefaultArgs instead
     */
    export type EspecialidadesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecialidadesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicosCountOutputTypeDefaultArgs instead
     */
    export type MedicosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PacientesCountOutputTypeDefaultArgs instead
     */
    export type PacientesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PacientesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedimentosCountOutputTypeDefaultArgs instead
     */
    export type ProcedimentosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedimentosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SintomasCountOutputTypeDefaultArgs instead
     */
    export type SintomasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SintomasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use App_grupoCountOutputTypeDefaultArgs instead
     */
    export type App_grupoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_grupoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_usuarioDefaultArgs instead
     */
    export type app_usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_usuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_clinicaDefaultArgs instead
     */
    export type app_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_clinicaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_log_acaoDefaultArgs instead
     */
    export type app_log_acaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_log_acaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_conversaDefaultArgs instead
     */
    export type app_conversaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_conversaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_mensagemDefaultArgs instead
     */
    export type app_mensagemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_mensagemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_mensagem_sugestaoDefaultArgs instead
     */
    export type app_mensagem_sugestaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_mensagem_sugestaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_midiaDefaultArgs instead
     */
    export type app_midiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_midiaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_pacienteDefaultArgs instead
     */
    export type app_pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_pacienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_paciente_clinicaDefaultArgs instead
     */
    export type app_paciente_clinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_paciente_clinicaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_resposta_prontaDefaultArgs instead
     */
    export type app_resposta_prontaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_resposta_prontaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_tagDefaultArgs instead
     */
    export type app_tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_tagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use consultasDefaultArgs instead
     */
    export type consultasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = consultasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use conversationsDefaultArgs instead
     */
    export type conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = conversationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use documentsDefaultArgs instead
     */
    export type documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = documentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use especialidadesDefaultArgs instead
     */
    export type especialidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = especialidadesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medico_procedimentosDefaultArgs instead
     */
    export type medico_procedimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medico_procedimentosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medico_sintomasDefaultArgs instead
     */
    export type medico_sintomasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medico_sintomasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medicosDefaultArgs instead
     */
    export type medicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medicosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use n8n_chat_historiesDefaultArgs instead
     */
    export type n8n_chat_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = n8n_chat_historiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pacientesDefaultArgs instead
     */
    export type pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pacientesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use procedimentosDefaultArgs instead
     */
    export type procedimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = procedimentosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use schema_migrationsDefaultArgs instead
     */
    export type schema_migrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = schema_migrationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sintomasDefaultArgs instead
     */
    export type sintomasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sintomasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use agent_controlDefaultArgs instead
     */
    export type agent_controlArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = agent_controlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_grupoDefaultArgs instead
     */
    export type app_grupoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_grupoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_receiptDefaultArgs instead
     */
    export type app_receiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_receiptDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}